// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"480Zd":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "2751c5c64de9b498";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"4pp4s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _eventListeners = require("./event-listeners/event-listeners");
var _eventListenersDefault = parcelHelpers.interopDefault(_eventListeners);
(0, _eventListenersDefault.default).function(); // console.log(`${commonServices.getUUID()}`);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L","./event-listeners/event-listeners":"9RtNZ"}],"2IB9L":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"9RtNZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _global = require("../global");
var _constants = require("../constants");
var _elementServices = require("../services/element-services");
var _elementServicesDefault = parcelHelpers.interopDefault(_elementServices);
var _dataServices = require("../services/data-services");
var _elementToolsServices = require("../services/element-tools-services");
let selectedCell, scale = 1, mousePositionOnPaper = {
    top: 0,
    left: 0,
    x: 0,
    y: 0
};
exports.default = {
    function: ()=>{
        // -- toggler
        (0, _constants.togglerRight).addEventListener("click", function() {
            (0, _constants.togglerRight).parentElement.classList.toggle("rf-qna-flow-right-bar-toggler-collapsed");
        });
        (0, _constants.togglerLeft).addEventListener("click", function() {
            (0, _constants.togglerLeft).parentElement.classList.toggle("rf-qna-flow-left-bar-toggler-collapsed");
        });
        // paper events
        (0, _constants.qnaFlowPaper).on("cell:pointerclick", function(elementView) {
            selectedCell = (0, _constants.qnaFlowGraph).getCell(elementView.model.id);
            (()=>{
                selectedCell.isElement() ? (()=>{
                    (0, _constants.elementTopic).value = elementView.model.attributes.attrs.label.text;
                    (0, _constants.elemnentCoordinates).value = elementView.getBBox();
                    toggleClass((0, _constants.togglerRight).parentElement, "rf-qna-flow-right-bar-toggler-collapsed", "rf-qna-flow-right-bar-toggler-collapsed", true);
                })() : (()=>toggleClass((0, _constants.togglerRight).parentElement, "rf-qna-flow-right-bar-toggler-collapsed", "rf-qna-flow-right-bar-toggler-collapsed", false))();
            })();
            setToolsWhenNotSelected();
            elementView.addTools((0, _elementToolsServices.getToolsWhenSelected)(selectedCell.isElement()));
        });
        // evt: Event, x: mouse pointer x coordinate, y: mouse pointer y coordinate
        (0, _constants.qnaFlowPaper).on("blank:pointerclick", (evt, x, y)=>{
            setToolsWhenNotSelected();
            toggleClass((0, _constants.togglerRight).parentElement, "rf-qna-flow-right-bar-toggler-collapsed", "rf-qna-flow-right-bar-toggler-collapsed", false);
        });
        // evt: Event, x: mouse pointer x coordinate, y: mouse pointer y coordinate
        (0, _constants.qnaFlowPaper).on("blank:pointerdown", (evt, x, y)=>{
            mousePositionOnPaper.left = (0, _constants.qnaFlowContainer).scrollLeft;
            mousePositionOnPaper.top = (0, _constants.qnaFlowContainer).scrollTop;
            mousePositionOnPaper.x = x;
            mousePositionOnPaper.y = y;
        });
        (0, _constants.qnaFlowPaper).on("blank:pointerdown", function(event, x, y) {
            mousePositionOnPaper = {
                x: x * scale,
                y: y * scale
            };
        });
        // evt: Event, x: mouse pointer x coordinate, y: mouse pointer y coordinate
        (0, _constants.qnaFlowPaper).on("blank:pointermove", (evt, x, y)=>{
            // let dx = x - mousePositionOnPaper.x;
            // let dy = y - mousePositionOnPaper.y;
            // qnaFlowContainer.scrollLeft = Math.max(
            //     dx,
            //     mousePositionOnPaper.left - dx
            // );
            // qnaFlowContainer.scrollTop = Math.max(
            //     dy,
            //     mousePositionOnPaper.top - dy
            // );
            // console.log(`x: ${scales.sx}, y: ${scales.sy}`);
            (0, _constants.qnaFlowPaper).translate(evt.offsetX - mousePositionOnPaper.x, evt.offsetY - mousePositionOnPaper.y);
        });
        (0, _constants.qnaFlowPaper).on("cell:pointerup blank:pointerup", function(cellView, x, y) {
            // delete mousePositionOnPaper;
            mousePositionOnPaper = {
                top: 0,
                left: 0,
                x: 0,
                y: 0
            };
        });
        // evt: Event, x: mouse pointer x coordinate, y: mouse pointer y coordinate, delta:
        (0, _constants.qnaFlowPaper).on("blank:mousewheel", (evt, x, y, delta)=>zoom(evt, delta));
        // cellView: element view of the selected element
        // evt: Event, x: mouse pointer x coordinate, y: mouse pointer y coordinate
        // delta:
        (0, _constants.qnaFlowPaper).on("cell:mousewheel", (cellView, evt, x, y, delta)=>zoom(evt, delta));
        // Stencil events
        (0, _constants.stencilPaper).on("cell:pointerdown", (cellView, e, x, y)=>{
            (0, _global.$)("body").append('<div id="flyPaper" style="position:fixed;z-index:100;opacity:.7;pointer-event:none;"></div>');
            let flyGraph = new (0, _global.dia).Graph(), flyPaper = new (0, _global.dia).Paper({
                el: (0, _global.$)("#flyPaper"),
                model: flyGraph,
                height: 45,
                width: 80,
                interactive: false
            }), flyShape = cellView.model.clone(), pos = cellView.model.position(), offset = {
                x: x - pos.x,
                y: y - pos.y
            };
            flyShape.position(0, 0);
            flyGraph.addCell(flyShape);
            (0, _global.$)("#flyPaper").offset({
                left: e.pageX - offset.x,
                top: e.pageY - offset.y
            });
            (0, _global.$)("body").on("mousemove.fly", function(e) {
                (0, _global.$)("#flyPaper").offset({
                    left: e.pageX - offset.x,
                    top: e.pageY - offset.y
                });
            });
            (0, _global.$)("body").on("mouseup.fly", function(e) {
                let x = e.pageX, y = e.pageY, target = (0, _constants.qnaFlowPaper).$el.offset();
                // Dropped over paper ?
                if (x > target.left && x < target.left + (0, _constants.qnaFlowPaper).$el.width() && y > target.top && y < target.top + (0, _constants.qnaFlowPaper).$el.height()) {
                    let s = (0, _elementServicesDefault.default).createElement({
                        text: (0, _dataServices.GetAIData)(),
                        x: x - target.left - offset.x,
                        y: y - target.top - offset.y
                    }, "question").addElementTools(true);
                    currentElement = s;
                    (0, _constants.qnaFlowGraph).addCell(s.shape);
                }
                (0, _global.$)("body").off("mousemove.fly").off("mouseup.fly");
                flyShape.remove();
                (0, _global.$)("#flyPaper").remove();
            });
        });
        // Property panel events
        (0, _constants.elementTopic).addEventListener("keyup", (e)=>{
            selectedCell.prop("attrs/label", {
                text: (0, _constants.elementTopic).value
            }, {
                rewrite: true
            });
        });
        // button events
        (0, _constants.scaleToFitButton).addEventListener("click", ()=>{
            // let fitScaleX = 1;
            // let fitScaleY = 1;
            // if (fitScaleX > 0.5 && fitScaleY > 0.5) {
            //     fitScaleX = fitScaleY = 0.6;
            //     qnaFlowPaper.scale(
            //         parseFloat(fitScaleX, 10),
            //         parseFloat(fitScaleY, 10),
            //         0,
            //         0
            //         // contentPaperWidth / 2,
            //         // contentPaperHeight / 2
            //     );
            //     // qnaFlowPaper.translate(0, 0);
            //     console.dir(qnaFlowPaper);
            // } else {
            //     fitScaleX = fitScaleY = 0.8;
            //     qnaFlowPaper.scale(
            //         parseFloat(0.3, 10),
            //         parseFloat(0.3, 10),
            //         0,
            //         0
            //         // contentPaperWidth / 2,
            //         // contentPaperHeight / 2
            //     );
            //     // qnaFlowPaper.translate(0, 0);
            // }
            // qnaFlowPaper.scaleContentToFit({
            //     // padding: padding,
            //     minScale: 0.1,
            //     maxScale: 2.0,
            //     scaleGrid: 0.01,
            //     preserveAspectRatio: true,
            // });
            // log
            console.log(`${(0, _constants.qnaFlowPaper).getContentBBox()}`);
            console.log(`${(0, _constants.qnaFlowPaper).pageOffset()}`);
            console.dir((0, _constants.qnaFlowPaper).checkViewport());
            console.dir((0, _constants.qnaFlowGraph).getElements(2));
            // qnaFlowPaper.matrix({ a: 0.5, b: 0, c: 0, d: 0.5, e: 0, f: 0 });
            (0, _constants.qnaFlowPaper).scale(parseFloat(0.5, 10), parseFloat(0.5, 10), (0, _global.contentPaperWidth) / 2, (0, _global.contentPaperHeight) / 2 //4.2
            );
        // qnaFlowPaper.scaleContentToFit({
        //     minScaleX: 0.3,
        //     minScaleY: 0.3,
        //     maxScaleX: 1,
        //     maxScaleY: 1,
        // });
        });
        (0, _constants.autoArrangeButton).addEventListener("click", ()=>{
            // const cell = qnaFlowPaper.getFirstCell();
            // qnaFlowGraph.resetCells(qnaFlowGraph.getCells());
            if ((0, _global.graphJSON) !== null) (0, _constants.qnaFlowGraph).fromJSON(JSON.parse((0, _global.graphJSON)));
        });
        (0, _constants.saveGraphButton).addEventListener("click", async ()=>{
            (0, _global.setGraphJSON)(JSON.stringify((0, _constants.qnaFlowGraph).toJSON()));
        // Object.assign(graphJSON, qnaFlowGraph.toJSON());
        });
    }
};
const setToolsWhenNotSelected = ()=>{
    (0, _constants.qnaFlowGraph).getCells().forEach((el)=>{
        el.findView((0, _constants.qnaFlowPaper)).addTools((0, _elementToolsServices.getToolsWhenNotSelected)(el.isElement()));
    });
};
const zoom = (evt, delta)=>{
    if (!evt.ctrlKey) return;
    // stop the default behaviour
    evt.preventDefault();
    // if delta < 0 zoom-out else zoom-in
    scale = delta < 0 ? Math.max(0.1, scale - 0.1) : Math.max(0.1, scale + 0.1);
    (0, _constants.qnaFlowPaper).translate(0, 0);
    (0, _constants.qnaFlowPaper).scale(parseFloat(scale, 10), parseFloat(scale, 10), (0, _global.contentPaperWidth) / 2, (0, _global.contentPaperHeight) / 2);
};
const toggleClass = (element, className, query, has)=>{
    (()=>has ? (()=>(0, _constants.togglerRight).parentElement.classList.value.includes(query) ? element.classList.toggle(className) : (()=>{})())() : (()=>!(0, _constants.togglerRight).parentElement.classList.value.includes(query) ? element.classList.toggle(className) : (()=>{})())())();
};

},{"../global":"fagbk","../constants":"1j8D1","../services/element-services":"3KrQq","../services/element-tools-services":"kTyMb","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L","../services/data-services":"9r9WC"}],"fagbk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", ()=>(0, _jqueryMinDefault.default));
parcelHelpers.export(exports, "dia", ()=>(0, _jointMinJs.dia));
parcelHelpers.export(exports, "shapes", ()=>(0, _jointMinJs.shapes));
parcelHelpers.export(exports, "elementTools", ()=>(0, _jointMinJs.elementTools));
parcelHelpers.export(exports, "g", ()=>(0, _jointMinJs.g));
parcelHelpers.export(exports, "V", ()=>(0, _jointMinJs.V));
parcelHelpers.export(exports, "Vectorizer", ()=>(0, _jointMinJs.Vectorizer));
parcelHelpers.export(exports, "ui", ()=>(0, _jointMinJs.ui));
parcelHelpers.export(exports, "dagre", ()=>_dagreMin);
parcelHelpers.export(exports, "grahpLib", ()=>_graphlibMin);
parcelHelpers.export(exports, "gridSize", ()=>gridSize);
parcelHelpers.export(exports, "contentPaperWidth", ()=>contentPaperWidth);
parcelHelpers.export(exports, "contentPaperHeight", ()=>contentPaperHeight);
parcelHelpers.export(exports, "elementWidth", ()=>elementWidth);
parcelHelpers.export(exports, "elementHeight", ()=>elementHeight);
parcelHelpers.export(exports, "portWidth", ()=>portWidth);
parcelHelpers.export(exports, "portHeight", ()=>portHeight);
parcelHelpers.export(exports, "portGap", ()=>portGap);
parcelHelpers.export(exports, "currentElement", ()=>currentElement);
parcelHelpers.export(exports, "graphJSON", ()=>graphJSON);
parcelHelpers.export(exports, "setGraphJSON", ()=>setGraphJSON);
parcelHelpers.export(exports, "aiData", ()=>aiData);
parcelHelpers.export(exports, "diagramData", ()=>diagramData);
var _jqueryMin = require("./lib/jquery/jquery.min");
var _jqueryMinDefault = parcelHelpers.interopDefault(_jqueryMin);
var _jointMinJs = require("./lib/jointjs/joint.min.js");
var _dagreMin = require("./lib/dagre/dagre.min");
var _graphlibMin = require("./lib/dagre/graphlib.min");
const gridSize = 15;
const contentPaperWidth = 6000;
const contentPaperHeight = 3000;
const elementWidth = 300;
const elementHeight = 70;
// const aiData = {
//     AIDataId: "",
//     DiagramId: "",
//     Tag: "",
//     Topic: "",
//     Command: "",
//     Hook: [],
//     QuestionPattern: [],
//     AnswerResponse: [],
//     Fallback: "",
//     Keywords: [[]],
// };
class aiData {
    AIDataId = "";
    DiagramId = "";
    Tag = "";
    Topic = "";
    Command = "";
    Hook = [];
    QuestionPattern = [];
    AnswerResponse = [];
    Fallback = "";
    Keywords = [
        []
    ];
}
class diagramData {
    DiagramId = "";
    UserId = "";
    DiagramJSON = {};
    CreatedOn = "";
    ModifiedOn = "";
}
let graphJSON;
let currentElement;
setGraphJSON = (value)=>{
    graphJSON = value;
};
window.elementPostiontX = 60;
window.elementPostiontY = 100;
window.elementCount = 0;

},{"./lib/jquery/jquery.min":"4QkNZ","./lib/jointjs/joint.min.js":"67La9","./lib/dagre/dagre.min":"4DuVy","./lib/dagre/graphlib.min":"1p6vn","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"4QkNZ":[function(require,module,exports) {
/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e, t) {
    "use strict";
    "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
        if (!e.document) throw new Error("jQuery requires a window with a document");
        return t(e);
    } : t(e);
}("undefined" != typeof window ? window : this, function(C, e) {
    "use strict";
    var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function(e) {
        return t.flat.call(e);
    } : function(e) {
        return t.concat.apply([], e);
    }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function(e) {
        return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item;
    }, x = function(e) {
        return null != e && e === e.window;
    }, E = C.document, c = {
        type: !0,
        src: !0,
        nonce: !0,
        noModule: !0
    };
    function b(e, t, n) {
        var r, i, o = (n = n || E).createElement("script");
        if (o.text = e, t) for(r in c)(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
        n.head.appendChild(o).parentNode.removeChild(o);
    }
    function w(e) {
        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e;
    }
    var f = "3.6.0", S = function(e, t) {
        return new S.fn.init(e, t);
    };
    function p(e) {
        var t = !!e && "length" in e && e.length, n = w(e);
        return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e);
    }
    S.fn = S.prototype = {
        jquery: f,
        constructor: S,
        length: 0,
        toArray: function() {
            return s.call(this);
        },
        get: function(e) {
            return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e];
        },
        pushStack: function(e) {
            var t = S.merge(this.constructor(), e);
            return t.prevObject = this, t;
        },
        each: function(e) {
            return S.each(this, e);
        },
        map: function(n) {
            return this.pushStack(S.map(this, function(e, t) {
                return n.call(e, t, e);
            }));
        },
        slice: function() {
            return this.pushStack(s.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        even: function() {
            return this.pushStack(S.grep(this, function(e, t) {
                return (t + 1) % 2;
            }));
        },
        odd: function() {
            return this.pushStack(S.grep(this, function(e, t) {
                return t % 2;
            }));
        },
        eq: function(e) {
            var t = this.length, n = +e + (e < 0 ? t : 0);
            return this.pushStack(0 <= n && n < t ? [
                this[n]
            ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: u,
        sort: t.sort,
        splice: t.splice
    }, S.extend = S.fn.extend = function() {
        var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1;
        for("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for(t in e)r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r));
        return a;
    }, S.extend({
        expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(e) {
            throw new Error(e);
        },
        noop: function() {},
        isPlainObject: function(e) {
            var t, n;
            return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l);
        },
        isEmptyObject: function(e) {
            var t;
            for(t in e)return !1;
            return !0;
        },
        globalEval: function(e, t, n) {
            b(e, {
                nonce: t && t.nonce
            }, n);
        },
        each: function(e, t) {
            var n, r = 0;
            if (p(e)) {
                for(n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break;
            } else for(r in e)if (!1 === t.call(e[r], r, e[r])) break;
            return e;
        },
        makeArray: function(e, t) {
            var n = t || [];
            return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [
                e
            ] : e) : u.call(n, e)), n;
        },
        inArray: function(e, t, n) {
            return null == t ? -1 : i.call(t, e, n);
        },
        merge: function(e, t) {
            for(var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r];
            return e.length = i, e;
        },
        grep: function(e, t, n) {
            for(var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]);
            return r;
        },
        map: function(e, t, n) {
            var r, i, o = 0, a = [];
            if (p(e)) for(r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && a.push(i);
            else for(o in e)null != (i = t(e[o], o, n)) && a.push(i);
            return g(a);
        },
        guid: 1,
        support: y
    }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
        n["[object " + t + "]"] = t.toLowerCase();
    });
    var d = function(n) {
        var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "sizzle" + 1 * new Date, p = n.document, k = 0, r = 0, m = ue(), x = ue(), A = ue(), N = ue(), j = function(e, t) {
            return e === t && (l = !0), 0;
        }, D = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = function(e, t) {
            for(var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n;
            return -1;
        }, R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]", F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)", B = new RegExp(M + "+", "g"), $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), _ = new RegExp("^" + M + "*," + M + "*"), z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp(M + "|>"), X = new RegExp(F), V = new RegExp("^" + I + "$"), G = {
            ID: new RegExp("^#(" + I + ")"),
            CLASS: new RegExp("^\\.(" + I + ")"),
            TAG: new RegExp("^(" + I + "|[*])"),
            ATTR: new RegExp("^" + W),
            PSEUDO: new RegExp("^" + F),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + R + ")$", "i"),
            needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
        }, Y = /HTML$/i, Q = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"), ne = function(e, t) {
            var n = "0x" + e.slice(1) - 65536;
            return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320));
        }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function(e, t) {
            return t ? "\0" === e ? "ÔøΩ" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e;
        }, oe = function() {
            T();
        }, ae = be(function(e) {
            return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase();
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType;
        } catch (e1) {
            H = {
                apply: t.length ? function(e, t) {
                    L.apply(e, O.call(t));
                } : function(e, t) {
                    var n = e.length, r = 0;
                    while(e[n++] = t[r++]);
                    e.length = n - 1;
                }
            };
        }
        function se(t, e, n, r) {
            var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e ? e.nodeType : 9;
            if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;
            if (!r && (T(e), e = e || C, E)) {
                if (11 !== p && (u = Z.exec(t))) {
                    if (i = u[1]) {
                        if (9 === p) {
                            if (!(a = e.getElementById(i))) return n;
                            if (a.id === i) return n.push(a), n;
                        } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n;
                    } else {
                        if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n;
                        if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n;
                    }
                }
                if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
                    if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) {
                        (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length;
                        while(o--)l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]);
                        c = l.join(",");
                    }
                    try {
                        return H.apply(n, f.querySelectorAll(c)), n;
                    } catch (e1) {
                        N(t, !0);
                    } finally{
                        s === S && e.removeAttribute("id");
                    }
                }
            }
            return g(t.replace($, "$1"), e, n, r);
        }
        function ue() {
            var r = [];
            return function e(t, n) {
                return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n;
            };
        }
        function le(e) {
            return e[S] = !0, e;
        }
        function ce(e) {
            var t = C.createElement("fieldset");
            try {
                return !!e(t);
            } catch (e1) {
                return !1;
            } finally{
                t.parentNode && t.parentNode.removeChild(t), t = null;
            }
        }
        function fe(e, t) {
            var n = e.split("|"), r = n.length;
            while(r--)b.attrHandle[n[r]] = t;
        }
        function pe(e, t) {
            var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
            if (r) return r;
            if (n) {
                while(n = n.nextSibling)if (n === t) return -1;
            }
            return e ? 1 : -1;
        }
        function de(t) {
            return function(e) {
                return "input" === e.nodeName.toLowerCase() && e.type === t;
            };
        }
        function he(n) {
            return function(e) {
                var t = e.nodeName.toLowerCase();
                return ("input" === t || "button" === t) && e.type === n;
            };
        }
        function ge(t) {
            return function(e) {
                return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t;
            };
        }
        function ve(a) {
            return le(function(o) {
                return o = +o, le(function(e, t) {
                    var n, r = a([], e.length, o), i = r.length;
                    while(i--)e[n = r[i]] && (e[n] = !(t[n] = e[n]));
                });
            });
        }
        function ye(e) {
            return e && "undefined" != typeof e.getElementsByTagName && e;
        }
        for(e in d = se.support = {}, i = se.isXML = function(e) {
            var t = e && e.namespaceURI, n = e && (e.ownerDocument || e).documentElement;
            return !Y.test(t || n && n.nodeName || "HTML");
        }, T = se.setDocument = function(e) {
            var t, n, r = e ? e.ownerDocument || e : p;
            return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function(e) {
                return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length;
            }), d.attributes = ce(function(e) {
                return e.className = "i", !e.getAttribute("className");
            }), d.getElementsByTagName = ce(function(e) {
                return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length;
            }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function(e) {
                return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length;
            }), d.getById ? (b.filter.ID = function(e) {
                var t = e.replace(te, ne);
                return function(e) {
                    return e.getAttribute("id") === t;
                };
            }, b.find.ID = function(e, t) {
                if ("undefined" != typeof t.getElementById && E) {
                    var n = t.getElementById(e);
                    return n ? [
                        n
                    ] : [];
                }
            }) : (b.filter.ID = function(e) {
                var n = e.replace(te, ne);
                return function(e) {
                    var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                    return t && t.value === n;
                };
            }, b.find.ID = function(e, t) {
                if ("undefined" != typeof t.getElementById && E) {
                    var n, r, i, o = t.getElementById(e);
                    if (o) {
                        if ((n = o.getAttributeNode("id")) && n.value === e) return [
                            o
                        ];
                        i = t.getElementsByName(e), r = 0;
                        while(o = i[r++])if ((n = o.getAttributeNode("id")) && n.value === e) return [
                            o
                        ];
                    }
                    return [];
                }
            }), b.find.TAG = d.getElementsByTagName ? function(e, t) {
                return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0;
            } : function(e, t) {
                var n, r = [], i = 0, o = t.getElementsByTagName(e);
                if ("*" === e) {
                    while(n = o[i++])1 === n.nodeType && r.push(n);
                    return r;
                }
                return o;
            }, b.find.CLASS = d.getElementsByClassName && function(e, t) {
                if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e);
            }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function(e) {
                var t;
                a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]");
            }), ce(function(e) {
                e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var t = C.createElement("input");
                t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:");
            })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function(e) {
                d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F);
            }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function(e, t) {
                var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode;
                return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
            } : function(e, t) {
                if (t) {
                    while(t = t.parentNode)if (t === e) return !0;
                }
                return !1;
            }, j = t ? function(e, t) {
                if (e === t) return l = !0, 0;
                var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1);
            } : function(e, t) {
                if (e === t) return l = !0, 0;
                var n, r = 0, i = e.parentNode, o = t.parentNode, a = [
                    e
                ], s = [
                    t
                ];
                if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
                if (i === o) return pe(e, t);
                n = e;
                while(n = n.parentNode)a.unshift(n);
                n = t;
                while(n = n.parentNode)s.unshift(n);
                while(a[r] === s[r])r++;
                return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0;
            }), C;
        }, se.matches = function(e, t) {
            return se(e, null, null, t);
        }, se.matchesSelector = function(e, t) {
            if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try {
                var n = c.call(e, t);
                if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n;
            } catch (e1) {
                N(t, !0);
            }
            return 0 < se(t, C, null, [
                e
            ]).length;
        }, se.contains = function(e, t) {
            return (e.ownerDocument || e) != C && T(e), y(e, t);
        }, se.attr = function(e, t) {
            (e.ownerDocument || e) != C && T(e);
            var n = b.attrHandle[t.toLowerCase()], r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
            return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
        }, se.escape = function(e) {
            return (e + "").replace(re, ie);
        }, se.error = function(e) {
            throw new Error("Syntax error, unrecognized expression: " + e);
        }, se.uniqueSort = function(e) {
            var t, n = [], r = 0, i = 0;
            if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) {
                while(t = e[i++])t === e[i] && (r = n.push(i));
                while(r--)e.splice(n[r], 1);
            }
            return u = null, e;
        }, o = se.getText = function(e) {
            var t, n = "", r = 0, i = e.nodeType;
            if (i) {
                if (1 === i || 9 === i || 11 === i) {
                    if ("string" == typeof e.textContent) return e.textContent;
                    for(e = e.firstChild; e; e = e.nextSibling)n += o(e);
                } else if (3 === i || 4 === i) return e.nodeValue;
            } else while(t = e[r++])n += o(t);
            return n;
        }, (b = se.selectors = {
            cacheLength: 50,
            createPseudo: le,
            match: G,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(e) {
                    return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
                },
                CHILD: function(e) {
                    return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e;
                },
                PSEUDO: function(e) {
                    var t, n = !e[6] && e[2];
                    return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3));
                }
            },
            filter: {
                TAG: function(e) {
                    var t = e.replace(te, ne).toLowerCase();
                    return "*" === e ? function() {
                        return !0;
                    } : function(e) {
                        return e.nodeName && e.nodeName.toLowerCase() === t;
                    };
                },
                CLASS: function(e) {
                    var t = m[e + " "];
                    return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)"), m(e, function(e) {
                        return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "");
                    }));
                },
                ATTR: function(n, r, i) {
                    return function(e) {
                        var t = se.attr(e, n);
                        return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"));
                    };
                },
                CHILD: function(h, e, t, g, v) {
                    var y = "nth" !== h.slice(0, 3), m = "last" !== h.slice(-4), x = "of-type" === e;
                    return 1 === g && 0 === v ? function(e) {
                        return !!e.parentNode;
                    } : function(e, t, n) {
                        var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase(), p = !n && !x, d = !1;
                        if (c) {
                            if (y) {
                                while(l){
                                    a = e;
                                    while(a = a[l])if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1;
                                    u = l = "only" === h && !u && "nextSibling";
                                }
                                return !0;
                            }
                            if (u = [
                                m ? c.firstChild : c.lastChild
                            ], m && p) {
                                d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s];
                                while(a = ++s && a && a[l] || (d = s = 0) || u.pop())if (1 === a.nodeType && ++d && a === e) {
                                    i[h] = [
                                        k,
                                        s,
                                        d
                                    ];
                                    break;
                                }
                            } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) {
                                while(a = ++s && a && a[l] || (d = s = 0) || u.pop())if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [
                                    k,
                                    d
                                ]), a === e)) break;
                            }
                            return (d -= v) === g || d % g == 0 && 0 <= d / g;
                        }
                    };
                },
                PSEUDO: function(e, o) {
                    var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
                    return a[S] ? a(o) : 1 < a.length ? (t = [
                        e,
                        e,
                        "",
                        o
                    ], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function(e, t) {
                        var n, r = a(e, o), i = r.length;
                        while(i--)e[n = P(e, r[i])] = !(t[n] = r[i]);
                    }) : function(e) {
                        return a(e, 0, t);
                    }) : a;
                }
            },
            pseudos: {
                not: le(function(e) {
                    var r = [], i = [], s = f(e.replace($, "$1"));
                    return s[S] ? le(function(e, t, n, r) {
                        var i, o = s(e, null, r, []), a = e.length;
                        while(a--)(i = o[a]) && (e[a] = !(t[a] = i));
                    }) : function(e, t, n) {
                        return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop();
                    };
                }),
                has: le(function(t) {
                    return function(e) {
                        return 0 < se(t, e).length;
                    };
                }),
                contains: le(function(t) {
                    return t = t.replace(te, ne), function(e) {
                        return -1 < (e.textContent || o(e)).indexOf(t);
                    };
                }),
                lang: le(function(n) {
                    return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function(e) {
                        var t;
                        do {
                            if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-");
                        }while ((e = e.parentNode) && 1 === e.nodeType);
                        return !1;
                    };
                }),
                target: function(e) {
                    var t = n.location && n.location.hash;
                    return t && t.slice(1) === e.id;
                },
                root: function(e) {
                    return e === a;
                },
                focus: function(e) {
                    return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
                },
                enabled: ge(!1),
                disabled: ge(!0),
                checked: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && !!e.checked || "option" === t && !!e.selected;
                },
                selected: function(e) {
                    return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
                },
                empty: function(e) {
                    for(e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(e) {
                    return !b.pseudos.empty(e);
                },
                header: function(e) {
                    return J.test(e.nodeName);
                },
                input: function(e) {
                    return Q.test(e.nodeName);
                },
                button: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && "button" === e.type || "button" === t;
                },
                text: function(e) {
                    var t;
                    return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
                },
                first: ve(function() {
                    return [
                        0
                    ];
                }),
                last: ve(function(e, t) {
                    return [
                        t - 1
                    ];
                }),
                eq: ve(function(e, t, n) {
                    return [
                        n < 0 ? n + t : n
                    ];
                }),
                even: ve(function(e, t) {
                    for(var n = 0; n < t; n += 2)e.push(n);
                    return e;
                }),
                odd: ve(function(e, t) {
                    for(var n = 1; n < t; n += 2)e.push(n);
                    return e;
                }),
                lt: ve(function(e, t, n) {
                    for(var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;)e.push(r);
                    return e;
                }),
                gt: ve(function(e, t, n) {
                    for(var r = n < 0 ? n + t : n; ++r < t;)e.push(r);
                    return e;
                })
            }
        }).pseudos.nth = b.pseudos.eq, {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        })b.pseudos[e] = de(e);
        for(e in {
            submit: !0,
            reset: !0
        })b.pseudos[e] = he(e);
        function me() {}
        function xe(e) {
            for(var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value;
            return r;
        }
        function be(s, e, t) {
            var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r++;
            return e.first ? function(e, t, n) {
                while(e = e[u])if (1 === e.nodeType || f) return s(e, t, n);
                return !1;
            } : function(e, t, n) {
                var r, i, o, a = [
                    k,
                    p
                ];
                if (n) {
                    while(e = e[u])if ((1 === e.nodeType || f) && s(e, t, n)) return !0;
                } else while(e = e[u])if (1 === e.nodeType || f) {
                    if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e;
                    else {
                        if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2];
                        if ((i[c] = a)[2] = s(e, t, n)) return !0;
                    }
                }
                return !1;
            };
        }
        function we(i) {
            return 1 < i.length ? function(e, t, n) {
                var r = i.length;
                while(r--)if (!i[r](e, t, n)) return !1;
                return !0;
            } : i[0];
        }
        function Te(e, t, n, r, i) {
            for(var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
            return a;
        }
        function Ce(d, h, g, v, y, e) {
            return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function(e, t, n, r) {
                var i, o, a, s = [], u = [], l = t.length, c = e || function(e, t, n) {
                    for(var r = 0, i = t.length; r < i; r++)se(e, t[r], n);
                    return n;
                }(h || "*", n.nodeType ? [
                    n
                ] : n, []), f = !d || !e && h ? c : Te(c, s, d, n, r), p = g ? y || (e ? d : l || v) ? [] : t : f;
                if (g && g(f, p, n, r), v) {
                    i = Te(p, u), v(i, [], n, r), o = i.length;
                    while(o--)(a = i[o]) && (p[u[o]] = !(f[u[o]] = a));
                }
                if (e) {
                    if (y || d) {
                        if (y) {
                            i = [], o = p.length;
                            while(o--)(a = p[o]) && i.push(f[o] = a);
                            y(null, p = [], i, r);
                        }
                        o = p.length;
                        while(o--)(a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a));
                    }
                } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p);
            });
        }
        function Ee(e) {
            for(var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function(e) {
                return e === i;
            }, a, !0), l = be(function(e) {
                return -1 < P(i, e);
            }, a, !0), c = [
                function(e, t, n) {
                    var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
                    return i = null, r;
                }
            ]; s < r; s++)if (t = b.relative[e[s].type]) c = [
                be(we(c), t)
            ];
            else {
                if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) {
                    for(n = ++s; n < r; n++)if (b.relative[e[n].type]) break;
                    return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({
                        value: " " === e[s - 2].type ? "*" : ""
                    })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e));
                }
                c.push(t);
            }
            return we(c);
        }
        return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function(e, t) {
            var n, r, i, o, a, s, u, l = x[e + " "];
            if (l) return t ? 0 : l.slice(0);
            a = e, s = [], u = b.preFilter;
            while(a){
                for(o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({
                    value: n,
                    type: r[0].replace($, " ")
                }), a = a.slice(n.length)), b.filter)!(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
                    value: n,
                    type: o,
                    matches: r
                }), a = a.slice(n.length));
                if (!n) break;
            }
            return t ? a.length : a ? se.error(e) : x(e, s).slice(0);
        }, f = se.compile = function(e, t) {
            var n, v, y, m, x, r, i = [], o = [], a = A[e + " "];
            if (!a) {
                t || (t = h(e)), n = t.length;
                while(n--)(a = Ee(t[n]))[S] ? i.push(a) : o.push(a);
                (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function(e, t, n, r, i) {
                    var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG("*", i), h = k += null == p ? 1 : Math.random() || .1, g = d.length;
                    for(i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++){
                        if (x && o) {
                            a = 0, t || o.ownerDocument == C || (T(o), n = !E);
                            while(s = v[a++])if (s(o, t || C, n)) {
                                r.push(o);
                                break;
                            }
                            i && (k = h);
                        }
                        m && ((o = !s && o) && u--, e && c.push(o));
                    }
                    if (u += l, m && l !== u) {
                        a = 0;
                        while(s = y[a++])s(c, f, t, n);
                        if (e) {
                            if (0 < u) while(l--)c[l] || f[l] || (f[l] = q.call(r));
                            f = Te(f);
                        }
                        H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r);
                    }
                    return i && (k = h, w = p), c;
                }, m ? le(r) : r))).selector = e;
            }
            return a;
        }, g = se.select = function(e, t, n, r) {
            var i, o, a, s, u, l = "function" == typeof e && e, c = !r && h(e = l.selector || e);
            if (n = n || [], 1 === c.length) {
                if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
                    if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n;
                    l && (t = t.parentNode), e = e.slice(o.shift().value.length);
                }
                i = G.needsContext.test(e) ? 0 : o.length;
                while(i--){
                    if (a = o[i], b.relative[s = a.type]) break;
                    if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) {
                        if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n;
                        break;
                    }
                }
            }
            return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n;
        }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function(e) {
            return 1 & e.compareDocumentPosition(C.createElement("fieldset"));
        }), ce(function(e) {
            return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
        }) || fe("type|href|height|width", function(e, t, n) {
            if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
        }), d.attributes && ce(function(e) {
            return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
        }) || fe("value", function(e, t, n) {
            if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
        }), ce(function(e) {
            return null == e.getAttribute("disabled");
        }) || fe(R, function(e, t, n) {
            var r;
            if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
        }), se;
    }(C);
    S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape;
    var h = function(e, t, n) {
        var r = [], i = void 0 !== n;
        while((e = e[t]) && 9 !== e.nodeType)if (1 === e.nodeType) {
            if (i && S(e).is(n)) break;
            r.push(e);
        }
        return r;
    }, T = function(e, t) {
        for(var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e);
        return n;
    }, k = S.expr.match.needsContext;
    function A(e, t) {
        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
    }
    var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function j(e, n, r) {
        return m(n) ? S.grep(e, function(e, t) {
            return !!n.call(e, t, e) !== r;
        }) : n.nodeType ? S.grep(e, function(e) {
            return e === n !== r;
        }) : "string" != typeof n ? S.grep(e, function(e) {
            return -1 < i.call(n, e) !== r;
        }) : S.filter(n, e, r);
    }
    S.filter = function(e, t, n) {
        var r = t[0];
        return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [
            r
        ] : [] : S.find.matches(e, S.grep(t, function(e) {
            return 1 === e.nodeType;
        }));
    }, S.fn.extend({
        find: function(e) {
            var t, n, r = this.length, i = this;
            if ("string" != typeof e) return this.pushStack(S(e).filter(function() {
                for(t = 0; t < r; t++)if (S.contains(i[t], this)) return !0;
            }));
            for(n = this.pushStack([]), t = 0; t < r; t++)S.find(e, i[t], n);
            return 1 < r ? S.uniqueSort(n) : n;
        },
        filter: function(e) {
            return this.pushStack(j(this, e || [], !1));
        },
        not: function(e) {
            return this.pushStack(j(this, e || [], !0));
        },
        is: function(e) {
            return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length;
        }
    });
    var D, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (S.fn.init = function(e, t, n) {
        var r, i;
        if (!e) return this;
        if (n = n || D, "string" == typeof e) {
            if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [
                null,
                e,
                null
            ] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
            if (r[1]) {
                if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for(r in t)m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                return this;
            }
            return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this;
        }
        return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this);
    }).prototype = S.fn, D = S(E);
    var L = /^(?:parents|prev(?:Until|All))/, H = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    function O(e, t) {
        while((e = e[t]) && 1 !== e.nodeType);
        return e;
    }
    S.fn.extend({
        has: function(e) {
            var t = S(e, this), n = t.length;
            return this.filter(function() {
                for(var e = 0; e < n; e++)if (S.contains(this, t[e])) return !0;
            });
        },
        closest: function(e, t) {
            var n, r = 0, i = this.length, o = [], a = "string" != typeof e && S(e);
            if (!k.test(e)) {
                for(; r < i; r++)for(n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) {
                    o.push(n);
                    break;
                }
            }
            return this.pushStack(1 < o.length ? S.uniqueSort(o) : o);
        },
        index: function(e) {
            return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(e, t) {
            return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t))));
        },
        addBack: function(e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
        }
    }), S.each({
        parent: function(e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null;
        },
        parents: function(e) {
            return h(e, "parentNode");
        },
        parentsUntil: function(e, t, n) {
            return h(e, "parentNode", n);
        },
        next: function(e) {
            return O(e, "nextSibling");
        },
        prev: function(e) {
            return O(e, "previousSibling");
        },
        nextAll: function(e) {
            return h(e, "nextSibling");
        },
        prevAll: function(e) {
            return h(e, "previousSibling");
        },
        nextUntil: function(e, t, n) {
            return h(e, "nextSibling", n);
        },
        prevUntil: function(e, t, n) {
            return h(e, "previousSibling", n);
        },
        siblings: function(e) {
            return T((e.parentNode || {}).firstChild, e);
        },
        children: function(e) {
            return T(e.firstChild);
        },
        contents: function(e) {
            return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes));
        }
    }, function(r, i) {
        S.fn[r] = function(e, t) {
            var n = S.map(this, i, e);
            return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n);
        };
    });
    var P = /[^\x20\t\r\n\f]+/g;
    function R(e) {
        return e;
    }
    function M(e) {
        throw e;
    }
    function I(e, t, n, r) {
        var i;
        try {
            e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [
                e
            ].slice(r));
        } catch (e1) {
            n.apply(void 0, [
                e1
            ]);
        }
    }
    S.Callbacks = function(r) {
        var e, n;
        r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function(e, t) {
            n[t] = !0;
        }), n) : S.extend({}, r);
        var i, t, o, a, s = [], u = [], l = -1, c = function() {
            for(a = a || r.once, o = i = !0; u.length; l = -1){
                t = u.shift();
                while(++l < s.length)!1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1);
            }
            r.memory || (t = !1), i = !1, a && (s = t ? [] : "");
        }, f = {
            add: function() {
                return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
                    S.each(e, function(e, t) {
                        m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t);
                    });
                }(arguments), t && !i && c()), this;
            },
            remove: function() {
                return S.each(arguments, function(e, t) {
                    var n;
                    while(-1 < (n = S.inArray(t, s, n)))s.splice(n, 1), n <= l && l--;
                }), this;
            },
            has: function(e) {
                return e ? -1 < S.inArray(e, s) : 0 < s.length;
            },
            empty: function() {
                return s && (s = []), this;
            },
            disable: function() {
                return a = u = [], s = t = "", this;
            },
            disabled: function() {
                return !s;
            },
            lock: function() {
                return a = u = [], t || i || (s = t = ""), this;
            },
            locked: function() {
                return !!a;
            },
            fireWith: function(e, t) {
                return a || (t = [
                    e,
                    (t = t || []).slice ? t.slice() : t
                ], u.push(t), i || c()), this;
            },
            fire: function() {
                return f.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!o;
            }
        };
        return f;
    }, S.extend({
        Deferred: function(e) {
            var o = [
                [
                    "notify",
                    "progress",
                    S.Callbacks("memory"),
                    S.Callbacks("memory"),
                    2
                ],
                [
                    "resolve",
                    "done",
                    S.Callbacks("once memory"),
                    S.Callbacks("once memory"),
                    0,
                    "resolved"
                ],
                [
                    "reject",
                    "fail",
                    S.Callbacks("once memory"),
                    S.Callbacks("once memory"),
                    1,
                    "rejected"
                ]
            ], i = "pending", a = {
                state: function() {
                    return i;
                },
                always: function() {
                    return s.done(arguments).fail(arguments), this;
                },
                "catch": function(e) {
                    return a.then(null, e);
                },
                pipe: function() {
                    var i = arguments;
                    return S.Deferred(function(r) {
                        S.each(o, function(e, t) {
                            var n = m(i[t[4]]) && i[t[4]];
                            s[t[1]](function() {
                                var e = n && n.apply(this, arguments);
                                e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [
                                    e
                                ] : arguments);
                            });
                        }), i = null;
                    }).promise();
                },
                then: function(t, n, r) {
                    var u = 0;
                    function l(i, o, a, s) {
                        return function() {
                            var n = this, r = arguments, e = function() {
                                var e, t;
                                if (!(i < u)) {
                                    if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
                                    t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [
                                        e
                                    ]), (s || o.resolveWith)(n, r));
                                }
                            }, t = s ? e : function() {
                                try {
                                    e();
                                } catch (e1) {
                                    S.Deferred.exceptionHook && S.Deferred.exceptionHook(e1, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [
                                        e1
                                    ]), o.rejectWith(n, r));
                                }
                            };
                            i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t));
                        };
                    }
                    return S.Deferred(function(e) {
                        o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M));
                    }).promise();
                },
                promise: function(e) {
                    return null != e ? S.extend(e, a) : a;
                }
            }, s = {};
            return S.each(o, function(e, t) {
                var n = t[2], r = t[5];
                a[t[1]] = n.add, r && n.add(function() {
                    i = r;
                }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function() {
                    return s[t[0] + "With"](this === s ? void 0 : this, arguments), this;
                }, s[t[0] + "With"] = n.fireWith;
            }), a.promise(s), e && e.call(s, s), s;
        },
        when: function(e) {
            var n = arguments.length, t = n, r = Array(t), i = s.call(arguments), o = S.Deferred(), a = function(t) {
                return function(e) {
                    r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i);
                };
            };
            if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then();
            while(t--)I(i[t], a(t), o.reject);
            return o.promise();
        }
    });
    var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    S.Deferred.exceptionHook = function(e, t) {
        C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);
    }, S.readyException = function(e) {
        C.setTimeout(function() {
            throw e;
        });
    };
    var F = S.Deferred();
    function B() {
        E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready();
    }
    S.fn.ready = function(e) {
        return F.then(e)["catch"](function(e) {
            S.readyException(e);
        }), this;
    }, S.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(e) {
            (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [
                S
            ]);
        }
    }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));
    var $ = function(e, t, n, r, i, o, a) {
        var s = 0, u = e.length, l = null == n;
        if ("object" === w(n)) for(s in i = !0, n)$(e, t, s, n[s], !0, o, a);
        else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) {
            return l.call(S(e), n);
        })), t)) for(; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
        return i ? e : l ? t.call(e) : u ? t(e[0], n) : o;
    }, _ = /^-ms-/, z = /-([a-z])/g;
    function U(e, t) {
        return t.toUpperCase();
    }
    function X(e) {
        return e.replace(_, "ms-").replace(z, U);
    }
    var V = function(e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
    };
    function G() {
        this.expando = S.expando + G.uid++;
    }
    G.uid = 1, G.prototype = {
        cache: function(e) {
            var t = e[this.expando];
            return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                value: t,
                configurable: !0
            }))), t;
        },
        set: function(e, t, n) {
            var r, i = this.cache(e);
            if ("string" == typeof t) i[X(t)] = n;
            else for(r in t)i[X(r)] = t[r];
            return i;
        },
        get: function(e, t) {
            return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)];
        },
        access: function(e, t, n) {
            return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t);
        },
        remove: function(e, t) {
            var n, r = e[this.expando];
            if (void 0 !== r) {
                if (void 0 !== t) {
                    n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [
                        t
                    ] : t.match(P) || []).length;
                    while(n--)delete r[t[n]];
                }
                (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
            }
        },
        hasData: function(e) {
            var t = e[this.expando];
            return void 0 !== t && !S.isEmptyObject(t);
        }
    };
    var Y = new G, Q = new G, J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g;
    function Z(e, t, n) {
        var r, i;
        if (void 0 === n && 1 === e.nodeType) {
            if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) {
                try {
                    n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i);
                } catch (e1) {}
                Q.set(e, t, n);
            } else n = void 0;
        }
        return n;
    }
    S.extend({
        hasData: function(e) {
            return Q.hasData(e) || Y.hasData(e);
        },
        data: function(e, t, n) {
            return Q.access(e, t, n);
        },
        removeData: function(e, t) {
            Q.remove(e, t);
        },
        _data: function(e, t, n) {
            return Y.access(e, t, n);
        },
        _removeData: function(e, t) {
            Y.remove(e, t);
        }
    }), S.fn.extend({
        data: function(n, e) {
            var t, r, i, o = this[0], a = o && o.attributes;
            if (void 0 === n) {
                if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
                    t = a.length;
                    while(t--)a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r]));
                    Y.set(o, "hasDataAttrs", !0);
                }
                return i;
            }
            return "object" == typeof n ? this.each(function() {
                Q.set(this, n);
            }) : $(this, function(e) {
                var t;
                if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0;
                this.each(function() {
                    Q.set(this, n, e);
                });
            }, null, e, 1 < arguments.length, null, !0);
        },
        removeData: function(e) {
            return this.each(function() {
                Q.remove(this, e);
            });
        }
    }), S.extend({
        queue: function(e, t, n) {
            var r;
            if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || [];
        },
        dequeue: function(e, t) {
            t = t || "fx";
            var n = S.queue(e, t), r = n.length, i = n.shift(), o = S._queueHooks(e, t);
            "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function() {
                S.dequeue(e, t);
            }, o)), !r && o && o.empty.fire();
        },
        _queueHooks: function(e, t) {
            var n = t + "queueHooks";
            return Y.get(e, n) || Y.access(e, n, {
                empty: S.Callbacks("once memory").add(function() {
                    Y.remove(e, [
                        t + "queue",
                        n
                    ]);
                })
            });
        }
    }), S.fn.extend({
        queue: function(t, n) {
            var e = 2;
            return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function() {
                var e = S.queue(this, t, n);
                S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t);
            });
        },
        dequeue: function(e) {
            return this.each(function() {
                S.dequeue(this, e);
            });
        },
        clearQueue: function(e) {
            return this.queue(e || "fx", []);
        },
        promise: function(e, t) {
            var n, r = 1, i = S.Deferred(), o = this, a = this.length, s = function() {
                --r || i.resolveWith(o, [
                    o
                ]);
            };
            "string" != typeof e && (t = e, e = void 0), e = e || "fx";
            while(a--)(n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
            return s(), i.promise(t);
        }
    });
    var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"), ne = [
        "Top",
        "Right",
        "Bottom",
        "Left"
    ], re = E.documentElement, ie = function(e) {
        return S.contains(e.ownerDocument, e);
    }, oe = {
        composed: !0
    };
    re.getRootNode && (ie = function(e) {
        return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument;
    });
    var ae = function(e, t) {
        return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display");
    };
    function se(e, t, n, r) {
        var i, o, a = 20, s = r ? function() {
            return r.cur();
        } : function() {
            return S.css(e, t, "");
        }, u = s(), l = n && n[3] || (S.cssNumber[t] ? "" : "px"), c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t));
        if (c && c[3] !== l) {
            u /= 2, l = l || c[3], c = +u || 1;
            while(a--)S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
            c *= 2, S.style(e, t, c + l), n = n || [];
        }
        return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i;
    }
    var ue = {};
    function le(e, t) {
        for(var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n)));
        for(c = 0; c < f; c++)null != l[c] && (e[c].style.display = l[c]);
        return e;
    }
    S.fn.extend({
        show: function() {
            return le(this, !0);
        },
        hide: function() {
            return le(this);
        },
        toggle: function(e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                ae(this) ? S(this).show() : S(this).hide();
            });
        }
    });
    var ce, fe, pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?:java|ecma)script/i;
    ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild;
    var ge = {
        thead: [
            1,
            "<table>",
            "</table>"
        ],
        col: [
            2,
            "<table><colgroup>",
            "</colgroup></table>"
        ],
        tr: [
            2,
            "<table><tbody>",
            "</tbody></table>"
        ],
        td: [
            3,
            "<table><tbody><tr>",
            "</tr></tbody></table>"
        ],
        _default: [
            0,
            "",
            ""
        ]
    };
    function ve(e, t) {
        var n;
        return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([
            e
        ], n) : n;
    }
    function ye(e, t) {
        for(var n = 0, r = e.length; n < r; n++)Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"));
    }
    ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [
        1,
        "<select multiple='multiple'>",
        "</select>"
    ]);
    var me = /<|&#?\w+;/;
    function xe(e, t, n, r, i) {
        for(var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) {
            if ("object" === w(o)) S.merge(p, o.nodeType ? [
                o
            ] : o);
            else if (me.test(o)) {
                a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || [
                    "",
                    ""
                ])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0];
                while(c--)a = a.lastChild;
                S.merge(p, a.childNodes), (a = f.firstChild).textContent = "";
            } else p.push(t.createTextNode(o));
        }
        f.textContent = "", d = 0;
        while(o = p[d++])if (r && -1 < S.inArray(o, r)) i && i.push(o);
        else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) {
            c = 0;
            while(o = a[c++])he.test(o.type || "") && n.push(o);
        }
        return f;
    }
    var be = /^([^.]*)(?:\.(.+)|)/;
    function we() {
        return !0;
    }
    function Te() {
        return !1;
    }
    function Ce(e, t) {
        return e === function() {
            try {
                return E.activeElement;
            } catch (e) {}
        }() == ("focus" === t);
    }
    function Ee(e, t, n, r, i, o) {
        var a, s;
        if ("object" == typeof t) {
            for(s in "string" != typeof n && (r = r || n, n = void 0), t)Ee(e, s, n, r, t[s], o);
            return e;
        }
        if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te;
        else if (!i) return e;
        return 1 === o && (a = i, (i = function(e) {
            return S().off(e), a.apply(this, arguments);
        }).guid = a.guid || (a.guid = S.guid++)), e.each(function() {
            S.event.add(this, t, i, r, n);
        });
    }
    function Se(e, i, o) {
        o ? (Y.set(e, i, !1), S.event.add(e, i, {
            namespace: !1,
            handler: function(e) {
                var t, n, r = Y.get(this, i);
                if (1 & e.isTrigger && this[i]) {
                    if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation();
                    else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value;
                } else r.length && (Y.set(this, i, {
                    value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this)
                }), e.stopImmediatePropagation());
            }
        })) : void 0 === Y.get(e, i) && S.event.add(e, i, we);
    }
    S.event = {
        global: {},
        add: function(t, e, n, r, i) {
            var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t);
            if (V(t)) {
                n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function(e) {
                    return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0;
                }), l = (e = (e || "").match(P) || [
                    ""
                ]).length;
                while(l--)d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({
                    type: d,
                    origType: g,
                    data: r,
                    handler: n,
                    guid: n.guid,
                    selector: i,
                    needsContext: i && S.expr.match.needsContext.test(i),
                    namespace: h.join(".")
                }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0);
            }
        },
        remove: function(e, t, n, r, i) {
            var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e);
            if (v && (u = v.events)) {
                l = (t = (t || "").match(P) || [
                    ""
                ]).length;
                while(l--)if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
                    f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;
                    while(o--)c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
                    a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]);
                } else for(d in u)S.event.remove(e, d + t[l], n, r, !0);
                S.isEmptyObject(u) && Y.remove(e, "handle events");
            }
        },
        dispatch: function(e) {
            var t, n, r, i, o, a, s = new Array(arguments.length), u = S.event.fix(e), l = (Y.get(this, "events") || Object.create(null))[u.type] || [], c = S.event.special[u.type] || {};
            for(s[0] = u, t = 1; t < arguments.length; t++)s[t] = arguments[t];
            if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
                a = S.event.handlers.call(this, u, l), t = 0;
                while((i = a[t++]) && !u.isPropagationStopped()){
                    u.currentTarget = i.elem, n = 0;
                    while((o = i.handlers[n++]) && !u.isImmediatePropagationStopped())u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()));
                }
                return c.postDispatch && c.postDispatch.call(this, u), u.result;
            }
        },
        handlers: function(e, t) {
            var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target;
            if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) {
                for(; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
                    for(o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [
                        l
                    ]).length), a[i] && o.push(r);
                    o.length && s.push({
                        elem: l,
                        handlers: o
                    });
                }
            }
            return l = this, u < t.length && s.push({
                elem: l,
                handlers: t.slice(u)
            }), s;
        },
        addProp: function(t, e) {
            Object.defineProperty(S.Event.prototype, t, {
                enumerable: !0,
                configurable: !0,
                get: m(e) ? function() {
                    if (this.originalEvent) return e(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[t];
                },
                set: function(e) {
                    Object.defineProperty(this, t, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: e
                    });
                }
            });
        },
        fix: function(e) {
            return e[S.expando] ? e : new S.Event(e);
        },
        special: {
            load: {
                noBubble: !0
            },
            click: {
                setup: function(e) {
                    var t = this || e;
                    return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1;
                },
                trigger: function(e) {
                    var t = this || e;
                    return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0;
                },
                _default: function(e) {
                    var t = e.target;
                    return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a");
                }
            },
            beforeunload: {
                postDispatch: function(e) {
                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
                }
            }
        }
    }, S.removeEvent = function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n);
    }, S.Event = function(e, t) {
        if (!(this instanceof S.Event)) return new S.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0;
    }, S.Event.prototype = {
        constructor: S.Event,
        isDefaultPrevented: Te,
        isPropagationStopped: Te,
        isImmediatePropagationStopped: Te,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation();
        }
    }, S.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        "char": !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: !0
    }, S.event.addProp), S.each({
        focus: "focusin",
        blur: "focusout"
    }, function(e, t) {
        S.event.special[e] = {
            setup: function() {
                return Se(this, e, Ce), !1;
            },
            trigger: function() {
                return Se(this, e), !0;
            },
            _default: function() {
                return !0;
            },
            delegateType: t
        };
    }), S.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(e, i) {
        S.event.special[e] = {
            delegateType: i,
            bindType: i,
            handle: function(e) {
                var t, n = e.relatedTarget, r = e.handleObj;
                return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t;
            }
        };
    }), S.fn.extend({
        on: function(e, t, n, r) {
            return Ee(this, e, t, n, r);
        },
        one: function(e, t, n, r) {
            return Ee(this, e, t, n, r, 1);
        },
        off: function(e, t, n) {
            var r, i;
            if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
            if ("object" == typeof e) {
                for(i in e)this.off(i, t, e[i]);
                return this;
            }
            return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function() {
                S.event.remove(this, e, n, t);
            });
        }
    });
    var ke = /<script|<style|<link/i, Ae = /checked\s*(?:[^=]|=\s*.checked.)/i, Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function je(e, t) {
        return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e;
    }
    function De(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
    }
    function qe(e) {
        return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e;
    }
    function Le(e, t) {
        var n, r, i, o, a, s;
        if (1 === t.nodeType) {
            if (Y.hasData(e) && (s = Y.get(e).events)) for(i in Y.remove(t, "handle events"), s)for(n = 0, r = s[i].length; n < r; n++)S.event.add(t, i, s[i][n]);
            Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a));
        }
    }
    function He(n, r, i, o) {
        r = g(r);
        var e, t, a, s, u, l, c = 0, f = n.length, p = f - 1, d = r[0], h = m(d);
        if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function(e) {
            var t = n.eq(e);
            h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o);
        });
        if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
            for(s = (a = S.map(ve(e, "script"), De)).length; c < f; c++)u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c);
            if (s) for(l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++)u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, {
                nonce: u.nonce || u.getAttribute("nonce")
            }, l) : b(u.textContent.replace(Ne, ""), u, l));
        }
        return n;
    }
    function Oe(e, t, n) {
        for(var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));
        return e;
    }
    S.extend({
        htmlPrefilter: function(e) {
            return e;
        },
        clone: function(e, t, n) {
            var r, i, o, a, s, u, l, c = e.cloneNode(!0), f = ie(e);
            if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for(a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)s = o[r], u = a[r], "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
            if (t) {
                if (n) for(o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)Le(o[r], a[r]);
                else Le(e, c);
            }
            return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c;
        },
        cleanData: function(e) {
            for(var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)if (V(n)) {
                if (t = n[Y.expando]) {
                    if (t.events) for(r in t.events)i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle);
                    n[Y.expando] = void 0;
                }
                n[Q.expando] && (n[Q.expando] = void 0);
            }
        }
    }), S.fn.extend({
        detach: function(e) {
            return Oe(this, e, !0);
        },
        remove: function(e) {
            return Oe(this, e);
        },
        text: function(e) {
            return $(this, function(e) {
                return void 0 === e ? S.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
                });
            }, null, e, arguments.length);
        },
        append: function() {
            return He(this, arguments, function(e) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e);
            });
        },
        prepend: function() {
            return He(this, arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = je(this, e);
                    t.insertBefore(e, t.firstChild);
                }
            });
        },
        before: function() {
            return He(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this);
            });
        },
        after: function() {
            return He(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
            });
        },
        empty: function() {
            for(var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = "");
            return this;
        },
        clone: function(e, t) {
            return e = null != e && e, t = null == t ? e : t, this.map(function() {
                return S.clone(this, e, t);
            });
        },
        html: function(e) {
            return $(this, function(e) {
                var t = this[0] || {}, n = 0, r = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || [
                    "",
                    ""
                ])[1].toLowerCase()]) {
                    e = S.htmlPrefilter(e);
                    try {
                        for(; n < r; n++)1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e);
                        t = 0;
                    } catch (e1) {}
                }
                t && this.empty().append(e);
            }, null, e, arguments.length);
        },
        replaceWith: function() {
            var n = [];
            return He(this, arguments, function(e) {
                var t = this.parentNode;
                S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this));
            }, n);
        }
    }), S.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(e, a) {
        S.fn[e] = function(e) {
            for(var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++)t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get());
            return this.pushStack(n);
        };
    });
    var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"), Re = function(e) {
        var t = e.ownerDocument.defaultView;
        return t && t.opener || (t = C), t.getComputedStyle(e);
    }, Me = function(e, t, n) {
        var r, i, o = {};
        for(i in t)o[i] = e.style[i], e.style[i] = t[i];
        for(i in r = n.call(e), t)e.style[i] = o[i];
        return r;
    }, Ie = new RegExp(ne.join("|"), "i");
    function We(e, t, n) {
        var r, i, o, a, s = e.style;
        return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a;
    }
    function Fe(e, t) {
        return {
            get: function() {
                if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get;
            }
        };
    }
    !function() {
        function e() {
            if (l) {
                u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l);
                var e = C.getComputedStyle(l);
                n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null;
            }
        }
        function t(e) {
            return Math.round(parseFloat(e));
        }
        var n, r, i, o, a, s, u = E.createElement("div"), l = E.createElement("div");
        l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, {
            boxSizingReliable: function() {
                return e(), r;
            },
            pixelBoxStyles: function() {
                return e(), o;
            },
            pixelPosition: function() {
                return e(), n;
            },
            reliableMarginLeft: function() {
                return e(), s;
            },
            scrollboxSize: function() {
                return e(), i;
            },
            reliableTrDimensions: function() {
                var e, t, n, r;
                return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a;
            }
        }));
    }();
    var Be = [
        "Webkit",
        "Moz",
        "ms"
    ], $e = E.createElement("div").style, _e = {};
    function ze(e) {
        var t = S.cssProps[e] || _e[e];
        return t || (e in $e ? e : _e[e] = function(e) {
            var t = e[0].toUpperCase() + e.slice(1), n = Be.length;
            while(n--)if ((e = Be[n] + t) in $e) return e;
        }(e) || e);
    }
    var Ue = /^(none|table(?!-c[ea]).+)/, Xe = /^--/, Ve = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Ge = {
        letterSpacing: "0",
        fontWeight: "400"
    };
    function Ye(e, t, n) {
        var r = te.exec(t);
        return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
    }
    function Qe(e, t, n, r, i, o) {
        var a = "width" === t ? 1 : 0, s = 0, u = 0;
        if (n === (r ? "border" : "content")) return 0;
        for(; a < 4; a += 2)"margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i));
        return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u;
    }
    function Je(e, t, n) {
        var r = Re(e), i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r), o = i, a = We(e, t, r), s = "offset" + t[0].toUpperCase() + t.slice(1);
        if (Pe.test(a)) {
            if (!n) return a;
            a = "auto";
        }
        return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px";
    }
    function Ke(e, t, n, r, i) {
        return new Ke.prototype.init(e, t, n, r, i);
    }
    S.extend({
        cssHooks: {
            opacity: {
                get: function(e, t) {
                    if (t) {
                        var n = We(e, "opacity");
                        return "" === n ? "1" : n;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            gridArea: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnStart: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowStart: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {},
        style: function(e, t, n, r) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var i, o, a, s = X(t), u = Xe.test(t), l = e.style;
                if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
                "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n));
            }
        },
        css: function(e, t, n, r) {
            var i, o, a, s = X(t);
            return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i;
        }
    }), S.each([
        "height",
        "width"
    ], function(e, u) {
        S.cssHooks[u] = {
            get: function(e, t, n) {
                if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function() {
                    return Je(e, u, n);
                });
            },
            set: function(e, t, n) {
                var r, i = Re(e), o = !y.scrollboxSize() && "absolute" === i.position, a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i), s = n ? Qe(e, u, n, a, i) : 0;
                return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s);
            }
        };
    }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function(e, t) {
        if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, {
            marginLeft: 0
        }, function() {
            return e.getBoundingClientRect().left;
        })) + "px";
    }), S.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(i, o) {
        S.cssHooks[i + o] = {
            expand: function(e) {
                for(var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [
                    e
                ]; t < 4; t++)n[i + ne[t] + o] = r[t] || r[t - 2] || r[0];
                return n;
            }
        }, "margin" !== i && (S.cssHooks[i + o].set = Ye);
    }), S.fn.extend({
        css: function(e, t) {
            return $(this, function(e, t, n) {
                var r, i, o = {}, a = 0;
                if (Array.isArray(t)) {
                    for(r = Re(e), i = t.length; a < i; a++)o[t[a]] = S.css(e, t[a], !1, r);
                    return o;
                }
                return void 0 !== n ? S.style(e, t, n) : S.css(e, t);
            }, e, t, 1 < arguments.length);
        }
    }), ((S.Tween = Ke).prototype = {
        constructor: Ke,
        init: function(e, t, n, r, i, o) {
            this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px");
        },
        cur: function() {
            var e = Ke.propHooks[this.prop];
            return e && e.get ? e.get(this) : Ke.propHooks._default.get(this);
        },
        run: function(e) {
            var t, n = Ke.propHooks[this.prop];
            return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this;
        }
    }).init.prototype = Ke.prototype, (Ke.propHooks = {
        _default: {
            get: function(e) {
                var t;
                return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
            },
            set: function(e) {
                S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit);
            }
        }
    }).scrollTop = Ke.propHooks.scrollLeft = {
        set: function(e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
        }
    }, S.easing = {
        linear: function(e) {
            return e;
        },
        swing: function(e) {
            return .5 - Math.cos(e * Math.PI) / 2;
        },
        _default: "swing"
    }, S.fx = Ke.prototype.init, S.fx.step = {};
    var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/, it = /queueHooks$/;
    function ot() {
        et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick());
    }
    function at() {
        return C.setTimeout(function() {
            Ze = void 0;
        }), Ze = Date.now();
    }
    function st(e, t) {
        var n, r = 0, i = {
            height: e
        };
        for(t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = ne[r])] = i["padding" + n] = e;
        return t && (i.opacity = i.width = e), i;
    }
    function ut(e, t, n) {
        for(var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r;
    }
    function lt(o, e, t) {
        var n, a, r = 0, i = lt.prefilters.length, s = S.Deferred().always(function() {
            delete u.elem;
        }), u = function() {
            if (a) return !1;
            for(var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)l.tweens[r].run(n);
            return s.notifyWith(o, [
                l,
                n,
                t
            ]), n < 1 && i ? t : (i || s.notifyWith(o, [
                l,
                1,
                0
            ]), s.resolveWith(o, [
                l
            ]), !1);
        }, l = s.promise({
            elem: o,
            props: S.extend({}, e),
            opts: S.extend(!0, {
                specialEasing: {},
                easing: S.easing._default
            }, t),
            originalProperties: e,
            originalOptions: t,
            startTime: Ze || at(),
            duration: t.duration,
            tweens: [],
            createTween: function(e, t) {
                var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
                return l.tweens.push(n), n;
            },
            stop: function(e) {
                var t = 0, n = e ? l.tweens.length : 0;
                if (a) return this;
                for(a = !0; t < n; t++)l.tweens[t].run(1);
                return e ? (s.notifyWith(o, [
                    l,
                    1,
                    0
                ]), s.resolveWith(o, [
                    l,
                    e
                ])) : s.rejectWith(o, [
                    l,
                    e
                ]), this;
            }
        }), c = l.props;
        for(!function(e, t) {
            var n, r, i, o, a;
            for(n in e)if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && ("expand" in a)) for(n in o = a.expand(o), delete e[r], o)(n in e) || (e[n] = o[n], t[n] = i);
            else t[r] = i;
        }(c, l.opts.specialEasing); r < i; r++)if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
        return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, {
            elem: o,
            anim: l,
            queue: l.opts.queue
        })), l;
    }
    S.Animation = S.extend(lt, {
        tweeners: {
            "*": [
                function(e, t) {
                    var n = this.createTween(e, t);
                    return se(n.elem, e, te.exec(t), n), n;
                }
            ]
        },
        tweener: function(e, t) {
            m(e) ? (t = e, e = [
                "*"
            ]) : e = e.match(P);
            for(var n, r = 0, i = e.length; r < i; r++)n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t);
        },
        prefilters: [
            function(e, t, n) {
                var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), v = Y.get(e, "fxshow");
                for(r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() {
                    a.unqueued || s();
                }), a.unqueued++, p.always(function() {
                    p.always(function() {
                        a.unqueued--, S.queue(e, "fx").length || a.empty.fire();
                    });
                })), t)if (i = t[r], rt.test(i)) {
                    if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
                        if ("show" !== i || !v || void 0 === v[r]) continue;
                        g = !0;
                    }
                    d[r] = v && v[r] || S.style(e, r);
                }
                if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for(r in f && 1 === e.nodeType && (n.overflow = [
                    h.overflow,
                    h.overflowX,
                    h.overflowY
                ], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([
                    e
                ], !0), l = e.style.display || l, c = S.css(e, "display"), le([
                    e
                ]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function() {
                    h.display = l;
                }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function() {
                    h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2];
                })), u = !1, d)u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", {
                    display: l
                }), o && (v.hidden = !g), g && le([
                    e
                ], !0), p.done(function() {
                    for(r in g || le([
                        e
                    ]), Y.remove(e, "fxshow"), d)S.style(e, r, d[r]);
                })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0));
            }
        ],
        prefilter: function(e, t) {
            t ? lt.prefilters.unshift(e) : lt.prefilters.push(e);
        }
    }), S.speed = function(e, t, n) {
        var r = e && "object" == typeof e ? S.extend({}, e) : {
            complete: n || !n && t || m(e) && e,
            duration: e,
            easing: n && t || t && !m(t) && t
        };
        return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
            m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue);
        }, r;
    }, S.fn.extend({
        fadeTo: function(e, t, n, r) {
            return this.filter(ae).css("opacity", 0).show().end().animate({
                opacity: t
            }, e, n, r);
        },
        animate: function(t, e, n, r) {
            var i = S.isEmptyObject(t), o = S.speed(e, n, r), a = function() {
                var e = lt(this, S.extend({}, t), o);
                (i || Y.get(this, "finish")) && e.stop(!0);
            };
            return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
        },
        stop: function(i, e, o) {
            var a = function(e) {
                var t = e.stop;
                delete e.stop, t(o);
            };
            return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function() {
                var e = !0, t = null != i && i + "queueHooks", n = S.timers, r = Y.get(this);
                if (t) r[t] && r[t].stop && a(r[t]);
                else for(t in r)r[t] && r[t].stop && it.test(t) && a(r[t]);
                for(t = n.length; t--;)n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
                !e && o || S.dequeue(this, i);
            });
        },
        finish: function(a) {
            return !1 !== a && (a = a || "fx"), this.each(function() {
                var e, t = Y.get(this), n = t[a + "queue"], r = t[a + "queueHooks"], i = S.timers, o = n ? n.length : 0;
                for(t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;)i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
                for(e = 0; e < o; e++)n[e] && n[e].finish && n[e].finish.call(this);
                delete t.finish;
            });
        }
    }), S.each([
        "toggle",
        "show",
        "hide"
    ], function(e, r) {
        var i = S.fn[r];
        S.fn[r] = function(e, t, n) {
            return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n);
        };
    }), S.each({
        slideDown: st("show"),
        slideUp: st("hide"),
        slideToggle: st("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(e, r) {
        S.fn[e] = function(e, t, n) {
            return this.animate(r, e, t, n);
        };
    }), S.timers = [], S.fx.tick = function() {
        var e, t = 0, n = S.timers;
        for(Ze = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
        n.length || S.fx.stop(), Ze = void 0;
    }, S.fx.timer = function(e) {
        S.timers.push(e), S.fx.start();
    }, S.fx.interval = 13, S.fx.start = function() {
        et || (et = !0, ot());
    }, S.fx.stop = function() {
        et = null;
    }, S.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, S.fn.delay = function(r, e) {
        return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function(e, t) {
            var n = C.setTimeout(e, r);
            t.stop = function() {
                C.clearTimeout(n);
            };
        });
    }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value;
    var ct, ft = S.expr.attrHandle;
    S.fn.extend({
        attr: function(e, t) {
            return $(this, S.attr, e, t, 1 < arguments.length);
        },
        removeAttr: function(e) {
            return this.each(function() {
                S.removeAttr(this, e);
            });
        }
    }), S.extend({
        attr: function(e, t, n) {
            var r, i, o = e.nodeType;
            if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r);
        },
        attrHooks: {
            type: {
                set: function(e, t) {
                    if (!y.radioValue && "radio" === t && A(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t), n && (e.value = n), t;
                    }
                }
            }
        },
        removeAttr: function(e, t) {
            var n, r = 0, i = t && t.match(P);
            if (i && 1 === e.nodeType) while(n = i[r++])e.removeAttribute(n);
        }
    }), ct = {
        set: function(e, t, n) {
            return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n;
        }
    }, S.each(S.expr.match.bool.source.match(/\w+/g), function(e, t) {
        var a = ft[t] || S.find.attr;
        ft[t] = function(e, t, n) {
            var r, i, o = t.toLowerCase();
            return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r;
        };
    });
    var pt = /^(?:input|select|textarea|button)$/i, dt = /^(?:a|area)$/i;
    function ht(e) {
        return (e.match(P) || []).join(" ");
    }
    function gt(e) {
        return e.getAttribute && e.getAttribute("class") || "";
    }
    function vt(e) {
        return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [];
    }
    S.fn.extend({
        prop: function(e, t) {
            return $(this, S.prop, e, t, 1 < arguments.length);
        },
        removeProp: function(e) {
            return this.each(function() {
                delete this[S.propFix[e] || e];
            });
        }
    }), S.extend({
        prop: function(e, t, n) {
            var r, i, o = e.nodeType;
            if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t];
        },
        propHooks: {
            tabIndex: {
                get: function(e) {
                    var t = S.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1;
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    }), y.optSelected || (S.propHooks.selected = {
        get: function(e) {
            var t = e.parentNode;
            return t && t.parentNode && t.parentNode.selectedIndex, null;
        },
        set: function(e) {
            var t = e.parentNode;
            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
        }
    }), S.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        S.propFix[this.toLowerCase()] = this;
    }), S.fn.extend({
        addClass: function(t) {
            var e, n, r, i, o, a, s, u = 0;
            if (m(t)) return this.each(function(e) {
                S(this).addClass(t.call(this, e, gt(this)));
            });
            if ((e = vt(t)).length) {
                while(n = this[u++])if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
                    a = 0;
                    while(o = e[a++])r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                    i !== (s = ht(r)) && n.setAttribute("class", s);
                }
            }
            return this;
        },
        removeClass: function(t) {
            var e, n, r, i, o, a, s, u = 0;
            if (m(t)) return this.each(function(e) {
                S(this).removeClass(t.call(this, e, gt(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            if ((e = vt(t)).length) {
                while(n = this[u++])if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
                    a = 0;
                    while(o = e[a++])while(-1 < r.indexOf(" " + o + " "))r = r.replace(" " + o + " ", " ");
                    i !== (s = ht(r)) && n.setAttribute("class", s);
                }
            }
            return this;
        },
        toggleClass: function(i, t) {
            var o = typeof i, a = "string" === o || Array.isArray(i);
            return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function(e) {
                S(this).toggleClass(i.call(this, e, gt(this), t), t);
            }) : this.each(function() {
                var e, t, n, r;
                if (a) {
                    t = 0, n = S(this), r = vt(i);
                    while(e = r[t++])n.hasClass(e) ? n.removeClass(e) : n.addClass(e);
                } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || ""));
            });
        },
        hasClass: function(e) {
            var t, n, r = 0;
            t = " " + e + " ";
            while(n = this[r++])if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0;
            return !1;
        }
    });
    var yt = /\r/g;
    S.fn.extend({
        val: function(n) {
            var r, e, i, t = this[0];
            return arguments.length ? (i = m(n), this.each(function(e) {
                var t;
                1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function(e) {
                    return null == e ? "" : e + "";
                })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t));
            })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0;
        }
    }), S.extend({
        valHooks: {
            option: {
                get: function(e) {
                    var t = S.find.attr(e, "value");
                    return null != t ? t : ht(S.text(e));
                }
            },
            select: {
                get: function(e) {
                    var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length;
                    for(r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
                        if (t = S(n).val(), a) return t;
                        s.push(t);
                    }
                    return s;
                },
                set: function(e, t) {
                    var n, r, i = e.options, o = S.makeArray(t), a = i.length;
                    while(a--)((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0);
                    return n || (e.selectedIndex = -1), o;
                }
            }
        }
    }), S.each([
        "radio",
        "checkbox"
    ], function() {
        S.valHooks[this] = {
            set: function(e, t) {
                if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t);
            }
        }, y.checkOn || (S.valHooks[this].get = function(e) {
            return null === e.getAttribute("value") ? "on" : e.value;
        });
    }), y.focusin = "onfocusin" in C;
    var mt = /^(?:focusinfocus|focusoutblur)$/, xt = function(e) {
        e.stopPropagation();
    };
    S.extend(S.event, {
        trigger: function(e, t, n, r) {
            var i, o, a, s, u, l, c, f, p = [
                n || E
            ], d = v.call(e, "type") ? e.type : e, h = v.call(e, "namespace") ? e.namespace.split(".") : [];
            if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [
                e
            ] : S.makeArray(t, [
                e
            ]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
                if (!r && !c.noBubble && !x(n)) {
                    for(s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), a = o;
                    a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C);
                }
                i = 0;
                while((o = p[i++]) && !e.isPropagationStopped())f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
                return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result;
            }
        },
        simulate: function(e, t, n) {
            var r = S.extend(new S.Event, n, {
                type: e,
                isSimulated: !0
            });
            S.event.trigger(r, null, t);
        }
    }), S.fn.extend({
        trigger: function(e, t) {
            return this.each(function() {
                S.event.trigger(e, t, this);
            });
        },
        triggerHandler: function(e, t) {
            var n = this[0];
            if (n) return S.event.trigger(e, t, n, !0);
        }
    }), y.focusin || S.each({
        focus: "focusin",
        blur: "focusout"
    }, function(n, r) {
        var i = function(e) {
            S.event.simulate(r, e.target, S.event.fix(e));
        };
        S.event.special[r] = {
            setup: function() {
                var e = this.ownerDocument || this.document || this, t = Y.access(e, r);
                t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1);
            },
            teardown: function() {
                var e = this.ownerDocument || this.document || this, t = Y.access(e, r) - 1;
                t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r));
            }
        };
    });
    var bt = C.location, wt = {
        guid: Date.now()
    }, Tt = /\?/;
    S.parseXML = function(e) {
        var t, n;
        if (!e || "string" != typeof e) return null;
        try {
            t = (new C.DOMParser).parseFromString(e, "text/xml");
        } catch (e1) {}
        return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function(e) {
            return e.textContent;
        }).join("\n") : e)), t;
    };
    var Ct = /\[\]$/, Et = /\r?\n/g, St = /^(?:submit|button|image|reset|file)$/i, kt = /^(?:input|select|textarea|keygen)/i;
    function At(n, e, r, i) {
        var t;
        if (Array.isArray(e)) S.each(e, function(e, t) {
            r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i);
        });
        else if (r || "object" !== w(e)) i(n, e);
        else for(t in e)At(n + "[" + t + "]", e[t], r, i);
    }
    S.param = function(e, t) {
        var n, r = [], i = function(e, t) {
            var n = m(t) ? t() : t;
            r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
        };
        if (null == e) return "";
        if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function() {
            i(this.name, this.value);
        });
        else for(n in e)At(n, e[n], t, i);
        return r.join("&");
    }, S.fn.extend({
        serialize: function() {
            return S.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var e = S.prop(this, "elements");
                return e ? S.makeArray(e) : this;
            }).filter(function() {
                var e = this.type;
                return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e));
            }).map(function(e, t) {
                var n = S(this).val();
                return null == n ? null : Array.isArray(n) ? S.map(n, function(e) {
                    return {
                        name: t.name,
                        value: e.replace(Et, "\r\n")
                    };
                }) : {
                    name: t.name,
                    value: n.replace(Et, "\r\n")
                };
            }).get();
        }
    });
    var Nt = /%20/g, jt = /#.*$/, Dt = /([?&])_=[^&]*/, qt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Lt = /^(?:GET|HEAD)$/, Ht = /^\/\//, Ot = {}, Pt = {}, Rt = "*/".concat("*"), Mt = E.createElement("a");
    function It(o) {
        return function(e, t) {
            "string" != typeof e && (t = e, e = "*");
            var n, r = 0, i = e.toLowerCase().match(P) || [];
            if (m(t)) while(n = i[r++])"+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t);
        };
    }
    function Wt(t, i, o, a) {
        var s = {}, u = t === Pt;
        function l(e) {
            var r;
            return s[e] = !0, S.each(t[e] || [], function(e, t) {
                var n = t(i, o, a);
                return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1);
            }), r;
        }
        return l(i.dataTypes[0]) || !s["*"] && l("*");
    }
    function Ft(e, t) {
        var n, r, i = S.ajaxSettings.flatOptions || {};
        for(n in t)void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
        return r && S.extend(!0, e, r), e;
    }
    Mt.href = bt.href, S.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: bt.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Rt,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": S.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(e, t) {
            return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e);
        },
        ajaxPrefilter: It(Ot),
        ajaxTransport: It(Pt),
        ajax: function(e, t) {
            "object" == typeof e && (t = e, e = void 0), t = t || {};
            var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event, x = S.Deferred(), b = S.Callbacks("once memory"), w = v.statusCode || {}, a = {}, s = {}, u = "canceled", T = {
                readyState: 0,
                getResponseHeader: function(e) {
                    var t;
                    if (h) {
                        if (!n) {
                            n = {};
                            while(t = qt.exec(p))n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]);
                        }
                        t = n[e.toLowerCase() + " "];
                    }
                    return null == t ? null : t.join(", ");
                },
                getAllResponseHeaders: function() {
                    return h ? p : null;
                },
                setRequestHeader: function(e, t) {
                    return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this;
                },
                overrideMimeType: function(e) {
                    return null == h && (v.mimeType = e), this;
                },
                statusCode: function(e) {
                    var t;
                    if (e) {
                        if (h) T.always(e[T.status]);
                        else for(t in e)w[t] = [
                            w[t],
                            e[t]
                        ];
                    }
                    return this;
                },
                abort: function(e) {
                    var t = e || u;
                    return c && c.abort(t), l(0, t), this;
                }
            };
            if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [
                ""
            ], null == v.crossDomain) {
                r = E.createElement("a");
                try {
                    r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host;
                } catch (e1) {
                    v.crossDomain = !0;
                }
            }
            if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T;
            for(i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers)T.setRequestHeader(i, v.headers[i]);
            if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();
            if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) {
                if (T.readyState = 1, g && m.trigger("ajaxSend", [
                    T,
                    v
                ]), h) return T;
                v.async && 0 < v.timeout && (d = C.setTimeout(function() {
                    T.abort("timeout");
                }, v.timeout));
                try {
                    h = !1, c.send(a, l);
                } catch (e2) {
                    if (h) throw e2;
                    l(-1, e2);
                }
            } else l(-1, "No Transport");
            function l(e, t, n, r) {
                var i, o, a, s, u, l = t;
                h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function(e, t, n) {
                    var r, i, o, a, s = e.contents, u = e.dataTypes;
                    while("*" === u[0])u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                    if (r) {
                        for(i in s)if (s[i] && s[i].test(r)) {
                            u.unshift(i);
                            break;
                        }
                    }
                    if (u[0] in n) o = u[0];
                    else {
                        for(i in n){
                            if (!u[0] || e.converters[i + " " + u[0]]) {
                                o = i;
                                break;
                            }
                            a || (a = i);
                        }
                        o = o || a;
                    }
                    if (o) return o !== u[0] && u.unshift(o), n[o];
                }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function() {}), s = function(e, t, n, r) {
                    var i, o, a, s, u, l = {}, c = e.dataTypes.slice();
                    if (c[1]) for(a in e.converters)l[a.toLowerCase()] = e.converters[a];
                    o = c.shift();
                    while(o)if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) {
                        if ("*" === o) o = u;
                        else if ("*" !== u && u !== o) {
                            if (!(a = l[u + " " + o] || l["* " + o])) {
                                for(i in l)if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
                                    !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
                                    break;
                                }
                            }
                            if (!0 !== a) {
                                if (a && e["throws"]) t = a(t);
                                else try {
                                    t = a(t);
                                } catch (e1) {
                                    return {
                                        state: "parsererror",
                                        error: a ? e1 : "No conversion from " + u + " to " + o
                                    };
                                }
                            }
                        }
                    }
                    return {
                        state: "success",
                        data: t
                    };
                }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [
                    o,
                    l,
                    T
                ]) : x.rejectWith(y, [
                    T,
                    l,
                    a
                ]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [
                    T,
                    v,
                    i ? o : a
                ]), b.fireWith(y, [
                    T,
                    l
                ]), g && (m.trigger("ajaxComplete", [
                    T,
                    v
                ]), --S.active || S.event.trigger("ajaxStop")));
            }
            return T;
        },
        getJSON: function(e, t, n) {
            return S.get(e, t, n, "json");
        },
        getScript: function(e, t) {
            return S.get(e, void 0, t, "script");
        }
    }), S.each([
        "get",
        "post"
    ], function(e, i) {
        S[i] = function(e, t, n, r) {
            return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({
                url: e,
                type: i,
                dataType: r,
                data: t,
                success: n
            }, S.isPlainObject(e) && e));
        };
    }), S.ajaxPrefilter(function(e) {
        var t;
        for(t in e.headers)"content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "");
    }), S._evalUrl = function(e, t, n) {
        return S.ajax({
            url: e,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            converters: {
                "text script": function() {}
            },
            dataFilter: function(e) {
                S.globalEval(e, t, n);
            }
        });
    }, S.fn.extend({
        wrapAll: function(e) {
            var t;
            return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                var e = this;
                while(e.firstElementChild)e = e.firstElementChild;
                return e;
            }).append(this)), this;
        },
        wrapInner: function(n) {
            return m(n) ? this.each(function(e) {
                S(this).wrapInner(n.call(this, e));
            }) : this.each(function() {
                var e = S(this), t = e.contents();
                t.length ? t.wrapAll(n) : e.append(n);
            });
        },
        wrap: function(t) {
            var n = m(t);
            return this.each(function(e) {
                S(this).wrapAll(n ? t.call(this, e) : t);
            });
        },
        unwrap: function(e) {
            return this.parent(e).not("body").each(function() {
                S(this).replaceWith(this.childNodes);
            }), this;
        }
    }), S.expr.pseudos.hidden = function(e) {
        return !S.expr.pseudos.visible(e);
    }, S.expr.pseudos.visible = function(e) {
        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
    }, S.ajaxSettings.xhr = function() {
        try {
            return new C.XMLHttpRequest;
        } catch (e) {}
    };
    var Bt = {
        0: 200,
        1223: 204
    }, $t = S.ajaxSettings.xhr();
    y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function(i) {
        var o, a;
        if (y.cors || $t && !i.crossDomain) return {
            send: function(e, t) {
                var n, r = i.xhr();
                if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for(n in i.xhrFields)r[n] = i.xhrFields[n];
                for(n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e)r.setRequestHeader(n, e[n]);
                o = function(e) {
                    return function() {
                        o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
                            binary: r.response
                        } : {
                            text: r.responseText
                        }, r.getAllResponseHeaders()));
                    };
                }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function() {
                    4 === r.readyState && C.setTimeout(function() {
                        o && a();
                    });
                }, o = o("abort");
                try {
                    r.send(i.hasContent && i.data || null);
                } catch (e1) {
                    if (o) throw e1;
                }
            },
            abort: function() {
                o && o();
            }
        };
    }), S.ajaxPrefilter(function(e) {
        e.crossDomain && (e.contents.script = !1);
    }), S.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(e) {
                return S.globalEval(e), e;
            }
        }
    }), S.ajaxPrefilter("script", function(e) {
        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
    }), S.ajaxTransport("script", function(n) {
        var r, i;
        if (n.crossDomain || n.scriptAttrs) return {
            send: function(e, t) {
                r = S("<script>").attr(n.scriptAttrs || {}).prop({
                    charset: n.scriptCharset,
                    src: n.url
                }).on("load error", i = function(e) {
                    r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type);
                }), E.head.appendChild(r[0]);
            },
            abort: function() {
                i && i();
            }
        };
    });
    var _t, zt = [], Ut = /(=)\?(?=&|$)|\?\?/;
    S.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var e = zt.pop() || S.expando + "_" + wt.guid++;
            return this[e] = !0, e;
        }
    }), S.ajaxPrefilter("json jsonp", function(e, t, n) {
        var r, i, o, a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data");
        if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() {
            return o || S.error(r + " was not called"), o[0];
        }, e.dataTypes[0] = "json", i = C[r], C[r] = function() {
            o = arguments;
        }, n.always(function() {
            void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0;
        }), "script";
    }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function(e, t, n) {
        var r, i, o;
        return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [
            t.createElement(i[1])
        ] : (i = xe([
            e
        ], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes)));
    }, S.fn.load = function(e, t, n) {
        var r, i, o, a = this, s = e.indexOf(" ");
        return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({
            url: e,
            type: i || "GET",
            dataType: "html",
            data: t
        }).done(function(e) {
            o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e);
        }).always(n && function(e, t) {
            a.each(function() {
                n.apply(this, o || [
                    e.responseText,
                    t,
                    e
                ]);
            });
        }), this;
    }, S.expr.pseudos.animated = function(t) {
        return S.grep(S.timers, function(e) {
            return t === e.elem;
        }).length;
    }, S.offset = {
        setOffset: function(e, t, n) {
            var r, i, o, a, s, u, l = S.css(e, "position"), c = S(e), f = {};
            "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f);
        }
    }, S.fn.extend({
        offset: function(t) {
            if (arguments.length) return void 0 === t ? this : this.each(function(e) {
                S.offset.setOffset(this, t, e);
            });
            var e, n, r = this[0];
            return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
                top: e.top + n.pageYOffset,
                left: e.left + n.pageXOffset
            }) : {
                top: 0,
                left: 0
            } : void 0;
        },
        position: function() {
            if (this[0]) {
                var e, t, n, r = this[0], i = {
                    top: 0,
                    left: 0
                };
                if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect();
                else {
                    t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
                    while(e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position"))e = e.parentNode;
                    e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0));
                }
                return {
                    top: t.top - i.top - S.css(r, "marginTop", !0),
                    left: t.left - i.left - S.css(r, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                var e = this.offsetParent;
                while(e && "static" === S.css(e, "position"))e = e.offsetParent;
                return e || re;
            });
        }
    }), S.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(t, i) {
        var o = "pageYOffset" === i;
        S.fn[t] = function(e) {
            return $(this, function(e, t, n) {
                var r;
                if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
                r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n;
            }, t, e, arguments.length);
        };
    }), S.each([
        "top",
        "left"
    ], function(e, n) {
        S.cssHooks[n] = Fe(y.pixelPosition, function(e, t) {
            if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t;
        });
    }), S.each({
        Height: "height",
        Width: "width"
    }, function(a, s) {
        S.each({
            padding: "inner" + a,
            content: s,
            "": "outer" + a
        }, function(r, o) {
            S.fn[o] = function(e, t) {
                var n = arguments.length && (r || "boolean" != typeof e), i = r || (!0 === e || !0 === t ? "margin" : "border");
                return $(this, function(e, t, n) {
                    var r;
                    return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i);
                }, s, n ? e : void 0, n);
            };
        });
    }), S.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function(e, t) {
        S.fn[t] = function(e) {
            return this.on(t, e);
        };
    }), S.fn.extend({
        bind: function(e, t, n) {
            return this.on(e, null, t, n);
        },
        unbind: function(e, t) {
            return this.off(e, null, t);
        },
        delegate: function(e, t, n, r) {
            return this.on(t, e, n, r);
        },
        undelegate: function(e, t, n) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
        },
        hover: function(e, t) {
            return this.mouseenter(e).mouseleave(t || e);
        }
    }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, n) {
        S.fn[n] = function(e, t) {
            return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n);
        };
    });
    var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    S.proxy = function(e, t) {
        var n, r, i;
        if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function() {
            return e.apply(t || this, r.concat(s.call(arguments)));
        }).guid = e.guid = e.guid || S.guid++, i;
    }, S.holdReady = function(e) {
        e ? S.readyWait++ : S.ready(!0);
    }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function(e) {
        var t = S.type(e);
        return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
    }, S.trim = function(e) {
        return null == e ? "" : (e + "").replace(Xt, "");
    }, "function" == typeof define && define.amd && define("jquery", [], function() {
        return S;
    });
    var Vt = C.jQuery, Gt = C.$;
    return S.noConflict = function(e) {
        return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S;
    }, "undefined" == typeof e && (C.jQuery = C.$ = S), S;
});

},{}],"67La9":[function(require,module,exports) {
var global = arguments[3];
/*! JointJS v3.5.5 (2022-04-08) - JavaScript diagramming library


This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/ if (function(t, e) {
    e(exports, require("/js/lib/backbone.js/backbone.min"), require("/js/lib/lodash.js/lodash.min"), require("/js/lib/jquery/jquery.min"));
}(this, function(t, s, i, S) {
    "use strict";
    s = s && s.hasOwnProperty("default") ? s.default : s, i = i && i.hasOwnProperty("default") ? i.default : i, S = S && S.hasOwnProperty("default") ? S.default : S;
    var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function n(t, e) {
        return t(e = {
            exports: {}
        }, e.exports), e.exports;
    }
    var r = function(t) {
        return t && t.Math == Math && t;
    }, u = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof e && e) || function() {
        return this;
    }() || Function("return this")(), a = function(t) {
        try {
            return !!t();
        } catch (t1) {
            return !0;
        }
    }, l = !a(function() {
        return 7 != Object.defineProperty({}, 1, {
            get: function() {
                return 7;
            }
        })[1];
    }), o = {}.propertyIsEnumerable, c = Object.getOwnPropertyDescriptor, h = {
        f: c && !o.call({
            1: 2
        }, 1) ? function(t) {
            var e = c(this, t);
            return !!e && e.enumerable;
        } : o
    }, C = function(t, e) {
        return {
            enumerable: !(1 & t),
            configurable: !(2 & t),
            writable: !(4 & t),
            value: e
        };
    }, g = {}.toString, d = function(t) {
        return g.call(t).slice(8, -1);
    }, f = "".split, y = a(function() {
        return !Object("z").propertyIsEnumerable(0);
    }) ? function(t) {
        return "String" == d(t) ? f.call(t, "") : Object(t);
    } : Object, p = function(t) {
        if (null == t) throw TypeError("Can't call method on " + t);
        return t;
    }, m = function(t) {
        return y(p(t));
    }, I = function(t) {
        return "object" == typeof t ? null !== t : "function" == typeof t;
    }, v = function(t, e) {
        if (!I(t)) return t;
        var i, n;
        if (e && "function" == typeof (i = t.toString) && !I(n = i.call(t))) return n;
        if ("function" == typeof (i = t.valueOf) && !I(n = i.call(t))) return n;
        if (!e && "function" == typeof (i = t.toString) && !I(n = i.call(t))) return n;
        throw TypeError("Can't convert object to primitive value");
    }, A = {}.hasOwnProperty, w = function(t, e) {
        return A.call(t, e);
    }, b = u.document, N = I(b) && I(b.createElement), x = function(t) {
        return N ? b.createElement(t) : {};
    }, M = !l && !a(function() {
        return 7 != Object.defineProperty(x("div"), "a", {
            get: function() {
                return 7;
            }
        }).a;
    }), k = Object.getOwnPropertyDescriptor, D = {
        f: l ? k : function(t, e) {
            if (t = m(t), e = v(e, !0), M) try {
                return k(t, e);
            } catch (t1) {}
            if (w(t, e)) return C(!h.f.call(t, e), t[e]);
        }
    }, T = function(t) {
        if (!I(t)) throw TypeError(String(t) + " is not an object");
        return t;
    }, L = Object.defineProperty, z = {
        f: l ? L : function(t, e, i) {
            if (T(t), e = v(e, !0), T(i), M) try {
                return L(t, e, i);
            } catch (t1) {}
            if ("get" in i || "set" in i) throw TypeError("Accessors not supported");
            return "value" in i && (t[e] = i.value), t;
        }
    }, P = l ? function(t, e, i) {
        return z.f(t, e, C(1, i));
    } : function(t, e, i) {
        return t[e] = i, t;
    }, j = function(e, i) {
        try {
            P(u, e, i);
        } catch (t) {
            u[e] = i;
        }
        return i;
    }, Z = "__core-js_shared__", G = u[Z] || j(Z, {}), B = Function.toString;
    "function" != typeof G.inspectSource && (G.inspectSource = function(t) {
        return B.call(t);
    });
    var O, E, R, Y = G.inspectSource, W = u.WeakMap, U = "function" == typeof W && /native code/.test(Y(W)), F = n(function(t) {
        (t.exports = function(t, e) {
            return G[t] || (G[t] = void 0 !== e ? e : {});
        })("versions", []).push({
            version: "3.8.3",
            mode: "global",
            copyright: "\xa9 2021 Denis Pushkarev (zloirock.ru)"
        });
    }), V = 0, X = Math.random(), H = function(t) {
        return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++V + X).toString(36);
    }, J = F("keys"), _ = function(t) {
        return J[t] || (J[t] = H(t));
    }, Q = {}, K = u.WeakMap;
    if (U) {
        var q = G.state || (G.state = new K), $ = q.get, tt = q.has, et = q.set;
        O = function(t, e) {
            return e.facade = t, et.call(q, t, e), e;
        }, E = function(t) {
            return $.call(q, t) || {};
        }, R = function(t) {
            return tt.call(q, t);
        };
    } else {
        var it = _("state");
        Q[it] = !0, O = function(t, e) {
            return e.facade = t, P(t, it, e), e;
        }, E = function(t) {
            return w(t, it) ? t[it] : {};
        }, R = function(t) {
            return w(t, it);
        };
    }
    var nt, rt = {
        set: O,
        get: E,
        has: R,
        enforce: function(t) {
            return R(t) ? E(t) : O(t, {});
        },
        getterFor: function(i) {
            return function(t) {
                var e;
                if (!I(t) || (e = E(t)).type !== i) throw TypeError("Incompatible receiver, " + i + " required");
                return e;
            };
        }
    }, ot = n(function(t) {
        var e = rt.get, l = rt.enforce, c = String(String).split("String");
        (t.exports = function(t, e, i, n) {
            var r, o = !!n && !!n.unsafe, a = !!n && !!n.enumerable, s = !!n && !!n.noTargetGet;
            "function" == typeof i && ("string" != typeof e || w(i, "name") || P(i, "name", e), (r = l(i)).source || (r.source = c.join("string" == typeof e ? e : ""))), t !== u ? (o ? !s && t[e] && (a = !0) : delete t[e], a ? t[e] = i : P(t, e, i)) : a ? t[e] = i : j(e, i);
        })(Function.prototype, "toString", function() {
            return "function" == typeof this && e(this).source || Y(this);
        });
    }), at = u, st = function(t) {
        return "function" == typeof t ? t : void 0;
    }, lt = function(t, e) {
        return arguments.length < 2 ? st(at[t]) || st(u[t]) : at[t] && at[t][e] || u[t] && u[t][e];
    }, ct = Math.ceil, ut = Math.floor, ht = function(t) {
        return isNaN(t = +t) ? 0 : (0 < t ? ut : ct)(t);
    }, gt = Math.min, dt = function(t) {
        return 0 < t ? gt(ht(t), 9007199254740991) : 0;
    }, ft = Math.max, pt = Math.min, mt = function(c) {
        return function(t, e, i) {
            var n, r, o, a = m(t), s = dt(a.length), l = (n = s, (r = ht(i)) < 0 ? ft(r + n, 0) : pt(r, n));
            if (c && e != e) {
                for(; l < s;)if ((o = a[l++]) != o) return !0;
            } else for(; l < s; l++)if ((c || l in a) && a[l] === e) return c || l || 0;
            return !c && -1;
        };
    }, It = {
        includes: mt(!0),
        indexOf: mt(!1)
    }, vt = It.indexOf, At = function(t, e) {
        var i, n = m(t), r = 0, o = [];
        for(i in n)!w(Q, i) && w(n, i) && o.push(i);
        for(; e.length > r;)w(n, i = e[r++]) && (~vt(o, i) || o.push(i));
        return o;
    }, Ct = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
    ], yt = Ct.concat("length", "prototype"), wt = {
        f: Object.getOwnPropertyNames || function(t) {
            return At(t, yt);
        }
    }, bt = {
        f: Object.getOwnPropertySymbols
    }, Nt = lt("Reflect", "ownKeys") || function(t) {
        var e = wt.f(T(t)), i = bt.f;
        return i ? e.concat(i(t)) : e;
    }, xt = function(t, e) {
        for(var i = Nt(e), n = z.f, r = D.f, o = 0; o < i.length; o++){
            var a = i[o];
            w(t, a) || n(t, a, r(e, a));
        }
    }, Mt = /#|\.prototype\./, St = function(t, e) {
        var i = Dt[kt(t)];
        return i == Lt || i != Tt && ("function" == typeof e ? a(e) : !!e);
    }, kt = St.normalize = function(t) {
        return String(t).replace(Mt, ".").toLowerCase();
    }, Dt = St.data = {}, Tt = St.NATIVE = "N", Lt = St.POLYFILL = "P", zt = St, Pt = D.f, jt = function(t, e) {
        var i, n, r, o, a, s = t.target, l = t.global, c = t.stat;
        if (i = l ? u : c ? u[s] || j(s, {}) : (u[s] || {}).prototype) for(n in e){
            if (o = e[n], r = t.noTargetGet ? (a = Pt(i, n)) && a.value : i[n], !zt(l ? n : s + (c ? "." : "#") + n, t.forced) && void 0 !== r) {
                if (typeof o == typeof r) continue;
                xt(o, r);
            }
            (t.sham || r && r.sham) && P(o, "sham", !0), ot(i, n, o, t);
        }
    }, Zt = !!Object.getOwnPropertySymbols && !a(function() {
        return !String(Symbol());
    }), Gt = Zt && !Symbol.sham && "symbol" == typeof Symbol.iterator, Bt = F("wks"), Ot = u.Symbol, Et = Gt ? Ot : Ot && Ot.withoutSetter || H, Rt = function(t) {
        return w(Bt, t) || (Zt && w(Ot, t) ? Bt[t] = Ot[t] : Bt[t] = Et("Symbol." + t)), Bt[t];
    }, Yt = Object.keys || function(t) {
        return At(t, Ct);
    }, Wt = l ? Object.defineProperties : function(t, e) {
        T(t);
        for(var i, n = Yt(e), r = n.length, o = 0; o < r;)z.f(t, i = n[o++], e[i]);
        return t;
    }, Ut = lt("document", "documentElement"), Ft = "prototype", Vt = "script", Xt = _("IE_PROTO"), Ht = function() {}, Jt = function(t) {
        return "<script>" + t + "</" + Vt + ">";
    }, _t = function() {
        try {
            nt = document.domain && new ActiveXObject("htmlfile");
        } catch (t) {}
        var t1, e;
        _t = nt ? function(t) {
            t.write(Jt("")), t.close();
            var e = t.parentWindow.Object;
            return t = null, e;
        }(nt) : ((e = x("iframe")).style.display = "none", Ut.appendChild(e), e.src = String("javascript:"), (t1 = e.contentWindow.document).open(), t1.write(Jt("document.F=Object")), t1.close(), t1.F);
        for(var i = Ct.length; i--;)delete _t[Ft][Ct[i]];
        return _t();
    };
    Q[Xt] = !0;
    var Qt = Object.create || function(t, e) {
        var i;
        return null !== t ? (Ht[Ft] = T(t), i = new Ht, Ht[Ft] = null, i[Xt] = t) : i = _t(), void 0 === e ? i : Wt(i, e);
    }, Kt = Rt("unscopables"), qt = Array.prototype;
    null == qt[Kt] && z.f(qt, Kt, {
        configurable: !0,
        value: Qt(null)
    });
    var $t = function(t) {
        qt[Kt][t] = !0;
    }, te = Object.defineProperty, ee = {}, ie = function(t) {
        throw t;
    }, ne = function(t, e) {
        if (w(ee, t)) return ee[t];
        e || (e = {});
        var i = [][t], n = !!w(e, "ACCESSORS") && e.ACCESSORS, r = w(e, 0) ? e[0] : ie, o = w(e, 1) ? e[1] : void 0;
        return ee[t] = !!i && !a(function() {
            if (n && !l) return !0;
            var t = {
                length: -1
            };
            n ? te(t, 1, {
                enumerable: !0,
                get: ie
            }) : t[1] = 1, i.call(t, r, o);
        });
    }, re = It.includes, oe = ne("indexOf", {
        ACCESSORS: !0,
        1: 0
    });
    jt({
        target: "Array",
        proto: !0,
        forced: !oe
    }, {
        includes: function(t) {
            return re(this, t, 1 < arguments.length ? arguments[1] : void 0);
        }
    }), $t("includes");
    var ae = function(n, r, t) {
        if (function(t) {
            if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
        }(n), void 0 === r) return n;
        switch(t){
            case 0:
                return function() {
                    return n.call(r);
                };
            case 1:
                return function(t) {
                    return n.call(r, t);
                };
            case 2:
                return function(t, e) {
                    return n.call(r, t, e);
                };
            case 3:
                return function(t, e, i) {
                    return n.call(r, t, e, i);
                };
        }
        return function() {
            return n.apply(r, arguments);
        };
    }, se = Function.call, le = function(t, e, i) {
        return ae(se, u[t].prototype[e], i);
    }, ce = (le("Array", "includes"), function(t) {
        return Object(p(t));
    }), ue = Array.isArray || function(t) {
        return "Array" == d(t);
    }, he = Rt("species"), ge = function(t, e) {
        var i;
        return ue(t) && ("function" != typeof (i = t.constructor) || i !== Array && !ue(i.prototype) ? I(i) && null === (i = i[he]) && (i = void 0) : i = void 0), new (void 0 === i ? Array : i)(0 === e ? 0 : e);
    }, de = [].push, fe = function(d) {
        var f = 1 == d, p = 2 == d, m = 3 == d, I = 4 == d, v = 6 == d, A = 7 == d, C = 5 == d || v;
        return function(t, e, i, n) {
            for(var r, o, a = ce(t), s = y(a), l = ae(e, i, 3), c = dt(s.length), u = 0, h = n || ge, g = f ? h(t, c) : p || A ? h(t, 0) : void 0; u < c; u++)if ((C || u in s) && (o = l(r = s[u], u, a), d)) {
                if (f) g[u] = o;
                else if (o) switch(d){
                    case 3:
                        return !0;
                    case 5:
                        return r;
                    case 6:
                        return u;
                    case 2:
                        de.call(g, r);
                }
                else switch(d){
                    case 4:
                        return !1;
                    case 7:
                        de.call(g, r);
                }
            }
            return v ? -1 : m || I ? I : g;
        };
    }, pe = {
        forEach: fe(0),
        map: fe(1),
        filter: fe(2),
        some: fe(3),
        every: fe(4),
        find: fe(5),
        findIndex: fe(6),
        filterOut: fe(7)
    }, me = pe.find, Ie = "find", ve = !0, Ae = ne(Ie);
    Ie in [] && Array(1)[Ie](function() {
        ve = !1;
    }), jt({
        target: "Array",
        proto: !0,
        forced: ve || !Ae
    }, {
        find: function(t) {
            return me(this, t, 1 < arguments.length ? arguments[1] : void 0);
        }
    }), $t(Ie);
    le("Array", "find");
    var Ce, ye, we, be = function(s) {
        return function(t, e) {
            var i, n, r = String(p(t)), o = ht(e), a = r.length;
            return o < 0 || a <= o ? s ? "" : void 0 : (i = r.charCodeAt(o)) < 55296 || 56319 < i || o + 1 === a || (n = r.charCodeAt(o + 1)) < 56320 || 57343 < n ? s ? r.charAt(o) : i : s ? r.slice(o, o + 2) : n - 56320 + (i - 55296 << 10) + 65536;
        };
    }, Ne = {
        codeAt: be(!1),
        charAt: be(!0)
    }, xe = !a(function() {
        function t() {}
        return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype;
    }), Me = _("IE_PROTO"), Se = Object.prototype, ke = xe ? Object.getPrototypeOf : function(t) {
        return t = ce(t), w(t, Me) ? t[Me] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? Se : null;
    }, De = Rt("iterator"), Te = !1;
    [].keys && ("next" in (we = [].keys()) ? (ye = ke(ke(we))) !== Object.prototype && (Ce = ye) : Te = !0);
    var Le = null == Ce || a(function() {
        var t = {};
        return Ce[De].call(t) !== t;
    });
    Le && (Ce = {}), w(Ce, De) || P(Ce, De, function() {
        return this;
    });
    var ze = {
        IteratorPrototype: Ce,
        BUGGY_SAFARI_ITERATORS: Te
    }, Pe = z.f, je = Rt("toStringTag"), Ze = function(t, e, i) {
        t && !w(t = i ? t : t.prototype, je) && Pe(t, je, {
            configurable: !0,
            value: e
        });
    }, Ge = {}, Be = ze.IteratorPrototype, Oe = function() {
        return this;
    }, Ee = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var i, n = !1, t = {};
        try {
            (i = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(t, []), n = t instanceof Array;
        } catch (t1) {}
        return function(t, e) {
            return T(t), function(t) {
                if (!I(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
            }(e), n ? i.call(t, e) : t.__proto__ = e, t;
        };
    }() : void 0), Re = ze.IteratorPrototype, Ye = ze.BUGGY_SAFARI_ITERATORS, We = Rt("iterator"), Ue = "values", Fe = "entries", Ve = function() {
        return this;
    }, Xe = Ne.charAt, He = "String Iterator", Je = rt.set, _e = rt.getterFor(He);
    !function(t, e, i, n, r, o, a) {
        var s, l, c;
        l = n, c = e + " Iterator", (s = i).prototype = Qt(Be, {
            next: C(1, l)
        }), Ze(s, c, !1), Ge[c] = Oe;
        var u, h, g, d = function(t) {
            if (t === r && v) return v;
            if (!Ye && t in m) return m[t];
            switch(t){
                case "keys":
                case Ue:
                case Fe:
                    return function() {
                        return new i(this, t);
                    };
            }
            return function() {
                return new i(this);
            };
        }, f = e + " Iterator", p = !1, m = t.prototype, I = m[We] || m["@@iterator"] || r && m[r], v = !Ye && I || d(r), A = "Array" == e && m.entries || I;
        if (A && (u = ke(A.call(new t)), Re !== Object.prototype && u.next && (ke(u) !== Re && (Ee ? Ee(u, Re) : "function" != typeof u[We] && P(u, We, Ve)), Ze(u, f, !0))), r == Ue && I && I.name !== Ue && (p = !0, v = function() {
            return I.call(this);
        }), m[We] !== v && P(m, We, v), Ge[e] = v, r) {
            if (h = {
                values: d(Ue),
                keys: o ? v : d("keys"),
                entries: d(Fe)
            }, a) for(g in h)!Ye && !p && g in m || ot(m, g, h[g]);
            else jt({
                target: e,
                proto: !0,
                forced: Ye || p
            }, h);
        }
    }(String, "String", function(t) {
        Je(this, {
            type: He,
            string: String(t),
            index: 0
        });
    }, function() {
        var t, e = _e(this), i = e.string, n = e.index;
        return n >= i.length ? {
            value: void 0,
            done: !0
        } : (t = Xe(i, n), e.index += t.length, {
            value: t,
            done: !1
        });
    });
    var Qe = function(e, t, i, n) {
        try {
            return n ? t(T(i)[0], i[1]) : t(i);
        } catch (t1) {
            throw function(t) {
                var e = t.return;
                if (void 0 !== e) T(e.call(t)).value;
            }(e), t1;
        }
    }, Ke = Rt("iterator"), qe = Array.prototype, $e = function(t, e, i) {
        var n = v(e);
        n in t ? z.f(t, n, C(0, i)) : t[n] = i;
    }, ti = {};
    ti[Rt("toStringTag")] = "z";
    var ei = "[object z]" === String(ti), ii = Rt("toStringTag"), ni = "Arguments" == d(function() {
        return arguments;
    }()), ri = ei ? d : function(t) {
        var e, i, n;
        return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = function(t, e) {
            try {
                return t[e];
            } catch (t1) {}
        }(e = Object(t), ii)) ? i : ni ? d(e) : "Object" == (n = d(e)) && "function" == typeof e.callee ? "Arguments" : n;
    }, oi = Rt("iterator"), ai = Rt("iterator"), si = !1;
    try {
        var li = 0, ci = {
            next: function() {
                return {
                    done: !!li++
                };
            },
            return: function() {
                si = !0;
            }
        };
        ci[ai] = function() {
            return this;
        }, Array.from(ci, function() {
            throw 2;
        });
    } catch (t1) {}
    var ui = !function(t, e) {
        if (!e && !si) return !1;
        var i = !1;
        try {
            var n = {};
            n[ai] = function() {
                return {
                    next: function() {
                        return {
                            done: i = !0
                        };
                    }
                };
            }, t(n);
        } catch (t1) {}
        return i;
    }(function(t) {
        Array.from(t);
    });
    jt({
        target: "Array",
        stat: !0,
        forced: ui
    }, {
        from: function(t) {
            var e, i, n, r, o, a, s, l = ce(t), c = "function" == typeof this ? this : Array, u = arguments.length, h = 1 < u ? arguments[1] : void 0, g = void 0 !== h, d = function(t) {
                if (null != t) return t[oi] || t["@@iterator"] || Ge[ri(t)];
            }(l), f = 0;
            if (g && (h = ae(h, 2 < u ? arguments[2] : void 0, 2)), null != d && (c != Array || void 0 === (s = d) || Ge.Array !== s && qe[Ke] !== s)) for(o = (r = d.call(l)).next, i = new c; !(n = o.call(r)).done; f++)a = g ? Qe(r, h, [
                n.value,
                f
            ], !0) : n.value, $e(i, f, a);
            else for(i = new c(e = dt(l.length)); f < e; f++)a = g ? h(l[f], f) : l[f], $e(i, f, a);
            return i.length = f, i;
        }
    });
    at.Array.from;
    var hi = pe.findIndex, gi = "findIndex", di = !0, fi = ne(gi);
    gi in [] && Array(1)[gi](function() {
        di = !1;
    }), jt({
        target: "Array",
        proto: !0,
        forced: di || !fi
    }, {
        findIndex: function(t) {
            return hi(this, t, 1 < arguments.length ? arguments[1] : void 0);
        }
    }), $t(gi);
    le("Array", "findIndex"), n(function(t, e) {
        !function() {
            var t = e, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            function l(t) {
                this.message = t;
            }
            (l.prototype = new Error).name = "InvalidCharacterError", t.btoa || (t.btoa = function(t) {
                for(var e, i, n = String(t), r = 0, o = s, a = ""; n.charAt(0 | r) || (o = "=", r % 1); a += o.charAt(63 & e >> 8 - r % 1 * 8)){
                    if (255 < (i = n.charCodeAt(r += .75))) throw new l("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
                    e = e << 8 | i;
                }
                return a;
            }), t.atob || (t.atob = function(t) {
                var e = String(t).replace(/=+$/, "");
                if (e.length % 4 == 1) throw new l("'atob' failed: The string to be decoded is not correctly encoded.");
                for(var i, n, r = 0, o = 0, a = ""; n = e.charAt(o++); ~n && (i = r % 4 ? 64 * i + n : n, (r++) % 4) && (a += String.fromCharCode(255 & i >> (-2 * r & 6))))n = s.indexOf(n);
                return a;
            });
        }();
    });
    jt({
        target: "Number",
        stat: !0
    }, {
        isNaN: function(t) {
            return t != t;
        }
    });
    at.Number.isNaN;
    var pi = u.isFinite, mi = Number.isFinite || function(t) {
        return "number" == typeof t && pi(t);
    };
    jt({
        target: "Number",
        stat: !0
    }, {
        isFinite: mi
    });
    at.Number.isFinite;
    var Ii = Rt("match"), vi = function(t) {
        if (I(e = t) && (void 0 !== (i = e[Ii]) ? i : "RegExp" == d(e))) throw TypeError("The method doesn't accept regular expressions");
        var e, i;
        return t;
    }, Ai = Rt("match"), Ci = function(e) {
        var i = /./;
        try {
            "/./"[e](i);
        } catch (t) {
            try {
                return i[Ai] = !1, "/./"[e](i);
            } catch (t1) {}
        }
        return !1;
    };
    jt({
        target: "String",
        proto: !0,
        forced: !Ci("includes")
    }, {
        includes: function(t) {
            return !!~String(p(this)).indexOf(vi(t), 1 < arguments.length ? arguments[1] : void 0);
        }
    });
    le("String", "includes");
    var yi, wi = D.f, bi = "".startsWith, Ni = Math.min, xi = Ci("startsWith"), Mi = !(xi || !(yi = wi(String.prototype, "startsWith")) || yi.writable);
    jt({
        target: "String",
        proto: !0,
        forced: !Mi && !xi
    }, {
        startsWith: function(t) {
            var e = String(p(this));
            vi(t);
            var i = dt(Ni(1 < arguments.length ? arguments[1] : void 0, e.length)), n = String(t);
            return bi ? bi.call(e, n, i) : e.slice(i, i + n.length) === n;
        }
    });
    le("String", "startsWith");
    !function() {
        function n(t, e) {
            return this.slice(t, e);
        }
        function r(t, e) {
            arguments.length < 2 && (e = 0);
            for(var i = 0, n = t.length; i < n; ++i, ++e)this[e] = 255 & t[i];
        }
        function t(t) {
            var e;
            if ("number" == typeof t) {
                e = new Array(t);
                for(var i = 0; i < t; ++i)e[i] = 0;
            } else e = t.slice(0);
            return e.subarray = n, (e.buffer = e).byteLength = e.length, e.set = r, "object" == typeof t && t.buffer && (e.buffer = t.buffer), e;
        }
        "undefined" == typeof Uint8Array && "undefined" != typeof window && (window.Uint8Array = t, window.Uint32Array = t, window.Int32Array = t);
    }();
    var Si = Math.round, ki = Math.floor, Di = Math.PI, Ti = function(t) {
        return t % 360 + (t < 0 ? 360 : 0);
    }, Li = function(t, e) {
        return e * Si(t / e);
    }, zi = function(t) {
        return 180 * t / Di % 360;
    }, Pi = function(t, e) {
        return (t = (e = e || !1) ? t : t % 360) * Di / 180;
    }, ji = function(t, e) {
        if (void 0 === e) e = void 0 === t ? 1 : t, t = 0;
        else if (e < t) {
            var i = t;
            t = e, e = i;
        }
        return ki(Math.random() * (e - t + 1) + t);
    }, Zi = Math.cos, Gi = Math.sin, Bi = Math.atan2, Oi = function(t, e) {
        var i = Pi(t.y), n = Pi(e.y), r = t.x, o = e.x, a = Pi(o - r), s = Gi(a) * Zi(n), l = Zi(i) * Gi(n) - Gi(i) * Zi(n) * Zi(a), c = zi(Bi(s, l)) - 22.5;
        return c < 0 && (c += 360), [
            "NE",
            "E",
            "SE",
            "S",
            "SW",
            "W",
            "NW",
            "N"
        ][c = parseInt(c / 45)];
    }, Ei = function(t, e) {
        var i = t.x, n = t.y;
        return (i -= e.x) * i + (n -= e.y) * n;
    }, Ri = function(t, e) {
        return Math.sqrt(Ei(t, e));
    }, Yi = {
        Point: 1,
        Line: 2,
        Ellipse: 3,
        Rect: 4,
        Polyline: 5,
        Polygon: 6,
        Curve: 7,
        Path: 8
    }, Wi = Math.abs, Ui = Math.cos, Fi = Math.sin, Vi = Math.sqrt, Xi = Math.min, Hi = Math.max, Ji = Math.atan2, _i = Math.round, Qi = Math.pow, Ki = Math.PI, qi = function(t, e) {
        if (!(this instanceof qi)) return new qi(t, e);
        if ("string" == typeof t) {
            var i = t.split(-1 === t.indexOf("@") ? " " : "@");
            t = parseFloat(i[0]), e = parseFloat(i[1]);
        } else Object(t) === t && (e = t.y, t = t.x);
        this.x = void 0 === t ? 0 : t, this.y = void 0 === e ? 0 : e;
    };
    qi.fromPolar = function(t, e, i) {
        i = new qi(i);
        var n = Wi(t * Ui(e)), r = Wi(t * Fi(e)), o = Ti(zi(e));
        return o < 90 ? r = -r : o < 180 ? (n = -n, r = -r) : o < 270 && (n = -n), new qi(i.x + n, i.y + r);
    }, qi.random = function(t, e, i, n) {
        return new qi(ji(t, e), ji(i, n));
    }, qi.prototype = {
        type: Yi.Point,
        chooseClosest: function(t) {
            var e = t.length;
            if (1 === e) return new qi(t[0]);
            for(var i = null, n = 1 / 0, r = 0; r < e; r++){
                var o = new qi(t[r]), a = this.squaredDistance(o);
                a < n && (i = o, n = a);
            }
            return i;
        },
        adhereToRect: function(t) {
            return t.containsPoint(this) || (this.x = Xi(Hi(this.x, t.x), t.x + t.width), this.y = Xi(Hi(this.y, t.y), t.y + t.height)), this;
        },
        angleBetween: function(t, e) {
            var i = this.equals(t) || this.equals(e) ? NaN : this.theta(e) - this.theta(t);
            return i < 0 && (i += 360), i;
        },
        bearing: function(t) {
            return Oi(this, t);
        },
        changeInAngle: function(t, e, i) {
            return this.clone().offset(-t, -e).theta(i) - this.theta(i);
        },
        clone: function() {
            return new qi(this);
        },
        cross: function(t, e) {
            return t && e ? (e.x - this.x) * (t.y - this.y) - (e.y - this.y) * (t.x - this.x) : NaN;
        },
        difference: function(t, e) {
            return Object(t) === t && (e = t.y, t = t.x), new qi(this.x - (t || 0), this.y - (e || 0));
        },
        distance: function(t) {
            return Ri(this, t);
        },
        dot: function(t) {
            return t ? this.x * t.x + this.y * t.y : NaN;
        },
        equals: function(t) {
            return !!t && this.x === t.x && this.y === t.y;
        },
        lerp: function(t, e) {
            var i = this.x, n = this.y;
            return new qi((1 - e) * i + e * t.x, (1 - e) * n + e * t.y);
        },
        magnitude: function() {
            return Vi(this.x * this.x + this.y * this.y) || .01;
        },
        manhattanDistance: function(t) {
            return Wi(t.x - this.x) + Wi(t.y - this.y);
        },
        move: function(t, e) {
            var i = Pi(new qi(t).theta(this));
            return this.offset(Ui(i) * e, -Fi(i) * e);
        },
        normalize: function(t) {
            var e = (t || 1) / this.magnitude();
            return this.scale(e, e);
        },
        offset: function(t, e) {
            return Object(t) === t && (e = t.y, t = t.x), this.x += t || 0, this.y += e || 0, this;
        },
        reflection: function(t) {
            return new qi(t).move(this, this.distance(t));
        },
        rotate: function(t, e) {
            if (0 === e) return this;
            t = t || new qi(0, 0), e = Pi(Ti(-e));
            var i = Ui(e), n = Fi(e), r = i * (this.x - t.x) - n * (this.y - t.y) + t.x, o = n * (this.x - t.x) + i * (this.y - t.y) + t.y;
            return this.x = r, this.y = o, this;
        },
        round: function(t) {
            var e = 1;
            if (t) switch(t){
                case 1:
                    e = 10;
                    break;
                case 2:
                    e = 100;
                    break;
                case 3:
                    e = 1e3;
                    break;
                default:
                    e = Qi(10, t);
            }
            return this.x = _i(this.x * e) / e, this.y = _i(this.y * e) / e, this;
        },
        scale: function(t, e, i) {
            return i = i && new qi(i) || new qi(0, 0), this.x = i.x + t * (this.x - i.x), this.y = i.y + e * (this.y - i.y), this;
        },
        snapToGrid: function(t, e) {
            return this.x = Li(this.x, t), this.y = Li(this.y, e || t), this;
        },
        squaredDistance: function(t) {
            return Ei(this, t);
        },
        theta: function(t) {
            var e = -((t = new qi(t)).y - this.y), i = t.x - this.x, n = Ji(e, i);
            return n < 0 && (n = 2 * Ki + n), 180 * n / Ki;
        },
        toJSON: function() {
            return {
                x: this.x,
                y: this.y
            };
        },
        toPolar: function(t) {
            t = t && new qi(t) || new qi(0, 0);
            var e = this.x, i = this.y;
            return this.x = Vi((e - t.x) * (e - t.x) + (i - t.y) * (i - t.y)), this.y = Pi(t.theta(new qi(e, i))), this;
        },
        toString: function() {
            return this.x + "@" + this.y;
        },
        serialize: function() {
            return this.x + "," + this.y;
        },
        update: function(t, e) {
            return Object(t) === t && (e = t.y, t = t.x), this.x = t || 0, this.y = e || 0, this;
        },
        vectorAngle: function(t) {
            return new qi(0, 0).angleBetween(this, t);
        }
    }, qi.prototype.translate = qi.prototype.offset;
    var $i = qi, tn = Math.max, en = Math.min, nn = function(t, e) {
        return this instanceof nn ? t instanceof nn ? new nn(t.start, t.end) : (this.start = new qi(t), void (this.end = new qi(e))) : new nn(t, e);
    };
    nn.prototype = {
        type: Yi.Line,
        angle: function() {
            var t = new qi(this.start.x + 1, this.start.y);
            return this.start.angleBetween(this.end, t);
        },
        bbox: function() {
            var t = en(this.start.x, this.end.x), e = en(this.start.y, this.end.y), i = tn(this.start.x, this.end.x), n = tn(this.start.y, this.end.y);
            return new In(t, e, i - t, n - e);
        },
        bearing: function() {
            return Oi(this.start, this.end);
        },
        clone: function() {
            return new nn(this.start, this.end);
        },
        closestPoint: function(t) {
            return this.pointAt(this.closestPointNormalizedLength(t));
        },
        closestPointLength: function(t) {
            return this.closestPointNormalizedLength(t) * this.length();
        },
        closestPointNormalizedLength: function(t) {
            var e = this.vector().dot(new nn(this.start, t).vector()), i = en(1, tn(0, e / this.squaredLength()));
            return i != i ? 0 : i;
        },
        closestPointTangent: function(t) {
            return this.tangentAt(this.closestPointNormalizedLength(t));
        },
        containsPoint: function(t) {
            var e = this.start, i = this.end;
            if (0 !== e.cross(t, i)) return !1;
            var n = this.length();
            return !(new nn(e, t).length() > n) && !(new nn(t, i).length() > n);
        },
        divideAt: function(t) {
            var e = this.pointAt(t);
            return [
                new nn(this.start, e),
                new nn(e, this.end)
            ];
        },
        divideAtLength: function(t) {
            var e = this.pointAtLength(t);
            return [
                new nn(this.start, e),
                new nn(e, this.end)
            ];
        },
        equals: function(t) {
            return !!t && this.start.x === t.start.x && this.start.y === t.start.y && this.end.x === t.end.x && this.end.y === t.end.y;
        },
        intersect: function(t, e) {
            if (t && t.intersectionWithLine) {
                var i = t.intersectionWithLine(this, e);
                return i && t instanceof nn && (i = i[0]), i;
            }
            return null;
        },
        intersectionWithLine: function(t) {
            var e = new qi(this.end.x - this.start.x, this.end.y - this.start.y), i = new qi(t.end.x - t.start.x, t.end.y - t.start.y), n = e.x * i.y - e.y * i.x, r = new qi(t.start.x - this.start.x, t.start.y - this.start.y), o = r.x * i.y - r.y * i.x, a = r.x * e.y - r.y * e.x;
            if (0 === n || o * n < 0 || a * n < 0) return null;
            if (0 < n) {
                if (n < o || n < a) return null;
            } else if (o < n || a < n) return null;
            return [
                new qi(this.start.x + o * e.x / n, this.start.y + o * e.y / n)
            ];
        },
        isDifferentiable: function() {
            return !this.start.equals(this.end);
        },
        length: function() {
            return Ri(this.start, this.end);
        },
        midpoint: function() {
            return new qi((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
        },
        parallel: function(t) {
            var e = this.clone();
            if (!this.isDifferentiable()) return e;
            var i = e.start, n = e.end, r = i.clone().rotate(n, 270), o = n.clone().rotate(i, 90);
            return i.move(o, t), n.move(r, t), e;
        },
        pointAt: function(t) {
            var e = this.start, i = this.end;
            return t <= 0 ? e.clone() : 1 <= t ? i.clone() : e.lerp(i, t);
        },
        pointAtLength: function(t) {
            var e = this.start, i = this.end, n = !0;
            t < 0 && (n = !1, t = -t);
            var r = this.length();
            return r <= t ? n ? i.clone() : e.clone() : this.pointAt((n ? t : r - t) / r);
        },
        pointOffset: function(t) {
            t = new qi(t);
            var e = this.start, i = this.end;
            return ((i.x - e.x) * (t.y - e.y) - (i.y - e.y) * (t.x - e.x)) / this.length();
        },
        rotate: function(t, e) {
            return this.start.rotate(t, e), this.end.rotate(t, e), this;
        },
        round: function(t) {
            return this.start.round(t), this.end.round(t), this;
        },
        scale: function(t, e, i) {
            return this.start.scale(t, e, i), this.end.scale(t, e, i), this;
        },
        setLength: function(t) {
            var e = this.length();
            if (!e) return this;
            var i = t / e;
            return this.scale(i, i, this.start);
        },
        squaredLength: function() {
            return Ei(this.start, this.end);
        },
        tangentAt: function(t) {
            if (!this.isDifferentiable()) return null;
            var e = this.start, i = this.end, n = this.pointAt(t), r = new nn(e, i);
            return r.translate(n.x - e.x, n.y - e.y), r;
        },
        tangentAtLength: function(t) {
            if (!this.isDifferentiable()) return null;
            var e = this.start, i = this.end, n = this.pointAtLength(t), r = new nn(e, i);
            return r.translate(n.x - e.x, n.y - e.y), r;
        },
        toString: function() {
            return this.start.toString() + " " + this.end.toString();
        },
        serialize: function() {
            return this.start.serialize() + " " + this.end.serialize();
        },
        translate: function(t, e) {
            return this.start.translate(t, e), this.end.translate(t, e), this;
        },
        vector: function() {
            return new qi(this.end.x - this.start.x, this.end.y - this.start.y);
        }
    }, nn.prototype.intersection = nn.prototype.intersect;
    var rn = nn, on = Math.sqrt, an = Math.round, sn = Math.pow, ln = function(t, e, i) {
        return this instanceof ln ? t instanceof ln ? new ln(new qi(t.x, t.y), t.a, t.b) : (t = new qi(t), this.x = t.x, this.y = t.y, this.a = e, void (this.b = i)) : new ln(t, e, i);
    };
    ln.fromRect = function(t) {
        return t = new In(t), new ln(t.center(), t.width / 2, t.height / 2);
    }, ln.prototype = {
        type: Yi.Ellipse,
        bbox: function() {
            return new In(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);
        },
        center: function() {
            return new qi(this.x, this.y);
        },
        clone: function() {
            return new ln(this);
        },
        containsPoint: function(t) {
            return this.normalizedDistance(t) <= 1;
        },
        equals: function(t) {
            return !!t && t.x === this.x && t.y === this.y && t.a === this.a && t.b === this.b;
        },
        inflate: function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = t), this.a += 2 * t, this.b += 2 * e, this;
        },
        intersectionWithLine: function(t) {
            var e = [], i = t.start, n = t.end, r = this.a, o = this.b, a = t.vector(), s = i.difference(new qi(this)), l = new qi(a.x / (r * r), a.y / (o * o)), c = new qi(s.x / (r * r), s.y / (o * o)), u = a.dot(l), h = a.dot(c), g = h * h - u * (s.dot(c) - 1);
            if (g < 0) return null;
            if (0 < g) {
                var d = on(g), f = (-h - d) / u, p = (-h + d) / u;
                if ((f < 0 || 1 < f) && (p < 0 || 1 < p)) return null;
                0 <= f && f <= 1 && e.push(i.lerp(n, f)), 0 <= p && p <= 1 && e.push(i.lerp(n, p));
            } else {
                var m = -h / u;
                if (!(0 <= m && m <= 1)) return null;
                e.push(i.lerp(n, m));
            }
            return e;
        },
        intersectionWithLineFromCenterToPoint: function(t, e) {
            t = new qi(t), e && t.rotate(new qi(this.x, this.y), e);
            var i, n = t.x - this.x, r = t.y - this.y;
            if (0 === n) return i = this.bbox().pointNearestToPoint(t), e ? i.rotate(new qi(this.x, this.y), -e) : i;
            var o = r / n, a = o * o, s = this.a * this.a, l = this.b * this.b, c = on(1 / (1 / s + a / l)), u = o * (c = n < 0 ? -c : c);
            return i = new qi(this.x + c, this.y + u), e ? i.rotate(new qi(this.x, this.y), -e) : i;
        },
        normalizedDistance: function(t) {
            var e = t.x, i = t.y, n = this.a, r = this.b, o = this.x, a = this.y;
            return (e - o) * (e - o) / (n * n) + (i - a) * (i - a) / (r * r);
        },
        round: function(t) {
            var e = 1;
            if (t) switch(t){
                case 1:
                    e = 10;
                    break;
                case 2:
                    e = 100;
                    break;
                case 3:
                    e = 1e3;
                    break;
                default:
                    e = sn(10, t);
            }
            return this.x = an(this.x * e) / e, this.y = an(this.y * e) / e, this.a = an(this.a * e) / e, this.b = an(this.b * e) / e, this;
        },
        tangentTheta: function(t) {
            var e, i, n = t.x, r = t.y, o = this.a, a = this.b, s = this.bbox().center(), l = s.x, c = s.y, u = n > s.x + o / 2, h = n < s.x - o / 2;
            return u || h ? i = o * o / (n - l) - o * o * (r - c) * ((e = n > s.x ? r - 30 : r + 30) - c) / (a * a * (n - l)) + l : e = a * a / (r - c) - a * a * (n - l) * ((i = r > s.y ? n + 30 : n - 30) - l) / (o * o * (r - c)) + c, new qi(i, e).theta(t);
        },
        toString: function() {
            return new qi(this.x, this.y).toString() + " " + this.a + " " + this.b;
        }
    };
    var cn = ln, un = Math.abs, hn = Math.cos, gn = Math.sin, dn = Math.min, fn = Math.max, pn = Math.round, mn = Math.pow, In = function(t, e, i, n) {
        if (!(this instanceof In)) return new In(t, e, i, n);
        Object(t) === t && (e = t.y, i = t.width, n = t.height, t = t.x), this.x = void 0 === t ? 0 : t, this.y = void 0 === e ? 0 : e, this.width = void 0 === i ? 0 : i, this.height = void 0 === n ? 0 : n;
    };
    In.fromEllipse = function(t) {
        return t = new ln(t), new In(t.x - t.a, t.y - t.b, 2 * t.a, 2 * t.b);
    }, In.fromPointUnion = function() {
        for(var t = [], e = arguments.length; e--;)t[e] = arguments[e];
        if (0 === t.length) return null;
        var i, n, r, o, a = new qi;
        i = n = 1 / 0, r = o = -1 / 0;
        for(var s = 0; s < t.length; s++){
            a.update(t[s]);
            var l = a.x, c = a.y;
            l < i && (i = l), r < l && (r = l), c < n && (n = c), o < c && (o = c);
        }
        return new In(i, n, r - i, o - n);
    }, In.fromRectUnion = function() {
        for(var t = [], e = arguments.length; e--;)t[e] = arguments[e];
        if (0 === t.length) return null;
        var i, n, r, o, a = new In;
        i = n = 1 / 0, r = o = -1 / 0;
        for(var s = 0; s < t.length; s++){
            a.update(t[s]);
            var l = a.x, c = a.y, u = l + a.width, h = c + a.height;
            l < i && (i = l), r < u && (r = u), c < n && (n = c), o < h && (o = h);
        }
        return new In(i, n, r - i, o - n);
    }, In.prototype = {
        type: Yi.Rect,
        bbox: function(t) {
            return this.clone().rotateAroundCenter(t);
        },
        rotateAroundCenter: function(t) {
            if (!t) return this;
            var e = this.width, i = this.height, n = Pi(t), r = un(gn(n)), o = un(hn(n)), a = e * o + i * r, s = e * r + i * o;
            return this.x += (e - a) / 2, this.y += (i - s) / 2, this.width = a, this.height = s, this;
        },
        bottomLeft: function() {
            return new qi(this.x, this.y + this.height);
        },
        bottomLine: function() {
            return new nn(this.bottomLeft(), this.bottomRight());
        },
        bottomMiddle: function() {
            return new qi(this.x + this.width / 2, this.y + this.height);
        },
        center: function() {
            return new qi(this.x + this.width / 2, this.y + this.height / 2);
        },
        clone: function() {
            return new In(this);
        },
        containsPoint: function(t) {
            return (t = new qi(t)).x >= this.x && t.x <= this.x + this.width && t.y >= this.y && t.y <= this.y + this.height;
        },
        containsRect: function(t) {
            var e = new In(this).normalize(), i = new In(t).normalize(), n = e.width, r = e.height, o = i.width, a = i.height;
            if (!(n && r && o && a)) return !1;
            var s = e.x, l = e.y, c = i.x, u = i.y;
            return o += c, n += s, a += u, r += l, s <= c && o <= n && l <= u && a <= r;
        },
        corner: function() {
            return new qi(this.x + this.width, this.y + this.height);
        },
        equals: function(t) {
            var e = new In(this).normalize(), i = new In(t).normalize();
            return e.x === i.x && e.y === i.y && e.width === i.width && e.height === i.height;
        },
        inflate: function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this;
        },
        intersect: function(t) {
            var e = this.origin(), i = this.corner(), n = t.origin(), r = t.corner();
            if (r.x <= e.x || r.y <= e.y || n.x >= i.x || n.y >= i.y) return null;
            var o = fn(e.x, n.x), a = fn(e.y, n.y);
            return new In(o, a, dn(i.x, r.x) - o, dn(i.y, r.y) - a);
        },
        intersectionWithLine: function(t) {
            var e, i, n = [
                this.topLine(),
                this.rightLine(),
                this.bottomLine(),
                this.leftLine()
            ], r = [], o = [], a = n.length;
            for(i = 0; i < a; i++)null !== (e = t.intersect(n[i])) && o.indexOf(e.toString()) < 0 && (r.push(e), o.push(e.toString()));
            return 0 < r.length ? r : null;
        },
        intersectionWithLineFromCenterToPoint: function(t, e) {
            t = new qi(t);
            var i, n = new qi(this.x + this.width / 2, this.y + this.height / 2);
            e && t.rotate(n, e);
            for(var r = [
                this.topLine(),
                this.rightLine(),
                this.bottomLine(),
                this.leftLine()
            ], o = new nn(n, t), a = r.length - 1; 0 <= a; --a){
                var s = r[a].intersection(o);
                if (null !== s) {
                    i = s;
                    break;
                }
            }
            return i && e && i.rotate(n, -e), i;
        },
        leftLine: function() {
            return new nn(this.topLeft(), this.bottomLeft());
        },
        leftMiddle: function() {
            return new qi(this.x, this.y + this.height / 2);
        },
        maxRectScaleToFit: function(t, e) {
            var i, n, r, o, a, s, l, c;
            t = new In(t), e || (e = t.center());
            var u = e.x, h = e.y;
            i = n = r = o = a = s = l = c = 1 / 0;
            var g = t.topLeft();
            g.x < u && (i = (this.x - u) / (g.x - u)), g.y < h && (a = (this.y - h) / (g.y - h));
            var d = t.bottomRight();
            d.x > u && (n = (this.x + this.width - u) / (d.x - u)), d.y > h && (s = (this.y + this.height - h) / (d.y - h));
            var f = t.topRight();
            f.x > u && (r = (this.x + this.width - u) / (f.x - u)), f.y < h && (l = (this.y - h) / (f.y - h));
            var p = t.bottomLeft();
            return p.x < u && (o = (this.x - u) / (p.x - u)), p.y > h && (c = (this.y + this.height - h) / (p.y - h)), {
                sx: dn(i, n, r, o),
                sy: dn(a, s, l, c)
            };
        },
        maxRectUniformScaleToFit: function(t, e) {
            var i = this.maxRectScaleToFit(t, e);
            return dn(i.sx, i.sy);
        },
        moveAndExpand: function(t) {
            return this.x += t.x || 0, this.y += t.y || 0, this.width += t.width || 0, this.height += t.height || 0, this;
        },
        normalize: function() {
            var t = this.x, e = this.y, i = this.width, n = this.height;
            return this.width < 0 && (t = this.x + this.width, i = -this.width), this.height < 0 && (e = this.y + this.height, n = -this.height), this.x = t, this.y = e, this.width = i, this.height = n, this;
        },
        offset: function(t, e) {
            return qi.prototype.offset.call(this, t, e);
        },
        origin: function() {
            return new qi(this.x, this.y);
        },
        pointNearestToPoint: function(t) {
            if (t = new qi(t), this.containsPoint(t)) switch(this.sideNearestToPoint(t)){
                case "right":
                    return new qi(this.x + this.width, t.y);
                case "left":
                    return new qi(this.x, t.y);
                case "bottom":
                    return new qi(t.x, this.y + this.height);
                case "top":
                    return new qi(t.x, this.y);
            }
            return t.adhereToRect(this);
        },
        rightLine: function() {
            return new nn(this.topRight(), this.bottomRight());
        },
        rightMiddle: function() {
            return new qi(this.x + this.width, this.y + this.height / 2);
        },
        round: function(t) {
            var e = 1;
            if (t) switch(t){
                case 1:
                    e = 10;
                    break;
                case 2:
                    e = 100;
                    break;
                case 3:
                    e = 1e3;
                    break;
                default:
                    e = mn(10, t);
            }
            return this.x = pn(this.x * e) / e, this.y = pn(this.y * e) / e, this.width = pn(this.width * e) / e, this.height = pn(this.height * e) / e, this;
        },
        scale: function(t, e, i) {
            return i = this.origin().scale(t, e, i), this.x = i.x, this.y = i.y, this.width *= t, this.height *= e, this;
        },
        sideNearestToPoint: function(t) {
            var e = (t = new qi(t)).x - this.x, i = this.x + this.width - t.x, n = t.y - this.y, r = e, o = "left";
            return i < r && (r = i, o = "right"), n < r && (r = n, o = "top"), this.y + this.height - t.y < r && (o = "bottom"), o;
        },
        snapToGrid: function(t, e) {
            var i = this.origin().snapToGrid(t, e), n = this.corner().snapToGrid(t, e);
            return this.x = i.x, this.y = i.y, this.width = n.x - i.x, this.height = n.y - i.y, this;
        },
        toJSON: function() {
            return {
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height
            };
        },
        topLine: function() {
            return new nn(this.topLeft(), this.topRight());
        },
        topMiddle: function() {
            return new qi(this.x + this.width / 2, this.y);
        },
        topRight: function() {
            return new qi(this.x + this.width, this.y);
        },
        toString: function() {
            return this.origin().toString() + " " + this.corner().toString();
        },
        union: function(t) {
            return In.fromRectUnion(this, t);
        },
        update: function(t, e, i, n) {
            return Object(t) === t && (e = t.y, i = t.width, n = t.height, t = t.x), this.x = t || 0, this.y = e || 0, this.width = i || 0, this.height = n || 0, this;
        }
    }, In.prototype.bottomRight = In.prototype.corner, In.prototype.topLeft = In.prototype.origin, In.prototype.translate = In.prototype.offset;
    var vn = In;
    function An(t) {
        if ("" === (t = t.trim())) return [];
        for(var e = [], i = t.split(/\s*,\s*|\s+/), n = i.length, r = 0; r < n; r += 2)e.push({
            x: +i[r],
            y: +i[r + 1]
        });
        return e;
    }
    function Cn(t) {
        var e = t.length;
        if (0 === e) return [];
        for(var i = [], n = 0; n < e; n++){
            var r = t[n].clone();
            i.push(r);
        }
        return i;
    }
    function yn(t) {
        var e, i, n, r = Math.abs, o = t.length;
        if (0 === o) return [];
        for(e = 0; e < o; e++)void 0 === n ? n = t[e] : t[e].y < n.y ? n = t[e] : t[e].y === n.y && t[e].x > n.x && (n = t[e]);
        var a = [];
        for(e = 0; e < o; e++){
            var s = n.theta(t[e]);
            0 === s && (s = 360);
            var l = [
                t[e],
                e,
                s
            ];
            a.push(l);
        }
        if (a.sort(function(t, e) {
            var i = t[2] - e[2];
            return 0 === i && (i = e[1] - t[1]), i;
        }), 2 < a.length) {
            var c = a[a.length - 1];
            a.unshift(c);
        }
        for(var u, h, g, d, f, p, m, I = {}, v = []; 0 !== a.length;)if (h = (u = a.pop())[0], !I.hasOwnProperty(u[0] + "@@" + u[1])) for(var A = !1; !A;)if (v.length < 2) v.push(u), A = !0;
        else {
            d = (g = v.pop())[0];
            var C = (p = (f = v.pop())[0]).cross(d, h);
            if (C < 0) v.push(f), v.push(g), v.push(u), A = !0;
            else if (0 === C) {
                var y = d.angleBetween(p, h);
                r(y - 180) < 1e-10 ? (I[g[0] + "@@" + g[1]] = d, v.push(f)) : d.equals(h) || p.equals(d) ? (I[g[0] + "@@" + g[1]] = d, v.push(f)) : r((y + 1) % 360 - 1) < 1e-10 && (v.push(f), a.push(g));
            } else I[g[0] + "@@" + g[1]] = d, v.push(f);
        }
        2 < v.length && v.pop();
        var w = -1;
        for(i = v.length, e = 0; e < i; e++){
            var b = v[e][1];
            (void 0 === m || b < m) && (m = b, w = e);
        }
        var N = [];
        if (0 < w) {
            var x = v.slice(w), M = v.slice(0, w);
            N = x.concat(M);
        } else N = v;
        var S = [];
        for(i = N.length, e = 0; e < i; e++)S.push(N[e][0]);
        return S;
    }
    var wn = function(t) {
        return this instanceof wn ? "string" == typeof t ? new wn.parse(t) : void (this.points = Array.isArray(t) ? t.map(qi) : []) : new wn(t);
    };
    wn.parse = function(t) {
        return new wn(An(t));
    }, wn.fromRect = function(t) {
        return new wn([
            t.topLeft(),
            t.topRight(),
            t.bottomRight(),
            t.bottomLeft(),
            t.topLeft()
        ]);
    }, wn.prototype = {
        type: Yi.Polyline,
        bbox: function() {
            var t = 1 / 0, e = -1 / 0, i = 1 / 0, n = -1 / 0, r = this.points, o = r.length;
            if (0 === o) return null;
            for(var a = 0; a < o; a++){
                var s = r[a], l = s.x, c = s.y;
                l < t && (t = l), e < l && (e = l), c < i && (i = c), n < c && (n = c);
            }
            return new In(t, i, e - t, n - i);
        },
        clone: function() {
            return new wn(Cn(this.points));
        },
        closestPoint: function(t) {
            var e = this.closestPointLength(t);
            return this.pointAtLength(e);
        },
        closestPointLength: function(t) {
            var e, i = this.lengthPoints(), n = i.length;
            if (0 === n) return 0;
            if (1 === n) return 0;
            for(var r = 1 / 0, o = 0, a = n - 1, s = 0; s < a; s++){
                var l = new nn(i[s], i[s + 1]), c = l.length(), u = l.closestPointNormalizedLength(t), h = l.pointAt(u).squaredDistance(t);
                h < r && (r = h, e = o + u * c), o += c;
            }
            return e;
        },
        closestPointNormalizedLength: function(t) {
            var e = this.closestPointLength(t);
            if (0 === e) return 0;
            var i = this.length();
            return 0 === i ? 0 : e / i;
        },
        closestPointTangent: function(t) {
            var e = this.closestPointLength(t);
            return this.tangentAtLength(e);
        },
        containsPoint: function(t) {
            var e = this.points, i = e.length;
            if (0 === i) return !1;
            for(var n = t.x, r = t.y, o = i - 1, a = 0, s = 0, l = new nn, c = new nn, u = new qi; a < i; a++){
                var h = e[o], g = e[a];
                if (t.equals(h)) return !0;
                if (l.start = h, l.end = g, l.containsPoint(t)) return !0;
                if (r <= h.y && r > g.y || r > h.y && r <= g.y) {
                    var d = h.x - n > g.x - n ? h.x - n : g.x - n;
                    0 <= d && (u.x = n + d, u.y = r, c.start = t, c.end = u, l.intersect(c) && s++);
                }
                o = a;
            }
            return s % 2 == 1;
        },
        close: function() {
            var t = this.start, e = this.end, i = this.points;
            return t && e && !t.equals(e) && i.push(t.clone()), this;
        },
        lengthPoints: function() {
            return this.points;
        },
        convexHull: function() {
            return new wn(yn(this.points));
        },
        equals: function(t) {
            if (!t) return !1;
            var e = this.points, i = t.points, n = e.length;
            if (i.length !== n) return !1;
            for(var r = 0; r < n; r++){
                var o = e[r], a = t.points[r];
                if (!o.equals(a)) return !1;
            }
            return !0;
        },
        intersectionWithLine: function(t) {
            for(var e = new nn(t), i = [], n = this.lengthPoints(), r = new nn, o = 0, a = n.length - 1; o < a; o++){
                r.start = n[o], r.end = n[o + 1];
                var s = e.intersectionWithLine(r);
                s && i.push(s[0]);
            }
            return 0 < i.length ? i : null;
        },
        isDifferentiable: function() {
            var t = this.points, e = t.length;
            if (0 === e) return !1;
            for(var i = new nn, n = e - 1, r = 0; r < n; r++)if (i.start = t[r], i.end = t[r + 1], i.isDifferentiable()) return !0;
            return !1;
        },
        length: function() {
            var t = this.lengthPoints(), e = t.length;
            if (0 === e) return 0;
            for(var i = 0, n = e - 1, r = 0; r < n; r++)i += t[r].distance(t[r + 1]);
            return i;
        },
        pointAt: function(t) {
            var e = this.lengthPoints(), i = e.length;
            if (0 === i) return null;
            if (1 === i) return e[0].clone();
            if (t <= 0) return e[0].clone();
            if (1 <= t) return e[i - 1].clone();
            var n = this.length() * t;
            return this.pointAtLength(n);
        },
        pointAtLength: function(t) {
            var e = this.lengthPoints(), i = e.length;
            if (0 === i) return null;
            if (1 === i) return e[0].clone();
            var n = !0;
            t < 0 && (n = !1, t = -t);
            for(var r = 0, o = i - 1, a = 0; a < o; a++){
                var s = n ? a : o - 1 - a, l = e[s], c = e[s + 1], u = new nn(l, c), h = l.distance(c);
                if (t <= r + h) return u.pointAtLength((n ? 1 : -1) * (t - r));
                r += h;
            }
            return (n ? e[i - 1] : e[0]).clone();
        },
        round: function(t) {
            for(var e = this.points, i = e.length, n = 0; n < i; n++)e[n].round(t);
            return this;
        },
        scale: function(t, e, i) {
            for(var n = this.points, r = n.length, o = 0; o < r; o++)n[o].scale(t, e, i);
            return this;
        },
        simplify: function(t) {
            void 0 === t && (t = {});
            var e = this.points;
            if (e.length < 3) return this;
            for(var i = t.threshold || 0, n = 0; e[n + 2];){
                var r = n + 1, o = n + 2, a = e[n], s = e[r], l = e[o];
                new nn(a, l).closestPoint(s).distance(s) <= i ? e.splice(r, 1) : n += 1;
            }
            return this;
        },
        tangentAt: function(t) {
            var e = this.lengthPoints().length;
            if (0 === e) return null;
            if (1 === e) return null;
            t < 0 && (t = 0), 1 < t && (t = 1);
            var i = this.length() * t;
            return this.tangentAtLength(i);
        },
        tangentAtLength: function(t) {
            var e = this.lengthPoints(), i = e.length;
            if (0 === i) return null;
            if (1 === i) return null;
            var n, r = !0;
            t < 0 && (r = !1, t = -t);
            for(var o = 0, a = i - 1, s = 0; s < a; s++){
                var l = r ? s : a - 1 - s, c = e[l], u = e[l + 1], h = new nn(c, u), g = c.distance(u);
                if (h.isDifferentiable()) {
                    if (t <= o + g) return h.tangentAtLength((r ? 1 : -1) * (t - o));
                    n = h;
                }
                o += g;
            }
            if (n) {
                var d = r ? 1 : 0;
                return n.tangentAt(d);
            }
            return null;
        },
        toString: function() {
            return this.points + "";
        },
        translate: function(t, e) {
            for(var i = this.points, n = i.length, r = 0; r < n; r++)i[r].translate(t, e);
            return this;
        },
        serialize: function() {
            var t = this.points, e = t.length;
            if (0 === e) return "";
            for(var i = "", n = 0; n < e; n++){
                var r = t[n];
                i += r.x + "," + r.y + " ";
            }
            return i.trim();
        }
    }, Object.defineProperty(wn.prototype, "start", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            return 0 === this.points.length ? null : this.points[0];
        }
    }), Object.defineProperty(wn.prototype, "end", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            var t = this.points.length;
            return 0 === t ? null : this.points[t - 1];
        }
    });
    var bn = Math.abs, Nn = Math.sqrt, xn = Math.min, Mn = Math.max, Sn = Math.pow, kn = function(t, e, i, n) {
        return this instanceof kn ? t instanceof kn ? new kn(t.start, t.controlPoint1, t.controlPoint2, t.end) : (this.start = new qi(t), this.controlPoint1 = new qi(e), this.controlPoint2 = new qi(i), void (this.end = new qi(n))) : new kn(t, e, i, n);
    };
    function Dn(t) {
        var e, i, n = arguments, r = [];
        for(i = arguments.length, e = 1; e < i; e++)r.push(n[e]);
        if (!t) throw new Error("Missing a parent object.");
        var o = Object.create(t);
        for(i = r.length, e = 0; e < i; e++){
            var a, s, l = r[e];
            for(s in l)l.hasOwnProperty(s) && (delete o[s], a = Object.getOwnPropertyDescriptor(l, s), Object.defineProperty(o, s, a));
        }
        return o;
    }
    kn.throughPoints = function() {
        function l(t) {
            var e = t.length, i = [], n = [], r = 2;
            i[0] = t[0] / r;
            for(var o = 1; o < e; o++)n[o] = 1 / r, r = (o < e - 1 ? 4 : 3.5) - n[o], i[o] = (t[o] - i[o - 1]) / r;
            for(o = 1; o < e; o++)i[e - o - 1] -= n[e - o] * i[e - o];
            return i;
        }
        return function(t) {
            if (!t || Array.isArray(t) && t.length < 2) throw new Error("At least 2 points are required");
            for(var e = function(t) {
                var e, i = [], n = [], r = t.length - 1;
                if (1 == r) return i[0] = new qi((2 * t[0].x + t[1].x) / 3, (2 * t[0].y + t[1].y) / 3), n[0] = new qi(2 * i[0].x - t[0].x, 2 * i[0].y - t[0].y), [
                    i,
                    n
                ];
                var o = [];
                for(e = 1; e < r - 1; e++)o[e] = 4 * t[e].x + 2 * t[e + 1].x;
                o[0] = t[0].x + 2 * t[1].x, o[r - 1] = (8 * t[r - 1].x + t[r].x) / 2;
                var a = l(o);
                for(e = 1; e < r - 1; ++e)o[e] = 4 * t[e].y + 2 * t[e + 1].y;
                o[0] = t[0].y + 2 * t[1].y, o[r - 1] = (8 * t[r - 1].y + t[r].y) / 2;
                var s = l(o);
                for(e = 0; e < r; e++)i.push(new qi(a[e], s[e])), e < r - 1 ? n.push(new qi(2 * t[e + 1].x - a[e + 1], 2 * t[e + 1].y - s[e + 1])) : n.push(new qi((t[r].x + a[r - 1]) / 2, (t[r].y + s[r - 1]) / 2));
                return [
                    i,
                    n
                ];
            }(t), i = [], n = e[0].length, r = 0; r < n; r++){
                var o = new qi(e[0][r].x, e[0][r].y), a = new qi(e[1][r].x, e[1][r].y);
                i.push(new kn(t[r], o, a, t[r + 1]));
            }
            return i;
        };
    }(), kn.prototype = {
        type: Yi.Curve,
        bbox: function() {
            for(var t, e, i, n, r, o, a, s, l = this.start, c = this.controlPoint1, u = this.controlPoint2, h = this.end, g = l.x, d = l.y, f = c.x, p = c.y, m = u.x, I = u.y, v = h.x, A = h.y, C = new Array, y = new Array, w = [
                new Array,
                new Array
            ], b = 0; b < 2; ++b)if (i = 0 === b ? (e = 6 * g - 12 * f + 6 * m, t = -3 * g + 9 * f - 9 * m + 3 * v, 3 * f - 3 * g) : (e = 6 * d - 12 * p + 6 * I, t = -3 * d + 9 * p - 9 * I + 3 * A, 3 * p - 3 * d), bn(t) < 1e-12) {
                if (bn(e) < 1e-12) continue;
                0 < (n = -i / e) && n < 1 && y.push(n);
            } else s = Nn(a = e * e - 4 * i * t), a < 0 || (0 < (r = (-e + s) / (2 * t)) && r < 1 && y.push(r), 0 < (o = (-e - s) / (2 * t)) && o < 1 && y.push(o));
            for(var N, x, M, S = y.length, k = S; S--;)x = (N = 1 - (n = y[S])) * N * N * g + 3 * N * N * n * f + 3 * N * n * n * m + n * n * n * v, w[0][S] = x, M = N * N * N * d + 3 * N * N * n * p + 3 * N * n * n * I + n * n * n * A, w[1][S] = M, C[S] = {
                X: x,
                Y: M
            };
            y[k] = 0, y[k + 1] = 1, C[k] = {
                X: g,
                Y: d
            }, C[k + 1] = {
                X: v,
                Y: A
            }, w[0][k] = g, w[1][k] = d, w[0][k + 1] = v, w[1][k + 1] = A, y.length = k + 2, w[0].length = k + 2, w[1].length = k + 2, C.length = k + 2;
            var D = xn.apply(null, w[0]), T = xn.apply(null, w[1]), L = Mn.apply(null, w[0]), z = Mn.apply(null, w[1]);
            return new In(D, T, L - D, z - T);
        },
        clone: function() {
            return new kn(this.start, this.controlPoint1, this.controlPoint2, this.end);
        },
        closestPoint: function(t, e) {
            return this.pointAtT(this.closestPointT(t, e));
        },
        closestPointLength: function(t, e) {
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                subdivisions: void 0 === e.subdivisions ? this.getSubdivisions({
                    precision: i
                }) : e.subdivisions
            };
            return this.lengthAtT(this.closestPointT(t, n), n);
        },
        closestPointNormalizedLength: function(t, e) {
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                subdivisions: void 0 === e.subdivisions ? this.getSubdivisions({
                    precision: i
                }) : e.subdivisions
            }, r = this.closestPointLength(t, n);
            if (!r) return 0;
            var o = this.length(n);
            return 0 === o ? 0 : r / o;
        },
        closestPointT: function(t, e) {
            for(var i, n, r, o, a, s, l, c = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, u = void 0 === e.subdivisions ? this.getSubdivisions({
                precision: c
            }) : e.subdivisions, h = u.length, g = h ? 1 / h : 0, d = 0; d < h; d++){
                var f = u[d], p = f.start.distance(t), m = f.end.distance(t), I = p + m;
                (!l || I < l) && (n = d * g, r = (d + 1) * g, o = p, a = m, s = (i = f).start.distance(f.end), l = I);
            }
            for(var v = Sn(10, -c);;){
                var A = o ? bn(o - a) / o : 0, C = a ? bn(o - a) / a : 0;
                if (A < v || C < v || !o || o < s * v || !a || a < s * v) return o <= a ? n : r;
                var y = i.divide(.5);
                g /= 2;
                var w = y[0].start.distance(t), b = y[0].end.distance(t), N = w + b, x = y[1].start.distance(t), M = y[1].end.distance(t);
                a = N <= x + M ? (i = y[0], r -= g, o = w, b) : (i = y[1], n += g, o = x, M);
            }
        },
        closestPointTangent: function(t, e) {
            return this.tangentAtT(this.closestPointT(t, e));
        },
        containsPoint: function(t, e) {
            return this.toPolyline(e).containsPoint(t);
        },
        divideAt: function(t, e) {
            if (t <= 0) return this.divideAtT(0);
            if (1 <= t) return this.divideAtT(1);
            var i = this.tAt(t, e);
            return this.divideAtT(i);
        },
        divideAtLength: function(t, e) {
            var i = this.tAtLength(t, e);
            return this.divideAtT(i);
        },
        divideAtT: function(t) {
            var e = this.start, i = this.controlPoint1, n = this.controlPoint2, r = this.end;
            if (t <= 0) return [
                new kn(e, e, e, e),
                new kn(e, i, n, r)
            ];
            if (1 <= t) return [
                new kn(e, i, n, r),
                new kn(r, r, r, r)
            ];
            var o = this.getSkeletonPoints(t), a = o.startControlPoint1, s = o.startControlPoint2, l = o.divider, c = o.dividerControlPoint1, u = o.dividerControlPoint2;
            return [
                new kn(e, a, s, l),
                new kn(l, c, u, r)
            ];
        },
        endpointDistance: function() {
            return this.start.distance(this.end);
        },
        equals: function(t) {
            return !!t && this.start.x === t.start.x && this.start.y === t.start.y && this.controlPoint1.x === t.controlPoint1.x && this.controlPoint1.y === t.controlPoint1.y && this.controlPoint2.x === t.controlPoint2.x && this.controlPoint2.y === t.controlPoint2.y && this.end.x === t.end.x && this.end.y === t.end.y;
        },
        getSkeletonPoints: function(t) {
            var e = this.start, i = this.controlPoint1, n = this.controlPoint2, r = this.end;
            if (t <= 0) return {
                startControlPoint1: e.clone(),
                startControlPoint2: e.clone(),
                divider: e.clone(),
                dividerControlPoint1: i.clone(),
                dividerControlPoint2: n.clone()
            };
            if (1 <= t) return {
                startControlPoint1: i.clone(),
                startControlPoint2: n.clone(),
                divider: r.clone(),
                dividerControlPoint1: r.clone(),
                dividerControlPoint2: r.clone()
            };
            var o = new nn(e, i).pointAt(t), a = new nn(i, n).pointAt(t), s = new nn(n, r).pointAt(t), l = new nn(o, a).pointAt(t), c = new nn(a, s).pointAt(t);
            return {
                startControlPoint1: o,
                startControlPoint2: l,
                divider: new nn(l, c).pointAt(t),
                dividerControlPoint1: c,
                dividerControlPoint2: s
            };
        },
        getSubdivisions: function(t) {
            var e = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, i = [
                new kn(this.start, this.controlPoint1, this.controlPoint2, this.end)
            ];
            if (0 === e) return i;
            for(var n = this.endpointDistance(), r = Sn(10, -e), o = 0;;){
                o += 1;
                for(var a = [], s = i.length, l = 0; l < s; l++){
                    var c = i[l].divide(.5);
                    a.push(c[0], c[1]);
                }
                for(var u = 0, h = a.length, g = 0; g < h; g++)u += a[g].endpointDistance();
                if (1 < o && (0 !== u ? (u - n) / u : 0) < r) return a;
                i = a, n = u;
            }
        },
        isDifferentiable: function() {
            var t = this.start, e = this.controlPoint1, i = this.controlPoint2, n = this.end;
            return !(t.equals(e) && e.equals(i) && i.equals(n));
        },
        length: function(t) {
            for(var e = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, i = void 0 === t.subdivisions ? this.getSubdivisions({
                precision: e
            }) : t.subdivisions, n = 0, r = i.length, o = 0; o < r; o++)n += i[o].endpointDistance();
            return n;
        },
        lengthAtT: function(t, e) {
            if (t <= 0) return 0;
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision;
            return this.divide(t)[0].length({
                precision: i
            });
        },
        pointAt: function(t, e) {
            if (t <= 0) return this.start.clone();
            if (1 <= t) return this.end.clone();
            var i = this.tAt(t, e);
            return this.pointAtT(i);
        },
        pointAtLength: function(t, e) {
            var i = this.tAtLength(t, e);
            return this.pointAtT(i);
        },
        pointAtT: function(t) {
            return t <= 0 ? this.start.clone() : 1 <= t ? this.end.clone() : this.getSkeletonPoints(t).divider;
        },
        PRECISION: 3,
        round: function(t) {
            return this.start.round(t), this.controlPoint1.round(t), this.controlPoint2.round(t), this.end.round(t), this;
        },
        scale: function(t, e, i) {
            return this.start.scale(t, e, i), this.controlPoint1.scale(t, e, i), this.controlPoint2.scale(t, e, i), this.end.scale(t, e, i), this;
        },
        tangentAt: function(t, e) {
            if (!this.isDifferentiable()) return null;
            t < 0 ? t = 0 : 1 < t && (t = 1);
            var i = this.tAt(t, e);
            return this.tangentAtT(i);
        },
        tangentAtLength: function(t, e) {
            if (!this.isDifferentiable()) return null;
            var i = this.tAtLength(t, e);
            return this.tangentAtT(i);
        },
        tangentAtT: function(t) {
            if (!this.isDifferentiable()) return null;
            t < 0 ? t = 0 : 1 < t && (t = 1);
            var e = this.getSkeletonPoints(t), i = e.startControlPoint2, n = e.dividerControlPoint1, r = e.divider, o = new nn(i, n);
            return o.translate(r.x - i.x, r.y - i.y), o;
        },
        tAt: function(t, e) {
            if (t <= 0) return 0;
            if (1 <= t) return 1;
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                subdivisions: void 0 === e.subdivisions ? this.getSubdivisions({
                    precision: i
                }) : e.subdivisions
            }, r = this.length(n) * t;
            return this.tAtLength(r, n);
        },
        tAtLength: function(t, e) {
            var i = !0;
            t < 0 && (i = !1, t = -t);
            for(var n, r, o, a, s, l = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, c = void 0 === e.subdivisions ? this.getSubdivisions({
                precision: l
            }) : e.subdivisions, u = {
                precision: l,
                subdivisions: c
            }, h = 0, g = c.length, d = 1 / g, f = 0; f < g; f++){
                var p = i ? f : g - 1 - f, m = c[f], I = m.endpointDistance();
                if (t <= h + I) {
                    n = m, r = p * d, o = (p + 1) * d, a = i ? t - h : I + h - t, s = i ? I + h - t : t - h;
                    break;
                }
                h += I;
            }
            if (!n) return i ? 1 : 0;
            for(var v = this.length(u), A = Sn(10, -l);;){
                var C, y;
                if ((0 !== v ? a / v : 0) < A) return r;
                if ((0 !== v ? s / v : 0) < A) return o;
                var w = n.divide(.5);
                d /= 2;
                var b = w[0].endpointDistance(), N = w[1].endpointDistance();
                y = a <= b ? (n = w[0], o -= d, b - (C = a)) : (n = w[1], r += d, N - (C = a - b)), a = C, s = y;
            }
        },
        toPoints: function(t) {
            for(var e = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, i = void 0 === t.subdivisions ? this.getSubdivisions({
                precision: e
            }) : t.subdivisions, n = [
                i[0].start.clone()
            ], r = i.length, o = 0; o < r; o++){
                var a = i[o];
                n.push(a.end.clone());
            }
            return n;
        },
        toPolyline: function(t) {
            return new wn(this.toPoints(t));
        },
        toString: function() {
            return this.start + " " + this.controlPoint1 + " " + this.controlPoint2 + " " + this.end;
        },
        translate: function(t, e) {
            return this.start.translate(t, e), this.controlPoint1.translate(t, e), this.controlPoint2.translate(t, e), this.end.translate(t, e), this;
        }
    }, kn.prototype.divide = kn.prototype.divideAtT;
    var Tn = function(t) {
        if (!(this instanceof Tn)) return new Tn(t);
        if ("string" == typeof t) return new Tn.parse(t);
        var e, i;
        if (this.segments = [], t) {
            if (Array.isArray(t) && 0 !== t.length) {
                if (i = (t = t.reduce(function(t, e) {
                    return t.concat(e);
                }, [])).length, t[0].isSegment) for(e = 0; e < i; e++){
                    var n = t[e];
                    this.appendSegment(n);
                }
                else {
                    var r = null;
                    for(e = 0; e < i; e++){
                        var o = t[e];
                        if (!(o instanceof nn || o instanceof kn)) throw new Error("Cannot construct a path segment from the provided object.");
                        0 === e && this.appendSegment(Tn.createSegment("M", o.start)), r && !r.end.equals(o.start) && this.appendSegment(Tn.createSegment("M", o.start)), o instanceof nn ? this.appendSegment(Tn.createSegment("L", o.end)) : o instanceof kn && this.appendSegment(Tn.createSegment("C", o.controlPoint1, o.controlPoint2, o.end)), r = o;
                    }
                }
            } else if (t.isSegment) this.appendSegment(t);
            else if (t instanceof nn) this.appendSegment(Tn.createSegment("M", t.start)), this.appendSegment(Tn.createSegment("L", t.end));
            else if (t instanceof kn) this.appendSegment(Tn.createSegment("M", t.start)), this.appendSegment(Tn.createSegment("C", t.controlPoint1, t.controlPoint2, t.end));
            else {
                if (!(t instanceof wn)) throw new Error("Cannot construct a path from the provided object.");
                if (!t.points || 0 === t.points.length) return;
                for(i = t.points.length, e = 0; e < i; e++){
                    var a = t.points[e];
                    0 === e ? this.appendSegment(Tn.createSegment("M", a)) : this.appendSegment(Tn.createSegment("L", a));
                }
            }
        } else ;
    };
    function Ln(t, e) {
        return e.unshift(null), new (Function.prototype.bind.apply(t, e));
    }
    Tn.parse = function(t) {
        if (!t) return new Tn;
        for(var e = new Tn, i = t.match(/(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g), n = i.length, r = 0; r < n; r++){
            var o = i[r].match(/(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g), a = Tn.createSegment.apply(this, o);
            e.appendSegment(a);
        }
        return e;
    }, Tn.createSegment = function(t) {
        var e = arguments;
        if (!t) throw new Error("Type must be provided.");
        var i = Tn.segmentTypes[t];
        if (!i) throw new Error(t + " is not a recognized path segment type.");
        for(var n = [], r = arguments.length, o = 1; o < r; o++)n.push(e[o]);
        return Ln(i, n);
    }, Tn.prototype = {
        type: Yi.Path,
        appendSegment: function(t) {
            var e, i = this.segments, n = i.length, r = 0 !== n ? i[n - 1] : null;
            if (Array.isArray(t)) {
                if (!(t = t.reduce(function(t, e) {
                    return t.concat(e);
                }, []))[0].isSegment) throw new Error("Segments required.");
                for(var o = t.length, a = 0; a < o; a++){
                    var s = t[a];
                    e = this.prepareSegment(s, r, null), i.push(e), r = e;
                }
            } else {
                if (!t || !t.isSegment) throw new Error("Segment required.");
                e = this.prepareSegment(t, r, null), i.push(e);
            }
        },
        bbox: function() {
            var t, e = this.segments, i = e.length;
            if (0 === i) return null;
            for(var n = 0; n < i; n++){
                var r = e[n];
                if (r.isVisible) {
                    var o = r.bbox();
                    t = t ? t.union(o) : o;
                }
            }
            if (t) return t;
            var a = e[i - 1];
            return new In(a.end.x, a.end.y, 0, 0);
        },
        clone: function() {
            for(var t = this.segments, e = t.length, i = new Tn, n = 0; n < e; n++){
                var r = t[n].clone();
                i.appendSegment(r);
            }
            return i;
        },
        closestPoint: function(t, e) {
            var i = this.closestPointT(t, e);
            return i ? this.pointAtT(i) : null;
        },
        closestPointLength: function(t, e) {
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                segmentSubdivisions: void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                    precision: i
                }) : e.segmentSubdivisions
            }, r = this.closestPointT(t, n);
            return r ? this.lengthAtT(r, n) : 0;
        },
        closestPointNormalizedLength: function(t, e) {
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                segmentSubdivisions: void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                    precision: i
                }) : e.segmentSubdivisions
            }, r = this.closestPointLength(t, n);
            if (0 === r) return 0;
            var o = this.length(n);
            return 0 === o ? 0 : r / o;
        },
        closestPointT: function(t, e) {
            var i = this.segments, n = i.length;
            if (0 === n) return null;
            for(var r, o = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, a = void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: o
            }) : e.segmentSubdivisions, s = 1 / 0, l = 0; l < n; l++){
                var c = i[l], u = a[l];
                if (c.isVisible) {
                    var h = c.closestPointT(t, {
                        precision: o,
                        subdivisions: u
                    }), g = c.pointAtT(h), d = new nn(g, t).squaredLength();
                    d < s && (r = {
                        segmentIndex: l,
                        value: h
                    }, s = d);
                }
            }
            return r || {
                segmentIndex: n - 1,
                value: 1
            };
        },
        closestPointTangent: function(t, e) {
            var i = this.segments, n = i.length;
            if (0 === n) return null;
            for(var r, o = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, a = void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: o
            }) : e.segmentSubdivisions, s = 1 / 0, l = 0; l < n; l++){
                var c = i[l], u = a[l];
                if (c.isDifferentiable()) {
                    var h = c.closestPointT(t, {
                        precision: o,
                        subdivisions: u
                    }), g = c.pointAtT(h), d = new nn(g, t).squaredLength();
                    d < s && (r = c.tangentAtT(h), s = d);
                }
            }
            return r || null;
        },
        containsPoint: function(t, e) {
            var i = this.toPolylines(e);
            if (!i) return !1;
            for(var n = i.length, r = 0, o = 0; o < n; o++)i[o].containsPoint(t) && r++;
            return r % 2 == 1;
        },
        divideAt: function(t, e) {
            if (0 === this.segments.length) return null;
            t < 0 && (t = 0), 1 < t && (t = 1);
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                segmentSubdivisions: void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                    precision: i
                }) : e.segmentSubdivisions
            }, r = this.length(n) * t;
            return this.divideAtLength(r, n);
        },
        divideAtLength: function(t, e) {
            var i = this.segments.length;
            if (0 === i) return null;
            var n = !0;
            t < 0 && (n = !1, t = -t);
            var r, o, a, s, l, c, u, h = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, g = void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: h
            }) : e.segmentSubdivisions, d = 0;
            for(r = 0; r < i; r++){
                var f = n ? r : i - 1 - r;
                o = this.getSegment(f);
                var p = g[f], m = o.length({
                    precision: h,
                    subdivisions: p
                });
                if (o.isDifferentiable() && (l = o, c = f, t <= d + m)) {
                    s = f, a = o.divideAtLength((n ? 1 : -1) * (t - d), {
                        precision: h,
                        subdivisions: p
                    });
                    break;
                }
                d += m;
            }
            if (!l) return null;
            a || (s = c, u = n ? 1 : 0, a = l.divideAtT(u));
            var I = this.clone();
            I.replaceSegment(s, a);
            var v = s, A = s + 1, C = s + 2;
            a[0].isDifferentiable() || (I.removeSegment(v), A -= 1, C -= 1);
            var y = I.getSegment(A).start;
            I.insertSegment(A, Tn.createSegment("M", y)), C += 1, a[1].isDifferentiable() || (I.removeSegment(C - 1), C -= 1);
            var w = C - v - 1;
            for(r = C; r < I.segments.length; r++){
                var b = this.getSegment(r - w);
                if ("Z" === (o = I.getSegment(r)).type && !b.subpathStartSegment.end.equals(o.subpathStartSegment.end)) {
                    var N = Tn.createSegment("L", b.end);
                    I.replaceSegment(r, N);
                }
            }
            return [
                new Tn(I.segments.slice(0, A)),
                new Tn(I.segments.slice(A))
            ];
        },
        equals: function(t) {
            if (!t) return !1;
            var e = this.segments, i = t.segments, n = e.length;
            if (i.length !== n) return !1;
            for(var r = 0; r < n; r++){
                var o = e[r], a = i[r];
                if (o.type !== a.type || !o.equals(a)) return !1;
            }
            return !0;
        },
        getSegment: function(t) {
            var e = this.segments, i = e.length;
            if (0 === i) throw new Error("Path has no segments.");
            if (t < 0 && (t = i + t), i <= t || t < 0) throw new Error("Index out of range.");
            return e[t];
        },
        getSegmentSubdivisions: function(t) {
            for(var e = this.segments, i = e.length, n = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, r = [], o = 0; o < i; o++){
                var a = e[o].getSubdivisions({
                    precision: n
                });
                r.push(a);
            }
            return r;
        },
        getSubpaths: function() {
            for(var t = this.clone().validate().segments, e = t.length, i = [], n = 0; n < e; n++){
                var r = t[n];
                r.isSubpathStart ? i.push(new Tn(r)) : i[i.length - 1].appendSegment(r);
            }
            return i;
        },
        insertSegment: function(t, e) {
            var i, n = this.segments, r = n.length;
            if (t < 0 && (t = r + t + 1), r < t || t < 0) throw new Error("Index out of range.");
            var o = null, a = null;
            if (0 !== r && (a = 1 <= t ? (o = n[t - 1]).nextSegment : n[0]), Array.isArray(e)) {
                if (!(e = e.reduce(function(t, e) {
                    return t.concat(e);
                }, []))[0].isSegment) throw new Error("Segments required.");
                for(var s = e.length, l = 0; l < s; l++){
                    var c = e[l];
                    i = this.prepareSegment(c, o, a), n.splice(t + l, 0, i), o = i;
                }
            } else {
                if (!e || !e.isSegment) throw new Error("Segment required.");
                i = this.prepareSegment(e, o, a), n.splice(t, 0, i);
            }
        },
        intersectionWithLine: function(t, e) {
            var i = null, n = this.toPolylines(e);
            if (!n) return null;
            for(var r = 0, o = n.length; r < o; r++){
                var a = n[r], s = t.intersect(a);
                s && (i || (i = []), Array.isArray(s) ? Array.prototype.push.apply(i, s) : i.push(s));
            }
            return i;
        },
        isDifferentiable: function() {
            for(var t = this.segments, e = t.length, i = 0; i < e; i++){
                if (t[i].isDifferentiable()) return !0;
            }
            return !1;
        },
        isValid: function() {
            var t = this.segments;
            return 0 === t.length || "M" === t[0].type;
        },
        length: function(t) {
            var e = this.segments, i = e.length;
            if (0 === i) return 0;
            for(var n = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, r = void 0 === t.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: n
            }) : t.segmentSubdivisions, o = 0, a = 0; a < i; a++){
                var s = e[a], l = r[a];
                o += s.length({
                    subdivisions: l
                });
            }
            return o;
        },
        lengthAtT: function(t, e) {
            var i = this.segments, n = i.length;
            if (0 === n) return 0;
            var r = t.segmentIndex;
            if (r < 0) return 0;
            var o = t.value;
            n <= r ? (r = n - 1, o = 1) : o < 0 ? o = 0 : 1 < o && (o = 1);
            for(var a, s = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, l = void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: s
            }) : e.segmentSubdivisions, c = 0, u = 0; u < r; u++){
                var h = i[u];
                a = l[u], c += h.length({
                    precisison: s,
                    subdivisions: a
                });
            }
            return h = i[r], a = l[r], c += h.lengthAtT(o, {
                precisison: s,
                subdivisions: a
            });
        },
        pointAt: function(t, e) {
            if (0 === this.segments.length) return null;
            if (t <= 0) return this.start.clone();
            if (1 <= t) return this.end.clone();
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                segmentSubdivisions: void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                    precision: i
                }) : e.segmentSubdivisions
            }, r = this.length(n) * t;
            return this.pointAtLength(r, n);
        },
        pointAtLength: function(t, e) {
            var i = this.segments, n = i.length;
            if (0 === n) return null;
            if (0 === t) return this.start.clone();
            var r = !0;
            t < 0 && (r = !1, t = -t);
            for(var o, a = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, s = void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: a
            }) : e.segmentSubdivisions, l = 0, c = 0; c < n; c++){
                var u = r ? c : n - 1 - c, h = i[u], g = s[u], d = h.length({
                    precision: a,
                    subdivisions: g
                });
                if (h.isVisible) {
                    if (t <= l + d) return h.pointAtLength((r ? 1 : -1) * (t - l), {
                        precision: a,
                        subdivisions: g
                    });
                    o = h;
                }
                l += d;
            }
            return o ? r ? o.end : o.start : i[n - 1].end.clone();
        },
        pointAtT: function(t) {
            var e = this.segments, i = e.length;
            if (0 === i) return null;
            var n = t.segmentIndex;
            if (n < 0) return e[0].pointAtT(0);
            if (i <= n) return e[i - 1].pointAtT(1);
            var r = t.value;
            return r < 0 ? r = 0 : 1 < r && (r = 1), e[n].pointAtT(r);
        },
        PRECISION: 3,
        prepareSegment: function(t, e, i) {
            t.previousSegment = e, t.nextSegment = i, e && (e.nextSegment = t), i && (i.previousSegment = t);
            var n = t;
            return t.isSubpathStart && (t.subpathStartSegment = t, n = i), n && this.updateSubpathStartSegment(n), t;
        },
        removeSegment: function(t) {
            var e = this.segments, i = e.length;
            if (0 === i) throw new Error("Path has no segments.");
            if (t < 0 && (t = i + t), i <= t || t < 0) throw new Error("Index out of range.");
            var n = e.splice(t, 1)[0], r = n.previousSegment, o = n.nextSegment;
            r && (r.nextSegment = o), o && (o.previousSegment = r), n.isSubpathStart && o && this.updateSubpathStartSegment(o);
        },
        replaceSegment: function(t, e) {
            var i, n = this.segments, r = n.length;
            if (0 === r) throw new Error("Path has no segments.");
            if (t < 0 && (t = r + t), r <= t || t < 0) throw new Error("Index out of range.");
            var o = n[t], a = o.previousSegment, s = o.nextSegment, l = o.isSubpathStart;
            if (Array.isArray(e)) {
                if (!(e = e.reduce(function(t, e) {
                    return t.concat(e);
                }, []))[0].isSegment) throw new Error("Segments required.");
                n.splice(t, 1);
                for(var c = e.length, u = 0; u < c; u++){
                    var h = e[u];
                    i = this.prepareSegment(h, a, s), n.splice(t + u, 0, i), a = i, l && i.isSubpathStart && (l = !1);
                }
            } else {
                if (!e || !e.isSegment) throw new Error("Segment required.");
                i = this.prepareSegment(e, a, s), n.splice(t, 1, i), l && i.isSubpathStart && (l = !1);
            }
            l && s && this.updateSubpathStartSegment(s);
        },
        round: function(t) {
            for(var e = this.segments, i = e.length, n = 0; n < i; n++)e[n].round(t);
            return this;
        },
        scale: function(t, e, i) {
            for(var n = this.segments, r = n.length, o = 0; o < r; o++)n[o].scale(t, e, i);
            return this;
        },
        segmentAt: function(t, e) {
            var i = this.segmentIndexAt(t, e);
            return i ? this.getSegment(i) : null;
        },
        segmentAtLength: function(t, e) {
            var i = this.segmentIndexAtLength(t, e);
            return i ? this.getSegment(i) : null;
        },
        segmentIndexAt: function(t, e) {
            if (0 === this.segments.length) return null;
            t < 0 && (t = 0), 1 < t && (t = 1);
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                segmentSubdivisions: void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                    precision: i
                }) : e.segmentSubdivisions
            }, r = this.length(n) * t;
            return this.segmentIndexAtLength(r, n);
        },
        segmentIndexAtLength: function(t, e) {
            var i = this.segments, n = i.length;
            if (0 === n) return null;
            var r = !0;
            t < 0 && (r = !1, t = -t);
            for(var o = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, a = void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: o
            }) : e.segmentSubdivisions, s = null, l = 0, c = 0; c < n; c++){
                var u = r ? c : n - 1 - c, h = i[u], g = a[u], d = h.length({
                    precision: o,
                    subdivisions: g
                });
                if (h.isVisible) {
                    if (t <= l + d) return u;
                    s = u;
                }
                l += d;
            }
            return s;
        },
        serialize: function() {
            if (!this.isValid()) throw new Error("Invalid path segments.");
            return this.toString();
        },
        tangentAt: function(t, e) {
            if (0 === this.segments.length) return null;
            t < 0 && (t = 0), 1 < t && (t = 1);
            var i = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, n = {
                precision: i,
                segmentSubdivisions: void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                    precision: i
                }) : e.segmentSubdivisions
            }, r = this.length(n) * t;
            return this.tangentAtLength(r, n);
        },
        tangentAtLength: function(t, e) {
            var i = this.segments, n = i.length;
            if (0 === n) return null;
            var r = !0;
            t < 0 && (r = !1, t = -t);
            for(var o, a = void 0 === (e = e || {}).precision ? this.PRECISION : e.precision, s = void 0 === e.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: a
            }) : e.segmentSubdivisions, l = 0, c = 0; c < n; c++){
                var u = r ? c : n - 1 - c, h = i[u], g = s[u], d = h.length({
                    precision: a,
                    subdivisions: g
                });
                if (h.isDifferentiable()) {
                    if (t <= l + d) return h.tangentAtLength((r ? 1 : -1) * (t - l), {
                        precision: a,
                        subdivisions: g
                    });
                    o = h;
                }
                l += d;
            }
            if (o) {
                var f = r ? 1 : 0;
                return o.tangentAtT(f);
            }
            return null;
        },
        tangentAtT: function(t) {
            var e = this.segments, i = e.length;
            if (0 === i) return null;
            var n = t.segmentIndex;
            if (n < 0) return e[0].tangentAtT(0);
            if (i <= n) return e[i - 1].tangentAtT(1);
            var r = t.value;
            return r < 0 ? r = 0 : 1 < r && (r = 1), e[n].tangentAtT(r);
        },
        toPoints: function(t) {
            var e = this.segments, i = e.length;
            if (0 === i) return null;
            for(var n = void 0 === (t = t || {}).precision ? this.PRECISION : t.precision, r = void 0 === t.segmentSubdivisions ? this.getSegmentSubdivisions({
                precision: n
            }) : t.segmentSubdivisions, o = [], a = [], s = 0; s < i; s++){
                var l = e[s];
                if (l.isVisible) {
                    var c = r[s];
                    if (0 < c.length) {
                        var u = c.map(function(t) {
                            return t.start;
                        });
                        Array.prototype.push.apply(a, u);
                    } else a.push(l.start);
                } else 0 < a.length && (a.push(e[s - 1].end), o.push(a), a = []);
            }
            return 0 < a.length && (a.push(this.end), o.push(a)), o;
        },
        toPolylines: function(t) {
            var e = [], i = this.toPoints(t);
            if (!i) return null;
            for(var n = 0, r = i.length; n < r; n++)e.push(new wn(i[n]));
            return e;
        },
        toString: function() {
            for(var t = this.segments, e = t.length, i = "", n = 0; n < e; n++)i += t[n].serialize() + " ";
            return i.trim();
        },
        translate: function(t, e) {
            for(var i = this.segments, n = i.length, r = 0; r < n; r++)i[r].translate(t, e);
            return this;
        },
        updateSubpathStartSegment: function(t) {
            for(var e = t.previousSegment; t && !t.isSubpathStart;)t.subpathStartSegment = e ? e.subpathStartSegment : null, t = (e = t).nextSegment;
        },
        validate: function() {
            return this.isValid() || this.insertSegment(0, Tn.createSegment("M", 0, 0)), this;
        }
    }, Object.defineProperty(Tn.prototype, "start", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            var t = this.segments, e = t.length;
            if (0 === e) return null;
            for(var i = 0; i < e; i++){
                var n = t[i];
                if (n.isVisible) return n.start;
            }
            return t[e - 1].end;
        }
    }), Object.defineProperty(Tn.prototype, "end", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            var t = this.segments, e = t.length;
            if (0 === e) return null;
            for(var i = e - 1; 0 <= i; i--){
                var n = t[i];
                if (n.isVisible) return n.end;
            }
            return t[e - 1].end;
        }
    });
    var zn = {
        bbox: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        clone: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        closestPoint: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        closestPointLength: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        closestPointNormalizedLength: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        closestPointT: function(t) {
            if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(t);
            throw new Error("Neither closestPointT() nor closestPointNormalizedLength() function is implemented.");
        },
        closestPointTangent: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        divideAt: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        divideAtLength: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        divideAtT: function(t) {
            if (this.divideAt) return this.divideAt(t);
            throw new Error("Neither divideAtT() nor divideAt() function is implemented.");
        },
        equals: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        getSubdivisions: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        isDifferentiable: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        isSegment: !0,
        isSubpathStart: !1,
        isVisible: !0,
        length: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        lengthAtT: function(t) {
            if (t <= 0) return 0;
            var e = this.length();
            return 1 <= t ? e : e * t;
        },
        nextSegment: null,
        pointAt: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        pointAtLength: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        pointAtT: function(t) {
            if (this.pointAt) return this.pointAt(t);
            throw new Error("Neither pointAtT() nor pointAt() function is implemented.");
        },
        previousSegment: null,
        round: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        subpathStartSegment: null,
        scale: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        serialize: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        tangentAt: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        tangentAtLength: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        tangentAtT: function(t) {
            if (this.tangentAt) return this.tangentAt(t);
            throw new Error("Neither tangentAtT() nor tangentAt() function is implemented.");
        },
        toString: function() {
            throw new Error("Declaration missing for virtual function.");
        },
        translate: function() {
            throw new Error("Declaration missing for virtual function.");
        }
    };
    Object.defineProperty(zn, "end", {
        configurable: !0,
        enumerable: !0,
        writable: !0
    }), Object.defineProperty(zn, "start", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            if (!this.previousSegment) throw new Error("Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)");
            return this.previousSegment.end;
        }
    }), Object.defineProperty(zn, "type", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            throw new Error("Bad segment declaration. No type specified.");
        }
    });
    var Pn = function() {
        for(var t, e, i = arguments, n = [], r = arguments.length, o = 0; o < r; o++)n.push(i[o]);
        if (!(this instanceof Pn)) return Ln(Pn, n);
        if (0 === r) throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).");
        if (n[0] instanceof nn) {
            if (1 === r) return this.end = n[0].end.clone(), this;
            throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (" + r + " lines provided).");
        }
        if ("string" == typeof n[0] || "number" == typeof n[0]) {
            if (2 === r) return this.end = new qi(+n[0], +n[1]), this;
            if (r < 2) throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (" + r + " coordinates provided).");
            var a;
            for(t = [], o = 0; o < r; o += 2)a = n.slice(o, o + 2), t.push(Ln(Pn, a));
            return t;
        }
        if (1 === r) return this.end = new qi(n[0]), this;
        for(t = [], o = 0; o < r; o += 1)e = n[o], t.push(new Pn(e));
        return t;
    }, jn = {
        clone: function() {
            return new Pn(this.end);
        },
        divideAt: function(t) {
            var e = new nn(this.start, this.end).divideAt(t);
            return [
                new Pn(e[0]),
                new Pn(e[1])
            ];
        },
        divideAtLength: function(t) {
            var e = new nn(this.start, this.end).divideAtLength(t);
            return [
                new Pn(e[0]),
                new Pn(e[1])
            ];
        },
        getSubdivisions: function() {
            return [];
        },
        isDifferentiable: function() {
            return !!this.previousSegment && !this.start.equals(this.end);
        },
        round: function(t) {
            return this.end.round(t), this;
        },
        scale: function(t, e, i) {
            return this.end.scale(t, e, i), this;
        },
        serialize: function() {
            var t = this.end;
            return this.type + " " + t.x + " " + t.y;
        },
        toString: function() {
            return this.type + " " + this.start + " " + this.end;
        },
        translate: function(t, e) {
            return this.end.translate(t, e), this;
        }
    };
    Object.defineProperty(jn, "type", {
        configurable: !0,
        enumerable: !0,
        value: "L"
    }), Pn.prototype = Dn(zn, nn.prototype, jn);
    var Zn = function() {
        for(var t, e, i = arguments, n = [], r = arguments.length, o = 0; o < r; o++)n.push(i[o]);
        if (!(this instanceof Zn)) return Ln(Zn, n);
        if (0 === r) throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).");
        if (n[0] instanceof kn) {
            if (1 === r) return this.controlPoint1 = n[0].controlPoint1.clone(), this.controlPoint2 = n[0].controlPoint2.clone(), this.end = n[0].end.clone(), this;
            throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + r + " curves provided).");
        }
        if ("string" == typeof n[0] || "number" == typeof n[0]) {
            if (6 === r) return this.controlPoint1 = new qi(+n[0], +n[1]), this.controlPoint2 = new qi(+n[2], +n[3]), this.end = new qi(+n[4], +n[5]), this;
            if (r < 6) throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + r + " coordinates provided).");
            var a;
            for(t = [], o = 0; o < r; o += 6)a = n.slice(o, o + 6), t.push(Ln(Zn, a));
            return t;
        }
        if (3 === r) return this.controlPoint1 = new qi(n[0]), this.controlPoint2 = new qi(n[1]), this.end = new qi(n[2]), this;
        if (r < 3) throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + r + " points provided).");
        for(t = [], o = 0; o < r; o += 3)e = n.slice(o, o + 3), t.push(Ln(Zn, e));
        return t;
    }, Gn = {
        clone: function() {
            return new Zn(this.controlPoint1, this.controlPoint2, this.end);
        },
        divideAt: function(t, e) {
            var i = new kn(this.start, this.controlPoint1, this.controlPoint2, this.end).divideAt(t, e);
            return [
                new Zn(i[0]),
                new Zn(i[1])
            ];
        },
        divideAtLength: function(t, e) {
            var i = new kn(this.start, this.controlPoint1, this.controlPoint2, this.end).divideAtLength(t, e);
            return [
                new Zn(i[0]),
                new Zn(i[1])
            ];
        },
        divideAtT: function(t) {
            var e = new kn(this.start, this.controlPoint1, this.controlPoint2, this.end).divideAtT(t);
            return [
                new Zn(e[0]),
                new Zn(e[1])
            ];
        },
        isDifferentiable: function() {
            if (!this.previousSegment) return !1;
            var t = this.start, e = this.controlPoint1, i = this.controlPoint2, n = this.end;
            return !(t.equals(e) && e.equals(i) && i.equals(n));
        },
        round: function(t) {
            return this.controlPoint1.round(t), this.controlPoint2.round(t), this.end.round(t), this;
        },
        scale: function(t, e, i) {
            return this.controlPoint1.scale(t, e, i), this.controlPoint2.scale(t, e, i), this.end.scale(t, e, i), this;
        },
        serialize: function() {
            var t = this.controlPoint1, e = this.controlPoint2, i = this.end;
            return this.type + " " + t.x + " " + t.y + " " + e.x + " " + e.y + " " + i.x + " " + i.y;
        },
        toString: function() {
            return this.type + " " + this.start + " " + this.controlPoint1 + " " + this.controlPoint2 + " " + this.end;
        },
        translate: function(t, e) {
            return this.controlPoint1.translate(t, e), this.controlPoint2.translate(t, e), this.end.translate(t, e), this;
        }
    };
    Object.defineProperty(Gn, "type", {
        configurable: !0,
        enumerable: !0,
        value: "C"
    }), Zn.prototype = Dn(zn, kn.prototype, Gn);
    var Bn = function() {
        for(var t, e, i = arguments, n = [], r = arguments.length, o = 0; o < r; o++)n.push(i[o]);
        if (!(this instanceof Bn)) return Ln(Bn, n);
        if (0 === r) throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).");
        if (n[0] instanceof nn) {
            if (1 === r) return this.end = n[0].end.clone(), this;
            throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + r + " lines provided).");
        }
        if (n[0] instanceof kn) {
            if (1 === r) return this.end = n[0].end.clone(), this;
            throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + r + " curves provided).");
        }
        if ("string" == typeof n[0] || "number" == typeof n[0]) {
            if (2 === r) return this.end = new qi(+n[0], +n[1]), this;
            if (r < 2) throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + r + " coordinates provided).");
            var a;
            for(t = [], o = 0; o < r; o += 2)a = n.slice(o, o + 2), 0 === o ? t.push(Ln(Bn, a)) : t.push(Ln(Pn, a));
            return t;
        }
        if (1 === r) return this.end = new qi(n[0]), this;
        for(t = [], o = 0; o < r; o += 1)e = n[o], 0 === o ? t.push(new Bn(e)) : t.push(new Pn(e));
        return t;
    }, On = {
        bbox: function() {
            return null;
        },
        clone: function() {
            return new Bn(this.end);
        },
        closestPoint: function() {
            return this.end.clone();
        },
        closestPointNormalizedLength: function() {
            return 0;
        },
        closestPointLength: function() {
            return 0;
        },
        closestPointT: function() {
            return 1;
        },
        closestPointTangent: function() {
            return null;
        },
        divideAt: function() {
            return [
                this.clone(),
                this.clone()
            ];
        },
        divideAtLength: function() {
            return [
                this.clone(),
                this.clone()
            ];
        },
        equals: function(t) {
            return this.end.equals(t.end);
        },
        getSubdivisions: function() {
            return [];
        },
        isDifferentiable: function() {
            return !1;
        },
        isSubpathStart: !0,
        isVisible: !1,
        length: function() {
            return 0;
        },
        lengthAtT: function() {
            return 0;
        },
        pointAt: function() {
            return this.end.clone();
        },
        pointAtLength: function() {
            return this.end.clone();
        },
        pointAtT: function() {
            return this.end.clone();
        },
        round: function(t) {
            return this.end.round(t), this;
        },
        scale: function(t, e, i) {
            return this.end.scale(t, e, i), this;
        },
        serialize: function() {
            var t = this.end;
            return this.type + " " + t.x + " " + t.y;
        },
        tangentAt: function() {
            return null;
        },
        tangentAtLength: function() {
            return null;
        },
        tangentAtT: function() {
            return null;
        },
        toString: function() {
            return this.type + " " + this.end;
        },
        translate: function(t, e) {
            return this.end.translate(t, e), this;
        }
    };
    Object.defineProperty(On, "start", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            throw new Error("Illegal access. Moveto segments should not need a start property.");
        }
    }), Object.defineProperty(On, "type", {
        configurable: !0,
        enumerable: !0,
        value: "M"
    }), Bn.prototype = Dn(zn, On);
    var En = function() {
        for(var t = arguments, e = [], i = arguments.length, n = 0; n < i; n++)e.push(t[n]);
        if (!(this instanceof En)) return Ln(En, e);
        if (0 < i) throw new Error("Closepath constructor expects no arguments.");
        return this;
    }, Rn = {
        clone: function() {
            return new En;
        },
        divideAt: function(t) {
            var e = new nn(this.start, this.end).divideAt(t);
            return [
                e[1].isDifferentiable() ? new Pn(e[0]) : this.clone(),
                new Pn(e[1])
            ];
        },
        divideAtLength: function(t) {
            var e = new nn(this.start, this.end).divideAtLength(t);
            return [
                e[1].isDifferentiable() ? new Pn(e[0]) : this.clone(),
                new Pn(e[1])
            ];
        },
        getSubdivisions: function() {
            return [];
        },
        isDifferentiable: function() {
            return !(!this.previousSegment || !this.subpathStartSegment) && !this.start.equals(this.end);
        },
        round: function() {
            return this;
        },
        scale: function() {
            return this;
        },
        serialize: function() {
            return this.type;
        },
        toString: function() {
            return this.type + " " + this.start + " " + this.end;
        },
        translate: function() {
            return this;
        }
    };
    Object.defineProperty(Rn, "end", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            if (!this.subpathStartSegment) throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)");
            return this.subpathStartSegment.end;
        }
    }), Object.defineProperty(Rn, "type", {
        configurable: !0,
        enumerable: !0,
        value: "Z"
    }), En.prototype = Dn(zn, nn.prototype, Rn);
    var Yn = Tn.segmentTypes = {
        L: Pn,
        C: Zn,
        M: Bn,
        Z: En,
        z: En
    };
    Tn.regexSupportedData = new RegExp("^[\\s\\d" + Object.keys(Yn).join("") + ",.]*$"), Tn.isDataSupported = function(t) {
        return "string" == typeof t && this.regexSupportedData.test(t);
    };
    var Wn = {
        curveThroughPoints: function(t) {
            return console.warn("deprecated"), new Tn(kn.throughPoints(t)).serialize();
        },
        getCurveControlPoints: function(t) {
            console.warn("deprecated");
            var e, i = [], n = [], r = t.length - 1;
            if (1 == r) return i[0] = new qi((2 * t[0].x + t[1].x) / 3, (2 * t[0].y + t[1].y) / 3), n[0] = new qi(2 * i[0].x - t[0].x, 2 * i[0].y - t[0].y), [
                i,
                n
            ];
            var o = [];
            for(e = 1; e < r - 1; e++)o[e] = 4 * t[e].x + 2 * t[e + 1].x;
            o[0] = t[0].x + 2 * t[1].x, o[r - 1] = (8 * t[r - 1].x + t[r].x) / 2;
            var a = this.getFirstControlPoints(o);
            for(e = 1; e < r - 1; ++e)o[e] = 4 * t[e].y + 2 * t[e + 1].y;
            o[0] = t[0].y + 2 * t[1].y, o[r - 1] = (8 * t[r - 1].y + t[r].y) / 2;
            var s = this.getFirstControlPoints(o);
            for(e = 0; e < r; e++)i.push(new qi(a[e], s[e])), e < r - 1 ? n.push(new qi(2 * t[e + 1].x - a[e + 1], 2 * t[e + 1].y - s[e + 1])) : n.push(new qi((t[r].x + a[r - 1]) / 2, (t[r].y + s[r - 1]) / 2));
            return [
                i,
                n
            ];
        },
        getCurveDivider: function(t, e, i, n) {
            console.warn("deprecated");
            var r = new kn(t, e, i, n);
            return function(t) {
                var e = r.divide(t);
                return [
                    {
                        p0: e[0].start,
                        p1: e[0].controlPoint1,
                        p2: e[0].controlPoint2,
                        p3: e[0].end
                    },
                    {
                        p0: e[1].start,
                        p1: e[1].controlPoint1,
                        p2: e[1].controlPoint2,
                        p3: e[1].end
                    }
                ];
            };
        },
        getFirstControlPoints: function(t) {
            console.warn("deprecated");
            var e = t.length, i = [], n = [], r = 2;
            i[0] = t[0] / r;
            for(var o = 1; o < e; o++)n[o] = 1 / r, r = (o < e - 1 ? 4 : 3.5) - n[o], i[o] = (t[o] - i[o - 1]) / r;
            for(o = 1; o < e; o++)i[e - o - 1] -= n[e - o] * i[e - o];
            return i;
        },
        getInversionSolver: function(t, e, i, n) {
            console.warn("deprecated");
            var r = new kn(t, e, i, n);
            return function(t) {
                return r.closestPointT(t);
            };
        }
    }, Un = function(t) {
        return this instanceof Un ? "string" == typeof t ? new Un.parse(t) : void (this.points = Array.isArray(t) ? t.map(qi) : []) : new Un(t);
    };
    function Fn(t, e) {
        var i = t.start.x, n = t.start.y, r = t.end.x, o = t.end.y, a = e.start.x, s = e.start.y, l = r - i, c = o - n, u = e.end.x - a, h = e.end.y - s, g = i - a, d = n - s, f = l * h - u * c, p = (l * d - c * g) / f, m = (u * d - h * g) / f;
        return 0 <= p && p <= 1 && 0 <= m && m <= 1;
    }
    function Vn(t, e) {
        var i = t.a, n = t.b, r = t.x, o = t.y, a = e.start.x - r, s = e.end.x - r, l = e.start.y - o, c = i * i, u = n * n, h = s - a, g = e.end.y - o - l, d = h * h / c + g * g / u, f = 2 * a * h / c + 2 * l * g / u, p = f * f - 4 * d * (a * a / c + l * l / u - 1);
        if (0 === p) {
            var m = -f / 2 / d;
            return 0 <= m && m <= 1;
        }
        if (0 < p) {
            var I = Math.sqrt(p), v = (-f + I) / 2 / d, A = (-f - I) / 2 / d;
            return 0 <= v && v <= 1 || 0 <= A && A <= 1;
        }
        return !1;
    }
    function Xn(t, e) {
        return function(t, e, i, n) {
            var r = Math.cos, o = Math.sin, a = o(e), s = r(e), l = o(n), c = r(n), u = a * a, h = s * s, g = a * s, d = l * l, f = c * c, p = l * c, m = t.a * t.a, I = t.b * t.b, v = i.a * i.a, A = i.b * i.b, C = m * u + I * h, y = v * d + A * f, w = m * h + I * u, b = v * f + A * d, N = 2 * (I - m) * g, x = 2 * (A - v) * p, M = -2 * C * t.x - N * t.y, S = -2 * y * i.x - x * i.y, k = -N * t.x - 2 * w * t.y, D = -x * i.x - 2 * b * i.y, T = C * t.x * t.x + w * t.y * t.y + N * t.x * t.y - m * I, L = y * i.x * i.x + b * i.y * i.y + x * i.x * i.y - v * A;
            x /= 2, S /= 2, D /= 2;
            var z = vr([
                [
                    C,
                    N /= 2,
                    M /= 2
                ],
                [
                    N,
                    w,
                    k /= 2
                ],
                [
                    M,
                    k,
                    T
                ]
            ]), P = vr([
                [
                    y,
                    x,
                    S
                ],
                [
                    x,
                    b,
                    D
                ],
                [
                    S,
                    D,
                    L
                ]
            ]), j = .33333333 * (vr([
                [
                    y,
                    N,
                    M
                ],
                [
                    x,
                    w,
                    k
                ],
                [
                    S,
                    k,
                    T
                ]
            ]) + vr([
                [
                    C,
                    x,
                    M
                ],
                [
                    N,
                    b,
                    k
                ],
                [
                    M,
                    D,
                    T
                ]
            ]) + vr([
                [
                    C,
                    N,
                    S
                ],
                [
                    N,
                    w,
                    D
                ],
                [
                    M,
                    k,
                    L
                ]
            ])), Z = .33333333 * (vr([
                [
                    C,
                    x,
                    S
                ],
                [
                    N,
                    b,
                    D
                ],
                [
                    M,
                    D,
                    L
                ]
            ]) + vr([
                [
                    y,
                    N,
                    S
                ],
                [
                    x,
                    w,
                    D
                ],
                [
                    S,
                    k,
                    L
                ]
            ]) + vr([
                [
                    y,
                    x,
                    M
                ],
                [
                    x,
                    b,
                    k
                ],
                [
                    S,
                    D,
                    T
                ]
            ])), G = Ir([
                [
                    z,
                    j
                ],
                [
                    j,
                    Z
                ]
            ]), B = Ir([
                [
                    z,
                    Z
                ],
                [
                    j,
                    P
                ]
            ]), O = Ir([
                [
                    j,
                    Z
                ],
                [
                    Z,
                    P
                ]
            ]);
            if (0 < Ir([
                [
                    2 * G,
                    B
                ],
                [
                    B,
                    2 * O
                ]
            ]) && (0 < Z || 0 < j)) return !1;
            return !0;
        }(t, 0, e, 0);
    }
    function Hn(t, e) {
        var i = e.start, n = e.end, r = t.x, o = t.y, a = t.width, s = t.height;
        return !(i.x > r + a && n.x > r + a || i.x < r && n.x < r || i.y > o + s && n.y > o + s || i.y < o && n.y < o) && (!(!t.containsPoint(e.start) && !t.containsPoint(e.end)) || Fn(t.topLine(), e) || Fn(t.rightLine(), e) || Fn(t.bottomLine(), e) || Fn(t.leftLine(), e));
    }
    function Jn(t, e) {
        return !!_n(t, In.fromEllipse(e)) && er(Un.fromRect(t), e);
    }
    function _n(t, e) {
        return t.x < e.x + e.width && t.x + t.width > e.x && t.y < e.y + e.height && t.y + t.height > e.y;
    }
    function Qn(t, e) {
        return hr(t, e, {
            interior: !1
        });
    }
    function Kn(t, e) {
        return gr(t, e, {
            interior: !1
        });
    }
    function qn(t, e) {
        return dr(t, e, {
            interior: !1
        });
    }
    function $n(t, e) {
        return pr(t, e, {
            interior: !1
        });
    }
    function tr(t, e) {
        return hr(t, e, {
            interior: !0
        });
    }
    function er(t, e) {
        return gr(t, e, {
            interior: !0
        });
    }
    function ir(t, e) {
        return dr(t, e, {
            interior: !0
        });
    }
    function nr(t, e) {
        return pr(t, e, {
            interior: !0
        });
    }
    function rr(t, e) {
        return mr(t, e, {
            interior: !0
        });
    }
    function or(t, i, n) {
        return t.getSubpaths().some(function(t) {
            var e = t.toPolylines(n)[0];
            return "Z" === t.getSegment(-1).type ? tr(e, i) : Qn(e, i);
        });
    }
    function ar(t, i, n) {
        return t.getSubpaths().some(function(t) {
            var e = t.toPolylines(n)[0];
            return "Z" === t.getSegment(-1).type ? er(e, i) : Kn(e, i);
        });
    }
    function sr(t, e, i) {
        return cr(t, Un.fromRect(e), i);
    }
    function lr(t, e, i) {
        return fr(t, e, i, {
            interior: !1
        });
    }
    function cr(t, e, i) {
        return fr(t, e, i, {
            interior: !0
        });
    }
    function ur(t, i, n, r) {
        return t.getSubpaths().some(function(t) {
            var e = t.toPolylines(n)[0];
            return "Z" === t.getSegment(-1).type ? cr(i, e, r) : lr(i, e, r);
        });
    }
    function hr(t, e, i) {
        void 0 === i && (i = {});
        var n, r = i.interior;
        if (void 0 === r && (r = !1), r) {
            if (t.containsPoint(e.start)) return !0;
            var o = t.start, a = t.end, s = t.points;
            n = a.equals(o) ? s : s.concat([
                o
            ]);
        } else n = t.points;
        for(var l = n.length, c = new nn, u = 0; u < l - 1; u++)if (c.start = n[u], c.end = n[u + 1], Fn(e, c)) return !0;
        return !1;
    }
    function gr(t, e, i) {
        void 0 === i && (i = {});
        var n, r = t.start, o = t.end, a = t.points;
        if (e.containsPoint(r)) return !0;
        var s = i.interior;
        if (void 0 === s && (s = !1), s) {
            if (t.containsPoint(e.center())) return !0;
            n = o.equals(r) ? a : a.concat([
                r
            ]);
        } else n = a;
        for(var l = n.length, c = new nn, u = 0; u < l - 1; u++)if (c.start = n[u], c.end = n[u + 1], Vn(e, c)) return !0;
        return !1;
    }
    function dr(t, e, i) {
        return mr(t, Un.fromRect(e), i);
    }
    function fr(t, i, n, r) {
        return t.getSubpaths().some(function(t) {
            var e = t.toPolylines(n)[0];
            return "Z" === t.getSegment(-1).type ? mr(i, e, r) : pr(i, e, r);
        });
    }
    function pr(t, e, i) {
        void 0 === i && (i = {});
        var n, r = i.interior;
        if (void 0 === r && (r = !1), r) {
            var o = e.start;
            if (t.containsPoint(o)) return !0;
            n = t.clone().close();
        } else n = t;
        for(var a = e.points, s = a.length, l = new nn, c = 0; c < s - 1; c++)if (l.start = a[c], l.end = a[c + 1], Qn(n, l)) return !0;
        return !1;
    }
    function mr(t, e, i) {
        return e.containsPoint(t.start) || pr(t, e.clone().close(), i);
    }
    function Ir(t) {
        return t[0][0] * t[1][1] - t[0][1] * t[1][0];
    }
    function vr(t) {
        return t[0][0] * t[1][1] * t[2][2] - t[0][0] * t[1][2] * t[2][1] - t[0][1] * t[1][0] * t[2][2] + t[0][1] * t[1][2] * t[2][0] + t[0][2] * t[1][0] * t[2][1] - t[0][2] * t[1][1] * t[2][0];
    }
    Un.parse = function(t) {
        return new Un(An(t));
    }, Un.fromRect = function(t) {
        return new Un([
            t.topLeft(),
            t.topRight(),
            t.bottomRight(),
            t.bottomLeft()
        ]);
    }, Un.prototype = Dn(wn.prototype, {
        type: Yi.Polygon,
        clone: function() {
            return new Un(Cn(this.points));
        },
        convexHull: function() {
            return new Un(yn(this.points));
        },
        lengthPoints: function() {
            var t = this.start, e = this.end, i = this.points;
            return i.length <= 1 || t.equals(e) ? i : i.concat([
                t.clone()
            ]);
        }
    });
    var Ar, Cr, yr = {
        intersection: {
            exists: function t(e, i, n, r) {
                switch(e.type){
                    case Yi.Line:
                        switch(i.type){
                            case Yi.Line:
                                return Fn(e, i);
                        }
                        break;
                    case Yi.Ellipse:
                        switch(i.type){
                            case Yi.Line:
                                return Vn(e, i);
                            case Yi.Ellipse:
                                return Xn(e, i);
                        }
                        break;
                    case Yi.Rect:
                        switch(i.type){
                            case Yi.Line:
                                return Hn(e, i);
                            case Yi.Ellipse:
                                return Jn(e, i);
                            case Yi.Rect:
                                return _n(e, i);
                        }
                        break;
                    case Yi.Polyline:
                        switch(i.type){
                            case Yi.Line:
                                return Qn(e, i);
                            case Yi.Ellipse:
                                return Kn(e, i);
                            case Yi.Rect:
                                return qn(e, i);
                            case Yi.Polyline:
                                return $n(e, i);
                        }
                        break;
                    case Yi.Polygon:
                        switch(i.type){
                            case Yi.Line:
                                return tr(e, i);
                            case Yi.Ellipse:
                                return er(e, i);
                            case Yi.Rect:
                                return ir(e, i);
                            case Yi.Polyline:
                                return nr(e, i);
                            case Yi.Polygon:
                                return rr(e, i);
                        }
                        break;
                    case Yi.Path:
                        switch(i.type){
                            case Yi.Line:
                                return or(e, i, n);
                            case Yi.Ellipse:
                                return ar(e, i, n);
                            case Yi.Rect:
                                return sr(e, i, n);
                            case Yi.Polyline:
                                return lr(e, i, n);
                            case Yi.Polygon:
                                return cr(e, i, n);
                            case Yi.Path:
                                return ur(e, i, n, r);
                        }
                }
                switch(i.type){
                    case Yi.Ellipse:
                    case Yi.Rect:
                    case Yi.Polyline:
                    case Yi.Polygon:
                    case Yi.Path:
                        return t(i, e, r, n);
                    default:
                        throw Error("The intersection for " + e + " and " + i + " could not be found.");
                }
            },
            lineWithLine: Fn,
            ellipseWithLine: Vn,
            ellipseWithEllipse: Xn,
            rectWithLine: Hn,
            rectWithEllipse: Jn,
            rectWithRect: _n,
            polylineWithLine: Qn,
            polylineWithEllipse: Kn,
            polylineWithRect: qn,
            polylineWithPolyline: $n,
            polygonWithLine: tr,
            polygonWithEllipse: er,
            polygonWithRect: ir,
            polygonWithPolyline: nr,
            polygonWithPolygon: rr,
            pathWithLine: or,
            pathWithEllipse: ar,
            pathWithRect: sr,
            pathWithPolyline: lr,
            pathWithPolygon: cr,
            pathWithPath: ur
        },
        scale: {
            linear: function(t, e, i) {
                var n = t[1] - t[0], r = e[1] - e[0];
                return (i - t[0]) / n * r + e[0] || 0;
            }
        },
        normalizeAngle: Ti,
        snapToGrid: Li,
        toDeg: zi,
        toRad: Pi,
        random: ji,
        bezier: Wn,
        Curve: kn,
        Ellipse: ln,
        ellipse: cn,
        Line: nn,
        line: rn,
        Path: Tn,
        Point: qi,
        point: $i,
        Polyline: wn,
        Polygon: Un,
        Rect: In,
        rect: vn,
        types: Yi
    }, wr = function() {
        if (!("object" == typeof window && !(!window.SVGAngle && !document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")))) return function() {
            throw new Error("SVG is required to use Vectorizer.");
        };
        var T = {
            svg: "http://www.w3.org/2000/svg",
            xmlns: "http://www.w3.org/2000/xmlns/",
            xml: "http://www.w3.org/XML/1998/namespace",
            xlink: "http://www.w3.org/1999/xlink",
            xhtml: "http://www.w3.org/1999/xhtml"
        }, t = Math, p = t.PI, o = t.atan2, a = t.sqrt, h = t.min, g = t.max, m = t.cos, I = t.sin, L = function(t, e, i) {
            if (!(this instanceof L)) return L.apply(Object.create(L.prototype), arguments);
            if (t) {
                if (L.isV(t) && (t = t.node), e = e || {}, L.isString(t)) {
                    if ("svg" === (t = t.trim()).toLowerCase()) t = L.createSvgDocument();
                    else if ("<" === t[0]) {
                        var n = L.createSvgDocument(t);
                        if (1 < n.childNodes.length) {
                            var r, o, a = [];
                            for(r = 0, o = n.childNodes.length; r < o; r++){
                                var s = n.childNodes[r];
                                a.push(new L(document.importNode(s, !0)));
                            }
                            return a;
                        }
                        t = document.importNode(n.firstChild, !0);
                    } else t = document.createElementNS(T.svg, t);
                    L.ensureId(t);
                }
                return this.node = t, this.setAttributes(e), i && this.append(i), this;
            }
        }, e = L.prototype;
        function z(t, e, i) {
            i || (i = {});
            for(var n = i.includeAnnotationIndices, r = i.eol, o = i.lineHeight, a = i.baseSize, s = 0, l = {}, c = e.length - 1, u = 0; u <= c; u++){
                var h = e[u], g = null;
                if (L.isObject(h)) {
                    var d = h.attrs, f = L("tspan", d), p = f.node, m = h.t;
                    r && u === c && (m += r), p.textContent = m;
                    var I = d.class;
                    I && f.addClass(I), n && f.attr("annotations", h.annotations), g = parseFloat(d["font-size"]), isFinite(g) || (g = a), g && s < g && (s = g);
                } else r && u === c && (h += r), p = document.createTextNode(h || " "), a && s < a && (s = a);
                t.appendChild(p);
            }
            return s && (l.maxFontSize = s), o ? l.lineHeight = o : s && (l.lineHeight = 1.2 * s), l;
        }
        Object.defineProperty(e, "id", {
            enumerable: !0,
            get: function() {
                return this.node.id;
            },
            set: function(t) {
                this.node.id = t;
            }
        }), e.getTransformToElement = function(t) {
            var e = this.node;
            if (L.isSVGGraphicsElement(t) && L.isSVGGraphicsElement(e)) {
                var i = L.toNode(t).getScreenCTM(), n = e.getScreenCTM();
                if (i && n) return i.inverse().multiply(n);
            }
            return L.createSVGMatrix();
        }, e.transform = function(t, e) {
            var i = this.node;
            if (L.isUndefined(t)) return L.transformStringToMatrix(this.attr("transform"));
            if (e && e.absolute) return this.attr("transform", L.matrixToTransformString(t));
            var n = L.createSVGTransform(t);
            return i.transform.baseVal.appendItem(n), this;
        }, e.translate = function(t, e, i) {
            i = i || {}, e = e || 0;
            var n = this.attr("transform") || "", r = L.parseTransformString(n);
            if (n = r.value, L.isUndefined(t)) return r.translate;
            n = n.replace(/translate\([^)]*\)/g, "").trim();
            var o = "translate(" + (i.absolute ? t : r.translate.tx + t) + "," + (i.absolute ? e : r.translate.ty + e) + ")";
            return this.attr("transform", (o + " " + n).trim()), this;
        }, e.rotate = function(t, e, i, n) {
            n = n || {};
            var r = this.attr("transform") || "", o = L.parseTransformString(r);
            if (r = o.value, L.isUndefined(t)) return o.rotate;
            r = r.replace(/rotate\([^)]*\)/g, "").trim(), t %= 360;
            var a = "rotate(" + (n.absolute ? t : o.rotate.angle + t) + (void 0 !== e && void 0 !== i ? "," + e + "," + i : "") + ")";
            return this.attr("transform", (r + " " + a).trim()), this;
        }, e.scale = function(t, e) {
            e = L.isUndefined(e) ? t : e;
            var i = this.attr("transform") || "", n = L.parseTransformString(i);
            if (i = n.value, L.isUndefined(t)) return n.scale;
            i = i.replace(/scale\([^)]*\)/g, "").trim();
            var r = "scale(" + t + "," + e + ")";
            return this.attr("transform", (i + " " + r).trim()), this;
        }, e.bbox = function(t, e) {
            var i, n = this.node, r = n.ownerSVGElement;
            if (!r) return new In(0, 0, 0, 0);
            try {
                i = n.getBBox();
            } catch (t1) {
                i = {
                    x: n.clientLeft,
                    y: n.clientTop,
                    width: n.clientWidth,
                    height: n.clientHeight
                };
            }
            if (t) return new In(i);
            var o = this.getTransformToElement(e || r);
            return L.transformRect(i, o);
        }, e.getBBox = function(t) {
            var e, i = {}, n = this.node;
            if (!n.ownerSVGElement || !L.isSVGGraphicsElement(n)) return new In(0, 0, 0, 0);
            if (t && (t.target && (i.target = L.toNode(t.target)), t.recursive && (i.recursive = t.recursive)), i.recursive) {
                var r = this.children(), o = r.length;
                if (0 === o) return this.getBBox({
                    target: i.target,
                    recursive: !1
                });
                i.target || (i.target = this);
                for(var a = 0; a < o; a++){
                    var s, l = r[a];
                    s = 0 === l.children().length ? l.getBBox({
                        target: i.target,
                        recursive: !1
                    }) : l.getBBox({
                        target: i.target,
                        recursive: !0
                    }), e = e ? e.union(s) : s;
                }
                return e;
            }
            try {
                e = n.getBBox();
            } catch (t1) {
                e = {
                    x: n.clientLeft,
                    y: n.clientTop,
                    width: n.clientWidth,
                    height: n.clientHeight
                };
            }
            if (i.target) {
                var c = this.getTransformToElement(i.target);
                return L.transformRect(e, c);
            }
            return new In(e);
        };
        var P = /em$/;
        function j(t, e) {
            var i = parseFloat(t);
            return P.test(t) ? i * e : i;
        }
        e.text = function(t, e) {
            if (t && "string" != typeof t) throw new Error("Vectorizer: text() expects the first argument to be a string.");
            t = L.sanitizeText(t), e || (e = {});
            var i = e.displayEmpty, n = e.eol, r = e.textPath, o = e.textVerticalAnchor, a = "middle" === o || "bottom" === o || "top" === o, s = e.x;
            void 0 === s && (s = this.attr("x") || 0);
            var l = e.includeAnnotationIndices, c = e.annotations;
            c && !L.isArray(c) && (c = [
                c
            ]);
            var u = e.lineHeight, h = "auto" === u, g = h ? "1.5em" : u || "1em";
            this.empty(), this.attr({
                "xml:space": "preserve",
                display: t || i ? null : "none"
            });
            var d = parseFloat(this.attr("font-size"));
            d || (d = 16, (a || c) && this.attr("font-size", d));
            var f, p = document;
            f = r ? ("string" == typeof r && (r = {
                d: r
            }), function(t, e) {
                t || (t = {});
                var i = L("textPath"), n = t.d;
                if (n && void 0 === t["xlink:href"]) {
                    var r = L("path").attr("d", n).appendTo(e.defs());
                    i.attr("xlink:href", "#" + r.id);
                }
                return L.isObject(t) && i.attr(t), i.node;
            }(r, this)) : p.createDocumentFragment();
            for(var m, I = 0, v = t.split("\n"), A = [], C = 0, y = v.length - 1; C <= y; C++){
                var w, b = g, N = "v-line", x = p.createElementNS(T.svg, "tspan"), M = v[C];
                if (M) {
                    if (c) {
                        var S = (w = z(x, L.annotateString(M, c, {
                            offset: -I,
                            includeAnnotationIndices: l
                        }), {
                            includeAnnotationIndices: l,
                            eol: C !== y && n,
                            lineHeight: h ? null : g,
                            baseSize: d
                        })).lineHeight;
                        S && h && 0 !== C && (b = S), 0 === C && (m = .8 * w.maxFontSize);
                    } else n && C !== y && (M += n), x.textContent = M;
                } else {
                    x.textContent = "-", N += " v-empty-line";
                    var k = x.style;
                    k.fillOpacity = 0, k.strokeOpacity = 0, c && (w = {});
                }
                w && A.push(w), 0 < C && x.setAttribute("dy", b), (0 < C || r) && x.setAttribute("x", s), x.className.baseVal = N, f.appendChild(x), I += M.length + 1;
            }
            if (a) {
                if (c) b = function(t, e, i, n) {
                    if (!Array.isArray(e)) return 0;
                    var r = e.length;
                    if (!r) return 0;
                    for(var o = e[0], a = j(o.maxFontSize, i) || i, s = 0, l = j(n, i), c = 1; c < r; c++)s += j((o = e[c]).lineHeight, i) || l;
                    var u, h = j(o.maxFontSize, i) || i;
                    switch(t){
                        case "middle":
                            u = a / 2 - .15 * h - s / 2;
                            break;
                        case "bottom":
                            u = -0.25 * h - s;
                            break;
                        default:
                        case "top":
                            u = .8 * a;
                    }
                    return u;
                }(o, A, d, g);
                else if ("top" === o) b = "0.8em";
                else {
                    var D;
                    switch(0 < y ? (D = parseFloat(g) || 1, D *= y, P.test(g) || (D /= d)) : D = 0, o){
                        case "middle":
                            b = .3 - D / 2 + "em";
                            break;
                        case "bottom":
                            b = -D - .3 + "em";
                    }
                }
            } else 0 === o ? b = "0em" : o ? b = o : (b = 0, null === this.attr("y") && this.attr("y", m || "0.8em"));
            return f.firstChild.setAttribute("dy", b), this.append(f), this;
        }, e.removeAttr = function(t) {
            var e = L.qualifyAttr(t), i = this.node;
            return e.ns ? i.hasAttributeNS(e.ns, e.local) && i.removeAttributeNS(e.ns, e.local) : i.hasAttribute(t) && i.removeAttribute(t), this;
        }, e.attr = function(t, e) {
            if (L.isUndefined(t)) {
                for(var i = this.node.attributes, n = {}, r = 0; r < i.length; r++)n[i[r].name] = i[r].value;
                return n;
            }
            if (L.isString(t) && L.isUndefined(e)) return this.node.getAttribute(t);
            if ("object" == typeof t) for(var o in t)t.hasOwnProperty(o) && this.setAttribute(o, t[o]);
            else this.setAttribute(t, e);
            return this;
        }, e.normalizePath = function() {
            return "PATH" === this.tagName() && this.attr("d", L.normalizePathData(this.attr("d"))), this;
        }, e.remove = function() {
            return this.node.parentNode && this.node.parentNode.removeChild(this.node), this;
        }, e.empty = function() {
            for(; this.node.firstChild;)this.node.removeChild(this.node.firstChild);
            return this;
        }, e.setAttributes = function(t) {
            for(var e in t)t.hasOwnProperty(e) && this.setAttribute(e, t[e]);
            return this;
        }, e.append = function(t) {
            L.isArray(t) || (t = [
                t
            ]);
            for(var e = 0, i = t.length; e < i; e++)this.node.appendChild(L.toNode(t[e]));
            return this;
        }, e.prepend = function(t) {
            var e = this.node.firstChild;
            return e ? L(e).before(t) : this.append(t);
        }, e.before = function(t) {
            var e = this.node, i = e.parentNode;
            if (i) {
                L.isArray(t) || (t = [
                    t
                ]);
                for(var n = 0, r = t.length; n < r; n++)i.insertBefore(L.toNode(t[n]), e);
            }
            return this;
        }, e.appendTo = function(t) {
            return L.toNode(t).appendChild(this.node), this;
        }, e.svg = function() {
            return this.node instanceof window.SVGSVGElement ? this : L(this.node.ownerSVGElement);
        }, e.tagName = function() {
            return this.node.tagName.toUpperCase();
        }, e.defs = function() {
            var t = this.svg() || this, e = t.node.getElementsByTagName("defs")[0];
            return e ? L(e) : L("defs").appendTo(t);
        }, e.clone = function() {
            var t = L(this.node.cloneNode(!0));
            return t.node.id = L.uniqueId(), t;
        }, e.findOne = function(t) {
            var e = this.node.querySelector(t);
            return e ? L(e) : void 0;
        }, e.find = function(t) {
            var e = [], i = this.node.querySelectorAll(t);
            if (i) for(var n = 0; n < i.length; n++)e.push(L(i[n]));
            return e;
        }, e.children = function() {
            for(var t = this.node.childNodes, e = [], i = 0; i < t.length; i++)1 === t[i].nodeType && e.push(L(t[i]));
            return e;
        }, e.parent = function() {
            return L(this.node.parentNode) || null;
        }, e.index = function() {
            for(var t = 0, e = this.node.previousSibling; e;)1 === e.nodeType && t++, e = e.previousSibling;
            return t;
        }, e.findParentByClass = function(t, e) {
            for(var i = this.node.ownerSVGElement, n = this.node.parentNode; n && n !== e && n !== i;){
                var r = L(n);
                if (r.hasClass(t)) return r;
                n = n.parentNode;
            }
            return null;
        }, e.contains = function(t) {
            var e = this.node, i = L.toNode(t), n = i && i.parentNode;
            return e === n || !!(n && 1 === n.nodeType && 16 & e.compareDocumentPosition(n));
        }, e.toLocalPoint = function(t, e) {
            var i = this.svg().node, n = i.createSVGPoint();
            n.x = t, n.y = e;
            try {
                var r = n.matrixTransform(i.getScreenCTM().inverse()), o = this.getTransformToElement(i).inverse();
            } catch (t1) {
                return n;
            }
            return r.matrixTransform(o);
        }, e.translateCenterToPoint = function(t) {
            var e = this.getBBox({
                target: this.svg()
            }).center();
            return this.translate(t.x - e.x, t.y - e.y), this;
        }, e.translateAndAutoOrient = function(t, e, i) {
            t = new qi(t), e = new qi(e), i || (i = this.svg());
            var n = this.scale();
            this.attr("transform", "");
            var r = this.getBBox({
                target: i
            }).scale(n.sx, n.sy), o = L.createSVGTransform();
            o.setTranslate(-r.x - r.width / 2, -r.y - r.height / 2);
            var a = L.createSVGTransform(), s = t.angleBetween(e, t.clone().offset(1, 0));
            s && a.setRotate(s, 0, 0);
            var l = L.createSVGTransform(), c = t.clone().move(e, r.width / 2);
            l.setTranslate(2 * t.x - c.x, 2 * t.y - c.y);
            var u = this.getTransformToElement(i), h = L.createSVGTransform();
            return h.setMatrix(l.matrix.multiply(a.matrix.multiply(o.matrix.multiply(u.scale(n.sx, n.sy))))), this.attr("transform", L.matrixToTransformString(h.matrix)), this;
        }, e.animateAlongPath = function(t, e) {
            e = L.toNode(e);
            var i = L.ensureId(e), n = L("animateMotion", t), r = L("mpath", {
                "xlink:href": "#" + i
            });
            n.append(r), this.append(n);
            try {
                n.node.beginElement();
            } catch (t1) {
                if ("fake" === document.documentElement.getAttribute("smiling")) {
                    var o = n.node;
                    o.animators = [];
                    var a = o.getAttribute("id");
                    a && (id2anim[a] = o);
                    for(var s = getTargets(o), l = 0, c = s.length; l < c; l++){
                        var u = s[l], h = new Animator(o, u, l);
                        animators.push(h), (o.animators[l] = h).register();
                    }
                }
            }
            return this;
        }, e.hasClass = function(t) {
            return new RegExp("(\\s|^)" + t + "(\\s|$)").test(this.node.getAttribute("class"));
        }, e.addClass = function(t) {
            if (t && !this.hasClass(t)) {
                var e = this.node.getAttribute("class") || "";
                this.node.setAttribute("class", (e + " " + t).trim());
            }
            return this;
        }, e.removeClass = function(t) {
            if (t && this.hasClass(t)) {
                var e = this.node.getAttribute("class").replace(new RegExp("(\\s|^)" + t + "(\\s|$)", "g"), "$2");
                this.node.setAttribute("class", e);
            }
            return this;
        }, e.toggleClass = function(t, e) {
            return (L.isUndefined(e) ? this.hasClass(t) : !e) ? this.removeClass(t) : this.addClass(t), this;
        }, e.sample = function(t) {
            t = t || 1;
            for(var e, i = this.node, n = i.getTotalLength(), r = [], o = 0; o < n;)e = i.getPointAtLength(o), r.push({
                x: e.x,
                y: e.y,
                distance: o
            }), o += t;
            return r;
        }, e.convertToPath = function() {
            var t = L("path");
            t.attr(this.attr());
            var e = this.convertToPathData();
            return e && t.attr("d", e), t;
        }, e.convertToPathData = function() {
            var t = this.tagName();
            switch(t){
                case "PATH":
                    return this.attr("d");
                case "LINE":
                    return L.convertLineToPathData(this.node);
                case "POLYGON":
                    return L.convertPolygonToPathData(this.node);
                case "POLYLINE":
                    return L.convertPolylineToPathData(this.node);
                case "ELLIPSE":
                    return L.convertEllipseToPathData(this.node);
                case "CIRCLE":
                    return L.convertCircleToPathData(this.node);
                case "RECT":
                    return L.convertRectToPathData(this.node);
            }
            throw new Error(t + " cannot be converted to PATH.");
        }, L.prototype.toGeometryShape = function() {
            var t, e, i, n, r, o, a, s, l, c, u, h, g, d, f;
            switch(this.tagName()){
                case "RECT":
                    return t = parseFloat(this.attr("x")) || 0, e = parseFloat(this.attr("y")) || 0, i = parseFloat(this.attr("width")) || 0, n = parseFloat(this.attr("height")) || 0, new In(t, e, i, n);
                case "CIRCLE":
                    return r = parseFloat(this.attr("cx")) || 0, o = parseFloat(this.attr("cy")) || 0, a = parseFloat(this.attr("r")) || 0, new ln({
                        x: r,
                        y: o
                    }, a, a);
                case "ELLIPSE":
                    return r = parseFloat(this.attr("cx")) || 0, o = parseFloat(this.attr("cy")) || 0, s = parseFloat(this.attr("rx")) || 0, l = parseFloat(this.attr("ry")) || 0, new ln({
                        x: r,
                        y: o
                    }, s, l);
                case "POLYLINE":
                    return c = L.getPointsFromSvgNode(this), new wn(c);
                case "POLYGON":
                    return 1 < (c = L.getPointsFromSvgNode(this)).length && c.push(c[0]), new wn(c);
                case "PATH":
                    return u = this.attr("d"), Tn.isDataSupported(u) || (u = L.normalizePathData(u)), new Tn(u);
                case "LINE":
                    return h = parseFloat(this.attr("x1")) || 0, d = parseFloat(this.attr("y1")) || 0, g = parseFloat(this.attr("x2")) || 0, f = parseFloat(this.attr("y2")) || 0, new nn({
                        x: h,
                        y: d
                    }, {
                        x: g,
                        y: f
                    });
            }
            return this.getBBox();
        }, e.findIntersection = function(t, e) {
            var i = this.svg().node;
            e = e || i;
            var n = this.getBBox({
                target: e
            }), r = n.center();
            if (n.intersectionWithLineFromCenterToPoint(t)) {
                var o, a = this.tagName();
                if ("RECT" === a) {
                    var s = new In(parseFloat(this.attr("x") || 0), parseFloat(this.attr("y") || 0), parseFloat(this.attr("width")), parseFloat(this.attr("height"))), l = this.getTransformToElement(e), c = L.decomposeMatrix(l), u = i.createSVGTransform();
                    u.setRotate(-c.rotation, r.x, r.y);
                    var h = L.transformRect(s, u.matrix.multiply(l));
                    o = new In(h).intersectionWithLineFromCenterToPoint(t, c.rotation);
                } else if ("PATH" === a || "POLYGON" === a || "POLYLINE" === a || "CIRCLE" === a || "ELLIPSE" === a) {
                    var g, d, f, p, m, I = ("PATH" === a ? this : this.convertToPath()).sample(), v = 1 / 0, A = [];
                    for(g = 0; g < I.length; g++)d = I[g], f = (f = L.createSVGPoint(d.x, d.y)).matrixTransform(this.getTransformToElement(e)), (m = (d = new qi(f)).distance(r) + (p = 1.1 * d.distance(t))) < v ? (v = m, A = [
                        {
                            sample: d,
                            refDistance: p
                        }
                    ]) : m < v + 1 && A.push({
                        sample: d,
                        refDistance: p
                    });
                    A.sort(function(t, e) {
                        return t.refDistance - e.refDistance;
                    }), A[0] && (o = A[0].sample);
                }
                return o;
            }
        }, e.setAttribute = function(t, e) {
            var i = this.node;
            if (null === e) return this.removeAttr(t), this;
            var n = L.qualifyAttr(t);
            return n.ns ? i.setAttributeNS(n.ns, t, e) : "id" === t ? i.id = e : i.setAttribute(t, e), this;
        }, L.createSvgDocument = function(t) {
            if (t) {
                var e = '<svg xmlns="' + T.svg + '" xmlns:xlink="' + T.xlink + '" version="1.1">' + t + "</svg>";
                return L.parseXML(e, {
                    async: !1
                }).documentElement;
            }
            var i = document.createElementNS(T.svg, "svg");
            return i.setAttributeNS(T.xmlns, "xmlns:xlink", T.xlink), i.setAttribute("version", "1.1"), i;
        }, L.createSVGStyle = function(t) {
            return L("style", {
                type: "text/css"
            }, [
                L.createCDATASection(t)
            ]).node;
        }, L.createCDATASection = function(t) {
            return void 0 === t && (t = ""), document.implementation.createDocument(null, "xml", null).createCDATASection(t);
        }, L.idCounter = 0, L.uniqueId = function() {
            return "v-" + ++L.idCounter;
        }, L.toNode = function(t) {
            return L.isV(t) ? t.node : t.nodeName && t || t[0];
        }, L.ensureId = function(t) {
            return (t = L.toNode(t)).id || (t.id = L.uniqueId());
        }, L.sanitizeText = function(t) {
            return (t || "").replace(/ /g, "\xa0");
        }, L.isUndefined = function(t) {
            return void 0 === t;
        }, L.isString = function(t) {
            return "string" == typeof t;
        }, L.isObject = function(t) {
            return t && "object" == typeof t;
        }, L.isArray = Array.isArray, L.parseXML = function(t, e) {
            var i;
            e = e || {};
            try {
                var n = new DOMParser;
                L.isUndefined(e.async) || (n.async = e.async), i = n.parseFromString(t, "text/xml");
            } catch (t1) {
                i = void 0;
            }
            if (!i || i.getElementsByTagName("parsererror").length) throw new Error("Invalid XML: " + t);
            return i;
        }, L.qualifyAttr = function(t) {
            if (-1 === t.indexOf(":")) return {
                ns: null,
                local: t
            };
            var e = t.split(":");
            return {
                ns: T[e[0]],
                local: e[1]
            };
        }, L.transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi, L.transformSeparatorRegex = /[ ,]+/, L.transformationListRegex = /^(\w+)\((.*)\)/, L.transformStringToMatrix = function(t) {
            var e = L.createSVGMatrix(), i = t && t.match(L.transformRegex);
            if (!i) return e;
            for(var n = 0, r = i.length; n < r; n++){
                var o = i[n].match(L.transformationListRegex);
                if (o) {
                    var a, s, l, c, u, h = L.createSVGMatrix(), g = o[2].split(L.transformSeparatorRegex);
                    switch(o[1].toLowerCase()){
                        case "scale":
                            a = parseFloat(g[0]), s = void 0 === g[1] ? a : parseFloat(g[1]), h = h.scaleNonUniform(a, s);
                            break;
                        case "translate":
                            l = parseFloat(g[0]), c = parseFloat(g[1]), h = h.translate(l, c);
                            break;
                        case "rotate":
                            u = parseFloat(g[0]), l = parseFloat(g[1]) || 0, c = parseFloat(g[2]) || 0, h = 0 !== l || 0 !== c ? h.translate(l, c).rotate(u).translate(-l, -c) : h.rotate(u);
                            break;
                        case "skewx":
                            u = parseFloat(g[0]), h = h.skewX(u);
                            break;
                        case "skewy":
                            u = parseFloat(g[0]), h = h.skewY(u);
                            break;
                        case "matrix":
                            h.a = parseFloat(g[0]), h.b = parseFloat(g[1]), h.c = parseFloat(g[2]), h.d = parseFloat(g[3]), h.e = parseFloat(g[4]), h.f = parseFloat(g[5]);
                            break;
                        default:
                            continue;
                    }
                    e = e.multiply(h);
                }
            }
            return e;
        }, L.matrixToTransformString = function(t) {
            return t || (t = !0), "matrix(" + (void 0 !== t.a ? t.a : 1) + "," + (void 0 !== t.b ? t.b : 0) + "," + (void 0 !== t.c ? t.c : 0) + "," + (void 0 !== t.d ? t.d : 1) + "," + (void 0 !== t.e ? t.e : 0) + "," + (void 0 !== t.f ? t.f : 0) + ")";
        }, L.parseTransformString = function(t) {
            var e, i, n;
            if (t) {
                var r = L.transformSeparatorRegex;
                if (0 <= t.trim().indexOf("matrix")) {
                    var o = L.transformStringToMatrix(t), a = L.decomposeMatrix(o);
                    e = [
                        a.translateX,
                        a.translateY
                    ], n = [
                        a.scaleX,
                        a.scaleY
                    ], i = [
                        a.rotation
                    ];
                    var s = [];
                    0 === e[0] && 0 === e[1] || s.push("translate(" + e + ")"), 1 === n[0] && 1 === n[1] || s.push("scale(" + n + ")"), 0 !== i[0] && s.push("rotate(" + i + ")"), t = s.join(" ");
                } else {
                    var l = t.match(/translate\((.*?)\)/);
                    l && (e = l[1].split(r));
                    var c = t.match(/rotate\((.*?)\)/);
                    c && (i = c[1].split(r));
                    var u = t.match(/scale\((.*?)\)/);
                    u && (n = u[1].split(r));
                }
            }
            var h = n && n[0] ? parseFloat(n[0]) : 1;
            return {
                value: t,
                translate: {
                    tx: e && e[0] ? parseInt(e[0], 10) : 0,
                    ty: e && e[1] ? parseInt(e[1], 10) : 0
                },
                rotate: {
                    angle: i && i[0] ? parseInt(i[0], 10) : 0,
                    cx: i && i[1] ? parseInt(i[1], 10) : void 0,
                    cy: i && i[2] ? parseInt(i[2], 10) : void 0
                },
                scale: {
                    sx: h,
                    sy: n && n[1] ? parseFloat(n[1]) : h
                }
            };
        }, L.deltaTransformPoint = function(t, e) {
            return {
                x: e.x * t.a + e.y * t.c + 0,
                y: e.x * t.b + e.y * t.d + 0
            };
        }, L.decomposeMatrix = function(t) {
            var e = L.deltaTransformPoint(t, {
                x: 0,
                y: 1
            }), i = L.deltaTransformPoint(t, {
                x: 1,
                y: 0
            }), n = 180 / p * o(e.y, e.x) - 90, r = 180 / p * o(i.y, i.x);
            return {
                translateX: t.e,
                translateY: t.f,
                scaleX: a(t.a * t.a + t.b * t.b),
                scaleY: a(t.c * t.c + t.d * t.d),
                skewX: n,
                skewY: r,
                rotation: n
            };
        }, L.matrixToScale = function(t) {
            var e, i, n, r;
            return t ? (e = L.isUndefined(t.a) ? 1 : t.a, r = L.isUndefined(t.d) ? 1 : t.d, i = t.b, n = t.c) : e = r = 1, {
                sx: i ? a(e * e + i * i) : e,
                sy: n ? a(n * n + r * r) : r
            };
        }, L.matrixToRotate = function(t) {
            var e = {
                x: 0,
                y: 1
            };
            return t && (e = L.deltaTransformPoint(t, e)), {
                angle: Ti(zi(o(e.y, e.x)) - 90)
            };
        }, L.matrixToTranslate = function(t) {
            return {
                tx: t && t.e || 0,
                ty: t && t.f || 0
            };
        }, L.isV = function(t) {
            return t instanceof L;
        }, L.isVElement = L.isV, L.isSVGGraphicsElement = function(t) {
            return !!t && (t = L.toNode(t)) instanceof SVGElement && "function" == typeof t.getScreenCTM;
        };
        var d = L("svg").node;
        return L.createSVGMatrix = function(t) {
            var e = d.createSVGMatrix();
            for(var i in t)e[i] = t[i];
            return e;
        }, L.createSVGTransform = function(t) {
            return L.isUndefined(t) ? d.createSVGTransform() : (t instanceof SVGMatrix || (t = L.createSVGMatrix(t)), d.createSVGTransformFromMatrix(t));
        }, L.createSVGPoint = function(t, e) {
            var i = d.createSVGPoint();
            return i.x = t, i.y = e, i;
        }, L.transformRect = function(t, e) {
            var i = d.createSVGPoint();
            i.x = t.x, i.y = t.y;
            var n = i.matrixTransform(e);
            i.x = t.x + t.width, i.y = t.y;
            var r = i.matrixTransform(e);
            i.x = t.x + t.width, i.y = t.y + t.height;
            var o = i.matrixTransform(e);
            i.x = t.x, i.y = t.y + t.height;
            var a = i.matrixTransform(e), s = h(n.x, r.x, o.x, a.x), l = g(n.x, r.x, o.x, a.x), c = h(n.y, r.y, o.y, a.y), u = g(n.y, r.y, o.y, a.y);
            return new In(s, c, l - s, u - c);
        }, L.transformPoint = function(t, e) {
            return new qi(L.createSVGPoint(t.x, t.y).matrixTransform(e));
        }, L.transformLine = function(t, e) {
            return new nn(L.transformPoint(t.start, e), L.transformPoint(t.end, e));
        }, L.transformPolyline = function(t, e) {
            var i = t instanceof wn ? t.points : t;
            L.isArray(i) || (i = []);
            for(var n = [], r = 0, o = i.length; r < o; r++)n[r] = L.transformPoint(i[r], e);
            return new wn(n);
        }, L.styleToObject = function(t) {
            for(var e = {}, i = t.split(";"), n = 0; n < i.length; n++){
                var r = i[n].split("=");
                e[r[0].trim()] = r[1].trim();
            }
            return e;
        }, L.createSlicePathData = function(t, e, i, n) {
            var r = 2 * p - 1e-6, o = t, a = e, s = i, l = n, c = (l < s && (c = s, s = l, l = c), l - s), u = c < p ? "0" : "1", h = m(s), g = I(s), d = m(l), f = I(l);
            return r <= c ? o ? "M0," + a + "A" + a + "," + a + " 0 1,1 0," + -a + "A" + a + "," + a + " 0 1,1 0," + a + "M0," + o + "A" + o + "," + o + " 0 1,0 0," + -o + "A" + o + "," + o + " 0 1,0 0," + o + "Z" : "M0," + a + "A" + a + "," + a + " 0 1,1 0," + -a + "A" + a + "," + a + " 0 1,1 0," + a + "Z" : o ? "M" + a * h + "," + a * g + "A" + a + "," + a + " 0 " + u + ",1 " + a * d + "," + a * f + "L" + o * d + "," + o * f + "A" + o + "," + o + " 0 " + u + ",0 " + o * h + "," + o * g + "Z" : "M" + a * h + "," + a * g + "A" + a + "," + a + " 0 " + u + ",1 " + a * d + "," + a * f + "L0,0Z";
        }, L.mergeAttrs = function(t, e) {
            for(var i in e)"class" === i ? t[i] = t[i] ? t[i] + " " + e[i] : e[i] : "style" === i ? L.isObject(t[i]) && L.isObject(e[i]) ? t[i] = L.mergeAttrs(t[i], e[i]) : L.isObject(t[i]) ? t[i] = L.mergeAttrs(t[i], L.styleToObject(e[i])) : L.isObject(e[i]) ? t[i] = L.mergeAttrs(L.styleToObject(t[i]), e[i]) : t[i] = L.mergeAttrs(L.styleToObject(t[i]), L.styleToObject(e[i])) : t[i] = e[i];
            return t;
        }, L.annotateString = function(t, e, i) {
            e = e || [];
            for(var n, r, o, a = (i = i || {}).offset || 0, s = [], l = [], c = 0; c < t.length; c++){
                r = l[c] = t[c];
                for(var u = 0; u < e.length; u++){
                    var h = e[u], g = h.start + a, d = h.end + a;
                    g <= c && c < d && (L.isObject(r) ? r.attrs = L.mergeAttrs(L.mergeAttrs({}, r.attrs), h.attrs) : r = l[c] = {
                        t: t[c],
                        attrs: h.attrs
                    }, i.includeAnnotationIndices && (r.annotations || (r.annotations = [])).push(u));
                }
                (o = l[c - 1]) ? L.isObject(r) && L.isObject(o) ? JSON.stringify(r.attrs) === JSON.stringify(o.attrs) ? n.t += r.t : (s.push(n), n = r) : n = L.isObject(r) ? (s.push(n), r) : L.isObject(o) ? (s.push(n), r) : (n || "") + r : n = r;
            }
            return n && s.push(n), s;
        }, L.findAnnotationsAtIndex = function(t, e) {
            var i = [];
            return t && t.forEach(function(t) {
                t.start < e && e <= t.end && i.push(t);
            }), i;
        }, L.findAnnotationsBetweenIndexes = function(t, e, i) {
            var n = [];
            return t && t.forEach(function(t) {
                (e >= t.start && e < t.end || i > t.start && i <= t.end || t.start >= e && t.end < i) && n.push(t);
            }), n;
        }, L.shiftAnnotations = function(t, e, i) {
            return t && t.forEach(function(t) {
                t.start < e && t.end >= e ? t.end += i : t.start >= e && (t.start += i, t.end += i);
            }), t;
        }, L.convertLineToPathData = function(t) {
            return [
                "M",
                (t = L(t)).attr("x1"),
                t.attr("y1"),
                "L",
                t.attr("x2"),
                t.attr("y2")
            ].join(" ");
        }, L.convertPolygonToPathData = function(t) {
            var e = L.getPointsFromSvgNode(t);
            return 0 === e.length ? null : L.svgPointsToPath(e) + " Z";
        }, L.convertPolylineToPathData = function(t) {
            var e = L.getPointsFromSvgNode(t);
            return 0 === e.length ? null : L.svgPointsToPath(e);
        }, L.svgPointsToPath = function(t) {
            for(var e = 0, i = t.length; e < i; e++)t[e] = t[e].x + " " + t[e].y;
            return "M " + t.join(" L");
        }, L.getPointsFromSvgNode = function(t) {
            var e = [], i = (t = L.toNode(t)).points;
            if (i) for(var n = 0, r = i.numberOfItems; n < r; n++)e.push(i.getItem(n));
            return e;
        }, L.KAPPA = .551784, L.convertCircleToPathData = function(t) {
            t = L(t);
            var e = parseFloat(t.attr("cx")) || 0, i = parseFloat(t.attr("cy")) || 0, n = parseFloat(t.attr("r")), r = n * L.KAPPA;
            return [
                "M",
                e,
                i - n,
                "C",
                e + r,
                i - n,
                e + n,
                i - r,
                e + n,
                i,
                "C",
                e + n,
                i + r,
                e + r,
                i + n,
                e,
                i + n,
                "C",
                e - r,
                i + n,
                e - n,
                i + r,
                e - n,
                i,
                "C",
                e - n,
                i - r,
                e - r,
                i - n,
                e,
                i - n,
                "Z"
            ].join(" ");
        }, L.convertEllipseToPathData = function(t) {
            t = L(t);
            var e = parseFloat(t.attr("cx")) || 0, i = parseFloat(t.attr("cy")) || 0, n = parseFloat(t.attr("rx")), r = parseFloat(t.attr("ry")) || n, o = n * L.KAPPA, a = r * L.KAPPA;
            return [
                "M",
                e,
                i - r,
                "C",
                e + o,
                i - r,
                e + n,
                i - a,
                e + n,
                i,
                "C",
                e + n,
                i + a,
                e + o,
                i + r,
                e,
                i + r,
                "C",
                e - o,
                i + r,
                e - n,
                i + a,
                e - n,
                i,
                "C",
                e - n,
                i - a,
                e - o,
                i - r,
                e,
                i - r,
                "Z"
            ].join(" ");
        }, L.convertRectToPathData = function(t) {
            return t = L(t), L.rectToPath({
                x: parseFloat(t.attr("x")) || 0,
                y: parseFloat(t.attr("y")) || 0,
                width: parseFloat(t.attr("width")) || 0,
                height: parseFloat(t.attr("height")) || 0,
                rx: parseFloat(t.attr("rx")) || 0,
                ry: parseFloat(t.attr("ry")) || 0
            });
        }, L.rectToPath = function(t) {
            var e = t.x, i = t.y, n = t.width, r = t.height, o = h(t.rx || t["top-rx"] || 0, n / 2), a = h(t.rx || t["bottom-rx"] || 0, n / 2), s = h(t.ry || t["top-ry"] || 0, r / 2), l = h(t.ry || t["bottom-ry"] || 0, r / 2);
            return (o || a || s || l ? [
                "M",
                e,
                i + s,
                "v",
                r - s - l,
                "a",
                a,
                l,
                0,
                0,
                0,
                a,
                l,
                "h",
                n - 2 * a,
                "a",
                a,
                l,
                0,
                0,
                0,
                a,
                -l,
                "v",
                -(r - l - s),
                "a",
                o,
                s,
                0,
                0,
                0,
                -o,
                -s,
                "h",
                -(n - 2 * o),
                "a",
                o,
                s,
                0,
                0,
                0,
                -o,
                s,
                "Z"
            ] : [
                "M",
                e,
                i,
                "H",
                e + n,
                "V",
                i + r,
                "H",
                e,
                "V",
                i,
                "Z"
            ]).join(" ");
        }, L.normalizePathData = function() {
            var t = "	\n\v\f\r \xa0·öÄ·†é‚ÄÄ‚ÄÅ‚ÄÇ‚ÄÉ‚ÄÑ‚ÄÖ‚ÄÜ‚Äá‚Äà‚Äâ‚Ää‚ÄØ‚Åü„ÄÄ\u2028\u2029", p = new RegExp("([a-z])[" + t + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + t + "]*,?[" + t + "]*)+)", "ig"), m = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + t + "]*,?[" + t + "]*", "ig"), e = Math, U = e.PI, F = e.sin, V = e.cos, X = e.tan, H = e.asin, J = e.sqrt, _ = e.abs;
            function g(t, e, i, n, r, o) {
                return [
                    1 / 3 * t + 2 / 3 * i,
                    1 / 3 * e + 2 / 3 * n,
                    1 / 3 * r + 2 / 3 * i,
                    1 / 3 * o + 2 / 3 * n,
                    r,
                    o
                ];
            }
            function Q(t, e, i) {
                return {
                    x: t * V(i) - e * F(i),
                    y: t * F(i) + e * V(i)
                };
            }
            function d(t) {
                if (Array.isArray(t) && Array.isArray(t && t[0]) || (t = function(t) {
                    if (!t) return null;
                    var o = {
                        a: 7,
                        c: 6,
                        h: 1,
                        l: 2,
                        m: 2,
                        q: 4,
                        s: 4,
                        t: 2,
                        v: 1,
                        z: 0
                    }, a = [];
                    return String(t).replace(p, function(t, e, i) {
                        var n = [], r = e.toLowerCase();
                        for(i.replace(m, function(t, e) {
                            e && n.push(+e);
                        }), "m" === r && 2 < n.length && (a.push([
                            e
                        ].concat(n.splice(0, 2))), r = "l", e = "m" === e ? "l" : "L"); n.length >= o[r] && (a.push([
                            e
                        ].concat(n.splice(0, o[r]))), o[r]););
                    }), a;
                }(t)), !t || !t.length) return [
                    [
                        "M",
                        0,
                        0
                    ]
                ];
                for(var e, i = [], n = 0, r = 0, o = 0, a = 0, s = t.length, l = 0; l < s; l++){
                    var c = [];
                    i.push(c);
                    var u, h, g = t[l];
                    if ((e = g[0]) != e.toUpperCase()) switch(c[0] = e.toUpperCase(), c[0]){
                        case "A":
                            c[1] = g[1], c[2] = g[2], c[3] = g[3], c[4] = g[4], c[5] = g[5], c[6] = +g[6] + n, c[7] = +g[7] + r;
                            break;
                        case "V":
                            c[1] = +g[1] + r;
                            break;
                        case "H":
                            c[1] = +g[1] + n;
                            break;
                        case "M":
                            for(o = +g[1] + n, a = +g[2] + r, u = g.length, h = 1; h < u; h++)c[h] = +g[h] + (h % 2 ? n : r);
                            break;
                        default:
                            for(u = g.length, h = 1; h < u; h++)c[h] = +g[h] + (h % 2 ? n : r);
                    }
                    else for(var d = g.length, f = 0; f < d; f++)c[f] = g[f];
                    switch(c[0]){
                        case "Z":
                            n = +o, r = +a;
                            break;
                        case "H":
                            n = c[1];
                            break;
                        case "V":
                            r = c[1];
                            break;
                        case "M":
                            o = c[c.length - 2], a = c[c.length - 1], n = c[c.length - 2], r = c[c.length - 1];
                            break;
                        default:
                            n = c[c.length - 2], r = c[c.length - 1];
                    }
                }
                return i;
            }
            function i(t) {
                var n = d(t), e = {
                    x: 0,
                    y: 0,
                    bx: 0,
                    by: 0,
                    X: 0,
                    Y: 0,
                    qx: null,
                    qy: null
                };
                function i(t, e, i) {
                    var n, r;
                    if (!t) return [
                        "C",
                        e.x,
                        e.y,
                        e.x,
                        e.y,
                        e.x,
                        e.y
                    ];
                    switch(t[0] in {
                        T: 1,
                        Q: 1
                    } || (e.qx = null, e.qy = null), t[0]){
                        case "M":
                            e.X = t[1], e.Y = t[2];
                            break;
                        case "A":
                            t = 0 === parseFloat(t[1]) || 0 === parseFloat(t[2]) ? [
                                "L",
                                t[6],
                                t[7]
                            ] : [
                                "C"
                            ].concat((function t(e, i, n, r, o, a, s, l, c, u) {
                                var h, g = 120 * U / 180, d = U / 180 * (+o || 0), f = [];
                                if (u) b = u[0], N = u[1], y = u[2], w = u[3];
                                else {
                                    e = (h = Q(e, i, -d)).x, i = h.y;
                                    var p = (e - (l = (h = Q(l, c, -d)).x)) / 2, m = (i - (c = h.y)) / 2, I = p * p / (n * n) + m * m / (r * r);
                                    1 < I && (n *= I = J(I), r *= I);
                                    var v = n * n, A = r * r, C = (a == s ? -1 : 1) * J(_((v * A - v * m * m - A * p * p) / (v * m * m + A * p * p))), y = C * n * m / r + (e + l) / 2, w = C * -r * p / n + (i + c) / 2, b = H(((i - w) / r).toFixed(9)), N = H(((c - w) / r).toFixed(9));
                                    (b = e < y ? U - b : b) < 0 && (b = 2 * U + b), (N = l < y ? U - N : N) < 0 && (N = 2 * U + N), s && N < b && (b -= 2 * U), !s && b < N && (N -= 2 * U);
                                }
                                var x = N - b;
                                if (_(x) > g) {
                                    var M = N, S = l, k = c;
                                    f = t(l = y + n * V(N = b + g * (s && b < N ? 1 : -1)), c = w + r * F(N), n, r, o, 0, s, S, k, [
                                        N,
                                        M,
                                        y,
                                        w
                                    ]);
                                }
                                x = N - b;
                                var D = V(b), T = F(b), L = V(N), z = F(N), P = X(x / 4), j = 4 / 3 * (n * P), Z = 4 / 3 * (r * P), G = [
                                    e,
                                    i
                                ], B = [
                                    e + j * T,
                                    i - Z * D
                                ], O = [
                                    l + j * z,
                                    c - Z * L
                                ], E = [
                                    l,
                                    c
                                ];
                                if (B[0] = 2 * G[0] - B[0], B[1] = 2 * G[1] - B[1], u) return [
                                    B,
                                    O,
                                    E
                                ].concat(f);
                                for(var R = [], Y = (f = [
                                    B,
                                    O,
                                    E
                                ].concat(f).join().split(",")).length, W = 0; W < Y; W++)R[W] = W % 2 ? Q(f[W - 1], f[W], d).y : Q(f[W], f[W + 1], d).x;
                                return R;
                            }).apply(0, [
                                e.x,
                                e.y
                            ].concat(t.slice(1))));
                            break;
                        case "S":
                            r = "C" === i || "S" === i ? (n = 2 * e.x - e.bx, 2 * e.y - e.by) : (n = e.x, e.y), t = [
                                "C",
                                n,
                                r
                            ].concat(t.slice(1));
                            break;
                        case "T":
                            "Q" === i || "T" === i ? (e.qx = 2 * e.x - e.qx, e.qy = 2 * e.y - e.qy) : (e.qx = e.x, e.qy = e.y), t = [
                                "C"
                            ].concat(g(e.x, e.y, e.qx, e.qy, t[1], t[2]));
                            break;
                        case "Q":
                            e.qx = t[1], e.qy = t[2], t = [
                                "C"
                            ].concat(g(e.x, e.y, t[1], t[2], t[3], t[4]));
                            break;
                        case "H":
                            t = [
                                "L"
                            ].concat(t[1], e.y);
                            break;
                        case "V":
                            t = [
                                "L"
                            ].concat(e.x, t[1]);
                    }
                    return t;
                }
                function r(t, e) {
                    if (7 < t[e].length) {
                        t[e].shift();
                        for(var i = t[e]; i.length;)o[e] = "A", t.splice(e++, 0, [
                            "C"
                        ].concat(i.splice(0, 6)));
                        t.splice(e, 1), l = n.length;
                    }
                }
                for(var o = [], a = "", s = "", l = n.length, c = 0; c < l; c++){
                    n[c] && (a = n[c][0]), "C" !== a && (o[c] = a, 0 < c && (s = o[c - 1])), n[c] = i(n[c], e, s), "A" !== o[c] && "C" === a && (o[c] = "C"), r(n, c);
                    var u = n[c], h = u.length;
                    e.x = u[h - 2], e.y = u[h - 1], e.bx = parseFloat(u[h - 4]) || e.x, e.by = parseFloat(u[h - 3]) || e.y;
                }
                return n[0][0] && "M" === n[0][0] || n.unshift([
                    "M",
                    0,
                    0
                ]), n;
            }
            return function(t) {
                return i(t).join(",").split(",").join(" ");
            };
        }(), L.namespace = T, L.g = yr, L;
    }(), br = {
        useCSSSelectors: !0,
        classNamePrefix: "joint-",
        defaultTheme: "default",
        doubleTapInterval: 300
    }, Nr = function(t) {
        return t ? t.toString().split(" ").map(function(t) {
            return t.substr(0, br.classNamePrefix.length) !== br.classNamePrefix && (t = br.classNamePrefix + t), t;
        }).join(" ") : t;
    }, xr = function(t) {
        return t ? t.toString().split(" ").map(function(t) {
            return t.substr(0, br.classNamePrefix.length) === br.classNamePrefix && (t = t.substr(br.classNamePrefix.length)), t;
        }).join(" ") : t;
    }, Mr = function(t, e) {
        for(var i = {}, n = {}, r = wr.namespace.svg, o = e || r, a = document.createDocumentFragment(), s = [
            t,
            a,
            o
        ]; 0 < s.length;){
            o = s.pop();
            for(var l = s.pop(), c = s.pop(), u = 0, h = c.length; u < h; u++){
                var g = c[u];
                if (!g.hasOwnProperty("tagName")) throw new Error("json-dom-parser: missing tagName");
                var d = g.tagName;
                g.hasOwnProperty("namespaceURI") && (o = g.namespaceURI);
                var f = document.createElementNS(o, d), p = o === r, m = p ? wr : S, I = g.attributes;
                I && m(f).attr(I);
                var v = g.style;
                if (v && S(f).css(v), g.hasOwnProperty("className")) {
                    var A = g.className;
                    p ? f.className.baseVal = A : f.className = A;
                }
                if (g.hasOwnProperty("textContent") && (f.textContent = g.textContent), g.hasOwnProperty("selector")) {
                    var C = g.selector;
                    if (i[C]) throw new Error("json-dom-parser: selector must be unique");
                    m(i[C] = f).attr("joint-selector", C);
                }
                if (g.hasOwnProperty("groupSelector")) {
                    var y = g.groupSelector;
                    Array.isArray(y) || (y = [
                        y
                    ]);
                    for(var w = 0, b = y.length; w < b; w++){
                        var N = y[w], x = n[N];
                        x || (x = n[N] = []), x.push(f);
                    }
                }
                l.appendChild(f);
                var M = g.children;
                Array.isArray(M) && s.push(M, f, o);
            }
        }
        return {
            fragment: a,
            selectors: i,
            groupSelectors: n
        };
    }, Sr = function(t) {
        var e = 0;
        if (0 === t.length) return e;
        for(var i = 0; i < t.length; i++)e = (e << 5) - e + t.charCodeAt(i), e &= e;
        return e;
    }, kr = function(t, e, i) {
        for(var n, r = Array.isArray(e) ? e : e.split(i || "/"), o = 0, a = r.length; o < a;){
            if (n = r[o++], !(Object(t) === t && n in t)) return;
            t = t[n];
        }
        return t;
    }, Dr = function(t, e) {
        return "string" != typeof e && "number" != typeof e && (e = String(e)), ("constructor" !== e || "function" != typeof t[e]) && "__proto__" !== e;
    }, Tr = function(t, e, i, n) {
        for(var r = Array.isArray(e) ? e : e.split(n || "/"), o = r.length - 1, a = t, s = 0; s < o; s++){
            var l = r[s];
            if (!Dr(a, l)) return t;
            a = a[l] || (a[l] = {});
        }
        return a[r[o]] = i, t;
    }, Lr = function(t, e, i) {
        for(var n = Array.isArray(e) ? e : e.split(i || "/"), r = n.length - 1, o = t, a = 0; a < r; a++){
            var s = n[a];
            if (!Dr(o, s)) return t;
            var l = o[s];
            if (!l) return t;
            o = l;
        }
        return delete o[n[r]], t;
    }, zr = function(t, e, i) {
        e = e || "/";
        var n = {};
        for(var r in t)if (t.hasOwnProperty(r)) {
            var o = "object" == typeof t[r];
            if (o && i && i(t[r]) && (o = !1), o) {
                var a = zr(t[r], e, i);
                for(var s in a)a.hasOwnProperty(s) && (n[r + e + s] = a[s]);
            } else n[r] = t[r];
        }
        return n;
    }, Pr = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
            var e = 16 * Math.random() | 0;
            return ("x" === t ? e : 3 & e | 8).toString(16);
        });
    }, jr = function(t) {
        return jr.id = jr.id || 1, t.id = void 0 === t.id ? "j_" + jr.id++ : t.id, t.id;
    }, Zr = function(t) {
        return t.replace(/[A-Z]/g, "-$&").toLowerCase();
    }, Gr = function(t) {
        var e = t, i = t.originalEvent && t.originalEvent.changedTouches && t.originalEvent.changedTouches[0];
        if (i) {
            for(var n in t)void 0 === i[n] && (i[n] = t[n]);
            e = i;
        }
        var r = e.target;
        if (r) {
            var o = r.correspondingUseElement;
            o && (e.target = o);
        }
        return e;
    }, Br = function() {
        var r;
        if ("undefined" != typeof window && (r = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame), !r) {
            var o = 0;
            r = function(t) {
                var e = (new Date).getTime(), i = Math.max(0, 16 - (e - o)), n = setTimeout(function() {
                    t(e + i);
                }, i);
                return o = e + i, n;
            };
        }
        return function(t, e) {
            for(var i = [], n = arguments.length - 2; 0 < n--;)i[n] = arguments[n + 2];
            return r(void 0 !== e ? t.bind.apply(t, [
                e
            ].concat(i)) : t);
        };
    }(), Or = ((Cr = "undefined" != typeof window) && (Ar = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame), Ar = Ar || clearTimeout, Cr ? Ar.bind(window) : Ar), Er = function(t) {
        return Go(t) && "%" === t.slice(-1);
    }, Rr = function(t, e) {
        var i = parseFloat(t);
        if (Number.isNaN(i)) return null;
        var n, r = {};
        if (r.value = i, null == e) n = "[A-Za-z]*";
        else if (Array.isArray(e)) {
            if (0 === e.length) return null;
            n = e.join("|");
        } else Go(e) && (n = e);
        var o, a = (o = new RegExp("(?:\\d+(?:\\.\\d+)*)(" + n + ")$").exec(t)) ? o[1] : null;
        return null === a ? null : (r.unit = a, r);
    }, Yr = function(t, e, i, n) {
        void 0 === i && (i = {}), void 0 === n && (n = {});
        var r = e.width, o = e.height, a = n.svgDocument || wr("svg").node, s = wr("tspan").node, l = wr("text").attr(i).append(s).node, c = document.createTextNode("");
        l.style.opacity = 0, l.style.display = "block", s.style.display = "block", s.appendChild(c), a.appendChild(l), n.svgDocument || document.body.appendChild(a);
        var u = n.separator || " ", h = n.eol || "\n", g = n.hyphen ? new RegExp(n.hyphen) : /[^\w\d]/, d = n.maxLineCount;
        Zo(d) || (d = 1 / 0);
        for(var f, p, m, I = t.split(u), v = [], A = [], C = 0, y = 0, w = I.length; C < w; C++){
            var b = I[C];
            if (b) {
                var N = !1;
                if (h && 0 <= b.indexOf(h)) {
                    if (1 < b.length) {
                        for(var x = b.split(h), M = 0, S = x.length - 1; M < S; M++)x.splice(2 * M + 1, 0, h);
                        I.splice.apply(I, [
                            C,
                            1
                        ].concat(x.filter(function(t) {
                            return "" !== t;
                        }))), C--, w = I.length;
                        continue;
                    }
                    N = (A[++y] = "", true);
                }
                if (!N) {
                    if (c.data = A[y] ? A[y] + " " + b : b, s.getComputedTextLength() <= r) A[y] = c.data, (f || p) && (v[y++] = !0, p = f = 0);
                    else {
                        if (!A[y] || f) {
                            var k = !!f;
                            if (f = b.length - 1, k || !f) {
                                if (!f) {
                                    if (!A[y]) {
                                        A = [];
                                        break;
                                    }
                                    I.splice(C, 2, b + I[C + 1]), w--, v[y++] = !0, C--;
                                    continue;
                                }
                                I[C] = b.substring(0, f), I[C + 1] = b.substring(f) + (void 0 === I[C + 1] ? "" : I[C + 1]);
                            } else {
                                if (p) I.splice(C, 2, I[C] + I[C + 1]), p = 0;
                                else {
                                    var D = b.search(g);
                                    -1 < D && D !== b.length - 1 && 0 !== D && (p = D + 1, f = 0), I.splice(C, 1, b.substring(0, p || f), b.substring(p || f)), w++;
                                }
                                y && !v[y - 1] && y--;
                            }
                            C--;
                            continue;
                        }
                        y++, C--;
                    }
                }
                var T = null;
                if (A.length > d) T = d - 1;
                else if (void 0 !== o) {
                    var L;
                    if (void 0 === m) m = (L = "auto" === i.lineHeight ? {
                        value: 1.5,
                        unit: "em"
                    } : Rr(i.lineHeight, [
                        "em"
                    ]) || {
                        value: 1,
                        unit: "em"
                    }).value, "em" === L.unit && (m *= l.getBBox().height);
                    m * A.length > o && (T = Math.floor(o / m) - 1);
                }
                if (null !== T) {
                    A.splice(T + 1);
                    var z = n.ellipsis;
                    if (!z || T < 0) break;
                    "string" != typeof z && (z = "‚Ä¶");
                    var P = A[T];
                    if (!P && !N) break;
                    var j, Z, G = P.length;
                    do {
                        if (Z = P[G], j = P.substring(0, G), Z ? Z.match(u) && (j += Z) : j += "string" == typeof u ? u : " ", j += z, c.data = j, s.getComputedTextLength() <= r) {
                            A[T] = j;
                            break;
                        }
                        G--;
                    }while (0 <= G);
                    break;
                }
            }
        }
        return n.svgDocument ? a.removeChild(l) : document.body.removeChild(a), A.join(h);
    }, Wr = function(t) {
        var e = S(S.parseHTML("<div>" + t + "</div>", null, !1));
        return e.find("*").each(function() {
            var i = this;
            S.each(i.attributes, function() {
                var t = this.name, e = this.value;
                (t.startsWith("on") || e.startsWith("javascript:") || e.startsWith("data:") || e.startsWith("vbscript:")) && S(i).removeAttr(t);
            });
        }), e.html();
    }, Ur = function(t, e) {
        if (window.navigator.msSaveBlob) window.navigator.msSaveBlob(t, e);
        else {
            var i = window.URL.createObjectURL(t), n = document.createElement("a");
            n.href = i, n.download = e, document.body.appendChild(n), n.click(), document.body.removeChild(n), window.URL.revokeObjectURL(i);
        }
    }, Fr = function(t) {
        t = t.replace(/\s/g, "");
        var e, i = (t = decodeURIComponent(t)).indexOf(","), n = t.slice(0, i), r = n.split(":")[1].split(";")[0], o = t.slice(i + 1);
        e = 0 <= n.indexOf("base64") ? atob(o) : unescape(encodeURIComponent(o));
        for(var a = new Uint8Array(e.length), s = 0; s < e.length; s++)a[s] = e.charCodeAt(s);
        return new Blob([
            a
        ], {
            type: r
        });
    }, Vr = function(t, e) {
        var i = S(t), n = i.map(function() {
            var t = this.parentNode, e = t.insertBefore(document.createTextNode(""), this.nextSibling);
            return function() {
                if (t === this) throw new Error("You can't sort elements if any one is a descendant of another.");
                t.insertBefore(this, e), t.removeChild(e);
            };
        });
        return Array.prototype.sort.call(i, e).each(function(t) {
            n[t].call(this);
        });
    }, Xr = function(t) {
        if (Object(t) === t) return e = i = n = r = 0, isFinite(t.vertical) && (e = n = +t.vertical), isFinite(t.horizontal) && (i = r = +t.horizontal), isFinite(t.top) && (e = +t.top), isFinite(t.right) && (i = +t.right), isFinite(t.bottom) && (n = +t.bottom), isFinite(t.left) && (r = +t.left), {
            top: e,
            right: i,
            bottom: n,
            left: r
        };
        var e, i, n, r, o = 0;
        return isFinite(t) && (o = +t), {
            top: o,
            right: o,
            bottom: o,
            left: o
        };
    }, Hr = {
        linear: function(t) {
            return t;
        },
        quad: function(t) {
            return t * t;
        },
        cubic: function(t) {
            return t * t * t;
        },
        inout: function(t) {
            if (t <= 0) return 0;
            if (1 <= t) return 1;
            var e = t * t, i = e * t;
            return 4 * (t < .5 ? i : 3 * (t - e) + i - .75);
        },
        exponential: function(t) {
            return Math.pow(2, 10 * (t - 1));
        },
        bounce: function(t) {
            for(var e = 0, i = 1;; e += i, i /= 2)if ((7 - 4 * e) / 11 <= t) {
                var n = (11 - 6 * e - 11 * t) / 4;
                return -n * n + i * i;
            }
        },
        reverse: function(e) {
            return function(t) {
                return 1 - e(1 - t);
            };
        },
        reflect: function(e) {
            return function(t) {
                return .5 * (t < .5 ? e(2 * t) : 2 - e(2 - 2 * t));
            };
        },
        clamp: function(i, n, r) {
            return n = n || 0, r = r || 1, function(t) {
                var e = i(t);
                return e < n ? n : r < e ? r : e;
            };
        },
        back: function(e) {
            return e || (e = 1.70158), function(t) {
                return t * t * ((e + 1) * t - e);
            };
        },
        elastic: function(e) {
            return e || (e = 1.5), function(t) {
                return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * e / 3 * t);
            };
        }
    }, Jr = {
        number: function(e, t) {
            var i = t - e;
            return function(t) {
                return e + i * t;
            };
        },
        object: function(r, o) {
            var a = Object.keys(r);
            return function(t) {
                var e, i, n = {};
                for(e = a.length - 1; -1 != e; e--)n[i = a[e]] = r[i] + (o[i] - r[i]) * t;
                return n;
            };
        },
        hexColor: function(t, e) {
            var i = parseInt(t.slice(1), 16), n = parseInt(e.slice(1), 16), r = 255 & i, o = (255 & n) - r, a = 65280 & i, s = (65280 & n) - a, l = 16711680 & i, c = (16711680 & n) - l;
            return function(t) {
                return "#" + (16777216 | r + o * t & 255 | a + s * t & 65280 | l + c * t & 16711680).toString(16).slice(1);
            };
        },
        unit: function(e, t) {
            var i = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/, n = i.exec(e), r = i.exec(t), o = r[1].indexOf("."), a = 0 < o ? r[1].length - o - 1 : 0;
            e = +n[1];
            var s = +r[1] - e, l = n[2];
            return function(t) {
                return (e + s * t).toFixed(a) + l;
            };
        }
    }, _r = {
        outline: function(t) {
            var e = Number.isFinite(t.margin) ? t.margin : 2, i = Number.isFinite(t.width) ? t.width : 1;
            return Kr('<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" /><feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" /><feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/><feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/><feMerge><feMergeNode in="outline"/><feMergeNode in="SourceGraphic"/></feMerge></filter>')({
                color: t.color || "blue",
                opacity: Number.isFinite(t.opacity) ? t.opacity : 1,
                outerRadius: e + i,
                innerRadius: e
            });
        },
        highlight: function(t) {
            return Kr('<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/><feComposite result="composed" in="colored" in2="morphed" operator="in"/><feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/><feBlend in="SourceGraphic" in2="blured" mode="normal"/></filter>')({
                color: t.color || "red",
                width: Number.isFinite(t.width) ? t.width : 1,
                blur: Number.isFinite(t.blur) ? t.blur : 0,
                opacity: Number.isFinite(t.opacity) ? t.opacity : 1
            });
        },
        blur: function(t) {
            var e = Number.isFinite(t.x) ? t.x : 2;
            return Kr('<filter><feGaussianBlur stdDeviation="${stdDeviation}"/></filter>')({
                stdDeviation: Number.isFinite(t.y) ? [
                    e,
                    t.y
                ] : e
            });
        },
        dropShadow: function(t) {
            var e = "SVGFEDropShadowElement" in window ? '<filter><feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}"/></filter>' : '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="${opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
            return Kr(e)({
                dx: t.dx || 0,
                dy: t.dy || 0,
                opacity: Number.isFinite(t.opacity) ? t.opacity : 1,
                color: t.color || "black",
                blur: Number.isFinite(t.blur) ? t.blur : 4
            });
        },
        grayscale: function(t) {
            var e = Number.isFinite(t.amount) ? t.amount : 1;
            return Kr('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>')({
                a: .2126 + .7874 * (1 - e),
                b: .7152 - .7152 * (1 - e),
                c: .0722 - .0722 * (1 - e),
                d: .2126 - .2126 * (1 - e),
                e: .7152 + .2848 * (1 - e),
                f: .0722 - .0722 * (1 - e),
                g: .2126 - .2126 * (1 - e),
                h: .0722 + .9278 * (1 - e)
            });
        },
        sepia: function(t) {
            var e = Number.isFinite(t.amount) ? t.amount : 1;
            return Kr('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/></filter>')({
                a: .393 + .607 * (1 - e),
                b: .769 - .769 * (1 - e),
                c: .189 - .189 * (1 - e),
                d: .349 - .349 * (1 - e),
                e: .686 + .314 * (1 - e),
                f: .168 - .168 * (1 - e),
                g: .272 - .272 * (1 - e),
                h: .534 - .534 * (1 - e),
                i: .131 + .869 * (1 - e)
            });
        },
        saturate: function(t) {
            var e = Number.isFinite(t.amount) ? t.amount : 1;
            return Kr('<filter><feColorMatrix type="saturate" values="${amount}"/></filter>')({
                amount: 1 - e
            });
        },
        hueRotate: function(t) {
            return Kr('<filter><feColorMatrix type="hueRotate" values="${angle}"/></filter>')({
                angle: t.angle || 0
            });
        },
        invert: function(t) {
            var e = Number.isFinite(t.amount) ? t.amount : 1;
            return Kr('<filter><feComponentTransfer><feFuncR type="table" tableValues="${amount} ${amount2}"/><feFuncG type="table" tableValues="${amount} ${amount2}"/><feFuncB type="table" tableValues="${amount} ${amount2}"/></feComponentTransfer></filter>')({
                amount: e,
                amount2: 1 - e
            });
        },
        brightness: function(t) {
            return Kr('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}"/><feFuncG type="linear" slope="${amount}"/><feFuncB type="linear" slope="${amount}"/></feComponentTransfer></filter>')({
                amount: Number.isFinite(t.amount) ? t.amount : 1
            });
        },
        contrast: function(t) {
            var e = Number.isFinite(t.amount) ? t.amount : 1;
            return Kr('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}" intercept="${amount2}"/><feFuncG type="linear" slope="${amount}" intercept="${amount2}"/><feFuncB type="linear" slope="${amount}" intercept="${amount2}"/></feComponentTransfer></filter>')({
                amount: e,
                amount2: .5 - e / 2
            });
        }
    }, Qr = {
        number: function(t, e, o) {
            o = o || {
                currency: [
                    "$",
                    ""
                ],
                decimal: ".",
                thousands: ",",
                grouping: [
                    3
                ]
            };
            var i = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i.exec(t), n = i[1] || " ", r = i[2] || ">", a = i[3] || "", s = i[4] || "", l = i[5], c = +i[6], u = i[7], h = i[8], g = i[9], d = 1, f = "", p = "", m = !1;
            switch(h && (h = +h.substring(1)), (l || "0" === n && "=" === r) && (l = n = "0", r = "=", u && (c -= Math.floor((c - 1) / 4))), g){
                case "n":
                    u = !0, g = "g";
                    break;
                case "%":
                    d = 100, p = "%", g = "f";
                    break;
                case "p":
                    d = 100, p = "%", g = "r";
                    break;
                case "b":
                case "o":
                case "x":
                case "X":
                    "#" === s && (f = "0" + g.toLowerCase());
                    break;
                case "c":
                case "d":
                    m = !0, h = 0;
                    break;
                case "s":
                    d = -1, g = "r";
            }
            "$" === s && (f = o.currency[0], p = o.currency[1]), "r" != g || h || (g = "g"), null != h && ("g" == g ? h = Math.max(1, Math.min(21, h)) : "e" != g && "f" != g || (h = Math.max(0, Math.min(20, h))));
            var I = l && u;
            if (m && e % 1) return "";
            var v = e < 0 || 0 === e && 1 / e < 0 ? (e = -e, "-") : a, A = p;
            if (d < 0) {
                var C = this.prefix(e, h);
                e = C.scale(e), A = C.symbol + p;
            } else e *= d;
            var y = (e = this.convert(g, e, h)).lastIndexOf("."), w = y < 0 ? e : e.substring(0, y), b = y < 0 ? "" : o.decimal + e.substring(y + 1);
            function N(t) {
                for(var e = t.length, i = [], n = 0, r = o.grouping[0]; 0 < e && 0 < r;)i.push(t.substring(e -= r, e + r)), r = o.grouping[n = (n + 1) % o.grouping.length];
                return i.reverse().join(o.thousands);
            }
            !l && u && o.grouping && (w = N(w));
            var x = f.length + w.length + b.length + (I ? 0 : v.length), M = x < c ? new Array(x = c - x + 1).join(n) : "";
            return I && (w = N(M + w)), v += f, e = w + b, ("<" === r ? v + e + M : ">" === r ? M + v + e : "^" === r ? M.substring(0, x >>= 1) + v + e + M.substring(x) : v + (I ? e : M + e)) + A;
        },
        string: function(t, e) {
            for(var i, n = "{", r = !1, o = []; -1 !== (i = t.indexOf(n));){
                var a, s, l;
                if (a = t.slice(0, i), r) {
                    l = (s = a.split(":")).shift().split("."), a = e;
                    for(var c = 0; c < l.length; c++)a = a[l[c]];
                    s.length && (a = this.number(s, a));
                }
                o.push(a), t = t.slice(i + 1), n = (r = !r) ? "}" : "{";
            }
            return o.push(t), o.join("");
        },
        convert: function(t, e, i) {
            switch(t){
                case "b":
                    return e.toString(2);
                case "c":
                    return String.fromCharCode(e);
                case "o":
                    return e.toString(8);
                case "x":
                    return e.toString(16);
                case "X":
                    return e.toString(16).toUpperCase();
                case "g":
                    return e.toPrecision(i);
                case "e":
                    return e.toExponential(i);
                case "f":
                    return e.toFixed(i);
                case "r":
                    return (e = this.round(e, this.precision(e, i))).toFixed(Math.max(0, Math.min(20, this.precision(e * (1 + 1e-15), i))));
                default:
                    return e + "";
            }
        },
        round: function(t, e) {
            return e ? Math.round(t * (e = Math.pow(10, e))) / e : Math.round(t);
        },
        precision: function(t, e) {
            return e - (t ? Math.ceil(Math.log(t) / Math.LN10) : 1);
        },
        prefix: function(t, e) {
            var i = [
                "y",
                "z",
                "a",
                "f",
                "p",
                "n",
                "\xb5",
                "m",
                "",
                "k",
                "M",
                "G",
                "T",
                "P",
                "E",
                "Z",
                "Y"
            ].map(function(t, e) {
                var i = Math.pow(10, 3 * Math.abs(8 - e));
                return {
                    scale: 8 < e ? function(t) {
                        return t / i;
                    } : function(t) {
                        return t * i;
                    },
                    symbol: t
                };
            }), n = 0;
            return t && (t < 0 && (t *= -1), e && (t = this.round(t, this.precision(t, e))), n = 1 + Math.floor(1e-12 + Math.log(t) / Math.LN10), n = Math.max(-24, Math.min(24, 3 * Math.floor((n <= 0 ? n + 1 : n - 1) / 3)))), i[8 + n / 3];
        }
    }, Kr = function(t) {
        var e = /<%= ([^ ]+) %>|\$\{ ?([^{} ]+) ?\}|\{\{([^{} ]+)\}\}/g;
        return function(n) {
            return n = n || {}, t.replace(e, function(t) {
                for(var e = Array.from(arguments).slice(1, 4).find(function(t) {
                    return !!t;
                }).split("."), i = n[e.shift()]; void 0 !== i && e.length;)i = i[e.shift()];
                return void 0 !== i ? i : "";
            });
        };
    }, qr = i.assign, $r = i.defaults, to = qr, eo = i.defaultsDeep, io = i.assign, no = i.defaults, ro = i.defaultsDeep, oo = i.invokeMap || i.invoke, ao = i.sortedIndexBy || i.sortedIndex, so = i.uniqBy || i.uniq, lo = i.clone, co = i.cloneDeep, uo = i.isEmpty, ho = i.isEqual, go = i.isFunction, fo = i.isPlainObject, po = i.toArray, mo = i.debounce, Io = i.groupBy, vo = i.sortBy, Ao = i.flattenDeep, Co = i.without, yo = i.difference, wo = i.intersection, bo = i.union, No = i.has, xo = i.result, Mo = i.omit, So = i.pick, ko = i.bindAll, Do = i.forIn, To = i.camelCase, Lo = i.uniqueId, zo = function() {
        if (i.mergeWith) {
            var t = Array.from(arguments), e = t[t.length - 1], n = go(e) ? e : Bo;
            return t.push(function(t, e) {
                var i = n(t, e);
                return void 0 !== i ? i : Array.isArray(t) && !Array.isArray(e) ? e : void 0;
            }), i.mergeWith.apply(this, t);
        }
        return i.merge.apply(this, arguments);
    }, Po = function(t) {
        var e = Object.prototype.toString;
        return !0 === t || !1 === t || !!t && "object" == typeof t && "[object Boolean]" === e.call(t);
    }, jo = function(t) {
        return !!t && ("object" == typeof t || "function" == typeof t);
    }, Zo = function(t) {
        var e = Object.prototype.toString;
        return "number" == typeof t || !!t && "object" == typeof t && "[object Number]" === e.call(t);
    }, Go = function(t) {
        var e = Object.prototype.toString;
        return "string" == typeof t || !!t && "object" == typeof t && "[object String]" === e.call(t);
    }, Bo = function() {};
    function Oo(t) {
        t = so(t);
        var a = po(t).reduce(function(t, e) {
            return t[e.id] = e.clone(), t;
        }, {});
        return po(t).forEach(function(t) {
            var e = a[t.id];
            if (e.isLink()) {
                var i = e.source(), n = e.target();
                i.id && a[i.id] && e.prop("source/id", a[i.id].id), n.id && a[n.id] && e.prop("target/id", a[n.id].id);
            }
            var r = t.get("parent");
            r && a[r] && e.set("parent", a[r].id);
            var o = po(t.get("embeds")).reduce(function(t, e) {
                return a[e] && t.push(a[e].id), t;
            }, []);
            uo(o) || e.set("embeds", o);
        }), a;
    }
    var Eo = {
        x: "x",
        y: "y",
        width: "w",
        height: "h",
        minimum: "s",
        maximum: "l",
        diagonal: "d"
    }, Ro = Object.keys(Eo).map(function(t) {
        return Eo[t];
    }).join(""), Yo = "[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?", Wo = /\s/g, Uo = new RegExp("^(" + Yo + "\\*)?([" + Ro + "])([-+]{1,2}" + Yo + ")?$", "g");
    function Fo(t) {
        throw new Error("Invalid calc() expression: " + t);
    }
    function Vo(t, e) {
        var i = Uo.exec(t.replace(Wo, ""));
        i || Fo(t), Uo.lastIndex = 0;
        var n = i[1];
        void 0 === n && (n = 1);
        var r = i[2], o = i[3];
        void 0 === o && (o = 0);
        var a = e.x, s = e.y, l = e.width, c = e.height, u = 0;
        switch(r){
            case Eo.width:
                u = l;
                break;
            case Eo.height:
                u = c;
                break;
            case Eo.x:
                u = a;
                break;
            case Eo.y:
                u = s;
                break;
            case Eo.minimum:
                u = Math.min(c, l);
                break;
            case Eo.maximum:
                u = Math.max(c, l);
                break;
            case Eo.diagonal:
                u = Math.sqrt(c * c + l * l);
        }
        return parseFloat(n) * u + function(t) {
            if (!t) return 0;
            switch(t[0]){
                case "+":
                    return parseFloat(t.substr(1));
                case "-":
                    return -parseFloat(t.substr(1));
            }
            return parseFloat(t);
        }(o);
    }
    function Xo(t) {
        return "string" == typeof t && t.includes("calc");
    }
    var Ho = "calc(", Jo = Ho.length;
    function _o(t, e) {
        for(var i = t, n = 0;;){
            var r = i.indexOf(Ho, n);
            if (-1 === r) return i;
            var o = r + Jo, a = 1;
            t: for(;;){
                switch(i[o]){
                    case "(":
                        a++;
                        break;
                    case ")":
                        if (0 === --a) break t;
                        break;
                    case void 0:
                        Fo(i);
                }
                o++;
            }
            var s = i.slice(r + Jo, o);
            Xo(s) && (s = _o(s, e));
            var l = String(Vo(s, e));
            i = i.slice(0, r) + l + i.slice(o + 1), n = r + l.length;
        }
    }
    function Qo(o, a) {
        return function(t, e) {
            var i = Er(t);
            t = parseFloat(t), i && (t /= 100);
            var n = {};
            if (isFinite(t)) {
                var r = i || 0 <= t && t <= 1 ? t * e[a] : Math.max(t + e[a], 0);
                n[o] = r;
            }
            return n;
        };
    }
    function Ko(a, s, l) {
        return function(t, e) {
            var i, n = Er(t);
            if (t = parseFloat(t), n && (t /= 100), isFinite(t)) {
                var r = e[l]();
                i = n || 0 < t && t < 1 ? r[a] + e[s] * t : r[a] + t;
            }
            var o = qi();
            return o[a] = i || 0, o;
        };
    }
    function qo(r, o, a) {
        return function(t, e) {
            var i;
            i = "middle" === t ? e[o] / 2 : t === a ? e[o] : isFinite(t) ? -1 < t && t < 1 ? -e[o] * t : -t : Er(t) ? e[o] * parseFloat(t) / 100 : 0;
            var n = qi();
            return n[r] = -(e[r] + i), n;
        };
    }
    function $o(d, t) {
        var f = "joint-shape", p = t && t.resetOffset;
        return function(t, e, i) {
            var n = S(i), r = n.data(f);
            if (!r || r.value !== t) {
                var o = d(t);
                r = {
                    value: t,
                    shape: o,
                    shapeBBox: o.bbox()
                }, n.data(f, r);
            }
            var a = r.shape.clone(), s = r.shapeBBox.clone(), l = s.origin(), c = e.origin();
            s.x = c.x, s.y = c.y;
            var u = e.maxRectScaleToFit(s, c), h = 0 === s.width || 0 === e.width ? 1 : u.sx, g = 0 === s.height || 0 === e.height ? 1 : u.sy;
            return a.scale(h, g, l), p && a.translate(-l.x, -l.y), a;
        };
    }
    function ta(t) {
        var n = $o(function(t) {
            return new Tn(wr.normalizePathData(t));
        }, t);
        return function(t, e, i) {
            return {
                d: n(t, e, i).serialize()
            };
        };
    }
    function ea(t) {
        var n = $o(wn, t);
        return function(t, e, i) {
            return {
                points: n(t, e, i).serialize()
            };
        };
    }
    function ia(r, o) {
        var a = new qi(1, 0);
        return function(t) {
            var e, i, n = this[r](t);
            return n ? (i = o.rotate ? n.vector().vectorAngle(a) : 0, e = n.start) : (e = this.path.start, i = 0), 0 === i ? {
                transform: "translate(" + e.x + "," + e.y + ")"
            } : {
                transform: "translate(" + e.x + "," + e.y + ") rotate(" + i + ")"
            };
        };
    }
    function na(r) {
        return function(t, e, i) {
            var n = wr(i);
            n.attr(r) !== t && n.attr(r, t);
        };
    }
    function ra(t, e, i) {
        return void 0 !== i.text;
    }
    function oa() {
        return this.model.isLink();
    }
    function aa(t) {
        var e = {}, i = t.stroke;
        "string" == typeof i && (e.stroke = i, e.fill = i);
        var n = t.strokeOpacity;
        return void 0 === n && (n = t["stroke-opacity"]), void 0 === n && (n = t.opacity), void 0 !== n && (e["stroke-opacity"] = n, e["fill-opacity"] = n), e;
    }
    function sa(t) {
        var e = this.paper;
        return "url(#" + ("pattern" === t.type ? e.definePattern(t) : e.defineGradient(t)) + ")";
    }
    var la, ca, ua = {
        xlinkShow: {
            set: "xlink:show"
        },
        xlinkRole: {
            set: "xlink:role"
        },
        xlinkType: {
            set: "xlink:type"
        },
        xlinkArcrole: {
            set: "xlink:arcrole"
        },
        xlinkTitle: {
            set: "xlink:title"
        },
        xlinkActuate: {
            set: "xlink:actuate"
        },
        xmlSpace: {
            set: "xml:space"
        },
        xmlBase: {
            set: "xml:base"
        },
        xmlLang: {
            set: "xml:lang"
        },
        preserveAspectRatio: {
            set: "preserveAspectRatio"
        },
        requiredExtension: {
            set: "requiredExtension"
        },
        requiredFeatures: {
            set: "requiredFeatures"
        },
        systemLanguage: {
            set: "systemLanguage"
        },
        externalResourcesRequired: {
            set: "externalResourceRequired"
        },
        href: {
            set: na("href")
        },
        xlinkHref: {
            set: na("xlink:href")
        },
        filter: {
            qualify: fo,
            set: function(t) {
                return "url(#" + this.paper.defineFilter(t) + ")";
            }
        },
        fill: {
            qualify: fo,
            set: sa
        },
        stroke: {
            qualify: fo,
            set: sa
        },
        sourceMarker: {
            qualify: fo,
            set: function(t, e, i, n) {
                return t = io(aa(n), t), {
                    "marker-start": "url(#" + this.paper.defineMarker(t) + ")"
                };
            }
        },
        targetMarker: {
            qualify: fo,
            set: function(t, e, i, n) {
                return t = io(aa(n), {
                    transform: "rotate(180)"
                }, t), {
                    "marker-end": "url(#" + this.paper.defineMarker(t) + ")"
                };
            }
        },
        vertexMarker: {
            qualify: fo,
            set: function(t, e, i, n) {
                return t = io(aa(n), t), {
                    "marker-mid": "url(#" + this.paper.defineMarker(t) + ")"
                };
            }
        },
        text: {
            qualify: function(t, e, i) {
                return !i.textWrap || !fo(i.textWrap);
            },
            set: function(t, e, i, n) {
                var r = S(i), o = "joint-text", a = r.data(o), s = So(n, "lineHeight", "annotations", "textPath", "x", "textVerticalAnchor", "eol", "displayEmpty"), l = s.x;
                Xo(l) && (s.x = _o(l, e));
                var c = s.fontSize = n["font-size"] || n.fontSize, u = JSON.stringify([
                    t,
                    s
                ]);
                if (void 0 === a || a !== u) {
                    c && i.setAttribute("font-size", c);
                    var h = s.textPath;
                    if (jo(h)) {
                        var g = h.selector;
                        if ("string" == typeof g) {
                            var d = this.findBySelector(g)[0];
                            d instanceof SVGPathElement && (s.textPath = io({
                                "xlink:href": "#" + d.id
                            }, h));
                        }
                    }
                    wr(i).text("" + t, s), r.data(o, u);
                }
            }
        },
        textWrap: {
            qualify: fo,
            set: function(t, e, i, n) {
                var r = t.width || 0, o = {};
                Er(r) ? o.width = e.width * parseFloat(r) / 100 : o.width = r <= 0 ? e.width + r : r;
                var a, s = t.height || 0;
                Er(s) ? o.height = e.height * parseFloat(s) / 100 : o.height = s <= 0 ? e.height + s : s;
                var l = t.text;
                void 0 === l && (l = n.text), a = void 0 !== l ? Yr("" + l, o, {
                    "font-weight": n["font-weight"] || n.fontWeight,
                    "font-size": n["font-size"] || n.fontSize,
                    "font-family": n["font-family"] || n.fontFamily,
                    lineHeight: n.lineHeight,
                    "letter-spacing": "letter-spacing" in n ? n["letter-spacing"] : n.letterSpacing
                }, {
                    svgDocument: this.paper.svg,
                    ellipsis: t.ellipsis,
                    hyphen: t.hyphen,
                    maxLineCount: t.maxLineCount
                }) : "", ua.text.set.call(this, a, e, i, n);
            }
        },
        title: {
            qualify: function(t, e) {
                return e instanceof SVGElement;
            },
            set: function(t, e, i) {
                var n = S(i), r = "joint-title", o = n.data(r);
                if (void 0 === o || o !== t) {
                    n.data(r, t);
                    var a = i.firstChild;
                    if (a && "TITLE" === a.tagName.toUpperCase()) a.textContent = t;
                    else {
                        var s = document.createElementNS(i.namespaceURI, "title");
                        s.textContent = t, i.insertBefore(s, a);
                    }
                }
            }
        },
        lineHeight: {
            qualify: ra
        },
        textVerticalAnchor: {
            qualify: ra
        },
        textPath: {
            qualify: ra
        },
        annotations: {
            qualify: ra
        },
        eol: {
            qualify: ra
        },
        displayEmpty: {
            qualify: ra
        },
        port: {
            set: function(t) {
                return null === t || void 0 === t.id ? t : t.id;
            }
        },
        style: {
            qualify: fo,
            set: function(t, e, i) {
                S(i).css(t);
            }
        },
        html: {
            set: function(t, e, i) {
                S(i).html(t + "");
            }
        },
        ref: {},
        refX: {
            position: Ko("x", "width", "origin")
        },
        refY: {
            position: Ko("y", "height", "origin")
        },
        refDx: {
            position: Ko("x", "width", "corner")
        },
        refDy: {
            position: Ko("y", "height", "corner")
        },
        refWidth: {
            set: Qo("width", "width")
        },
        refHeight: {
            set: Qo("height", "height")
        },
        refRx: {
            set: Qo("rx", "width")
        },
        refRy: {
            set: Qo("ry", "height")
        },
        refRInscribed: {
            set: (la = Qo("r", "width"), ca = Qo("r", "height"), function(t, e) {
                return (e.height > e.width ? la : ca)(t, e);
            })
        },
        refRCircumscribed: {
            set: function(t, e) {
                var i = Er(t);
                t = parseFloat(t), i && (t /= 100);
                var n, r = Math.sqrt(e.height * e.height + e.width * e.width);
                return isFinite(t) && (n = i || 0 <= t && t <= 1 ? t * r : Math.max(t + r, 0)), {
                    r: n
                };
            }
        },
        refCx: {
            set: Qo("cx", "width")
        },
        refCy: {
            set: Qo("cy", "height")
        },
        xAlignment: {
            offset: qo("x", "width", "right")
        },
        yAlignment: {
            offset: qo("y", "height", "bottom")
        },
        resetOffset: {
            offset: function(t, e) {
                return t ? {
                    x: -e.x,
                    y: -e.y
                } : {
                    x: 0,
                    y: 0
                };
            }
        },
        refDResetOffset: {
            set: ta({
                resetOffset: !0
            })
        },
        refDKeepOffset: {
            set: ta({
                resetOffset: !1
            })
        },
        refPointsResetOffset: {
            set: ea({
                resetOffset: !0
            })
        },
        refPointsKeepOffset: {
            set: ea({
                resetOffset: !1
            })
        },
        connection: {
            qualify: oa,
            set: function(t) {
                var e, i = t.stubs;
                if (void 0 === i && (i = 0), isFinite(i) && 0 !== i) {
                    var n;
                    n = i < 0 ? (this.getConnectionLength() + i) / 2 : i;
                    var r = this.getConnection(), o = r.divideAtLength(n), a = r.divideAtLength(-n);
                    o && a && (e = o[0].serialize() + " " + a[1].serialize());
                }
                return {
                    d: e || this.getSerializedConnection()
                };
            }
        },
        atConnectionLengthKeepGradient: {
            qualify: oa,
            set: ia("getTangentAtLength", {
                rotate: !0
            })
        },
        atConnectionLengthIgnoreGradient: {
            qualify: oa,
            set: ia("getTangentAtLength", {
                rotate: !1
            })
        },
        atConnectionRatioKeepGradient: {
            qualify: oa,
            set: ia("getTangentAtRatio", {
                rotate: !0
            })
        },
        atConnectionRatioIgnoreGradient: {
            qualify: oa,
            set: ia("getTangentAtRatio", {
                rotate: !1
            })
        }
    };
    ua["xlink:href"] = ua.xlinkHref, [
        "transform",
        "d",
        "points",
        "width",
        "height",
        "cx",
        "cy",
        "r",
        "rx",
        "ry",
        "x1",
        "x2",
        "y1",
        "y2",
        "x",
        "y",
        "dx",
        "dy"
    ].forEach(function(n) {
        ua[n] = {
            qualify: Xo,
            set: function(t, e) {
                var i;
                return (i = {})[n] = _o(t, e), i;
            }
        };
    }), ua.refR = ua.refRInscribed, ua.refD = ua.refDResetOffset, ua.refPoints = ua.refPointsResetOffset, ua.atConnectionLength = ua.atConnectionLengthKeepGradient, ua.atConnectionRatio = ua.atConnectionRatioKeepGradient, ua.refX2 = ua.refX, ua.refY2 = ua.refY, ua.refWidth2 = ua.refWidth, ua.refHeight2 = ua.refHeight, ua["ref-x"] = ua.refX, ua["ref-y"] = ua.refY, ua["ref-dy"] = ua.refDy, ua["ref-dx"] = ua.refDx, ua["ref-width"] = ua.refWidth, ua["ref-height"] = ua.refHeight, ua["x-alignment"] = ua.xAlignment, ua["y-alignment"] = ua.yAlignment;
    var ha = ua, ga = s.Model.extend({
        constructor: function(t, e) {
            var i, n = t || {};
            "function" == typeof this.preinitialize && this.preinitialize.apply(this, arguments), this.cid = Lo("c"), this.attributes = {}, e && e.collection && (this.collection = e.collection), e && e.parse && (n = this.parse(n, e) || {}), (i = xo(this, "defaults")) && (n = zo({}, i, n)), this.set(n, e), this.changed = {}, this.initialize.apply(this, arguments);
        },
        translate: function(t, e, i) {
            throw new Error("Must define a translate() method.");
        },
        toJSON: function() {
            var e = xo(this.constructor.prototype, "defaults").attrs || {}, t = this.attributes.attrs, o = {};
            Do(t, function(t, n) {
                var r = e[n];
                Do(t, function(t, i) {
                    jo(t) && !Array.isArray(t) ? Do(t, function(t, e) {
                        r && r[i] && ho(r[i][e], t) || (o[n] = o[n] || {}, (o[n][i] || (o[n][i] = {}))[e] = t);
                    }) : r && ho(r[i], t) || (o[n] = o[n] || {}, o[n][i] = t);
                });
            });
            var i = co(Mo(this.attributes, "attrs"));
            return i.attrs = o, i;
        },
        initialize: function(t) {
            var e = this.getIdAttribute();
            t && e in t || this.set(e, this.generateId(), {
                silent: !0
            }), this._transitionIds = {}, this._scheduledTransitionIds = {}, this.processPorts(), this.on("change:attrs", this.processPorts, this);
        },
        getIdAttribute: function() {
            return this.idAttribute || "id";
        },
        generateId: function() {
            return Pr();
        },
        processPorts: function() {
            var t = this.ports, i = {};
            Do(this.get("attrs"), function(t, e) {
                t && t.port && (void 0 !== t.port.id ? i[t.port.id] = t.port : i[t.port] = {
                    id: t.port
                });
            });
            var n = {};
            (Do(t, function(t, e) {
                i[e] || (n[e] = !0);
            }), this.graph && !uo(n)) && (this.graph.getConnectedLinks(this, {
                inbound: !0
            }).forEach(function(t) {
                n[t.get("target").port] && t.remove();
            }), this.graph.getConnectedLinks(this, {
                outbound: !0
            }).forEach(function(t) {
                n[t.get("source").port] && t.remove();
            }));
            this.ports = i;
        },
        remove: function(t) {
            void 0 === t && (t = {});
            var e = this.graph, i = this.collection;
            if (!e) return i && i.remove(this, t), this;
            e.startBatch("remove");
            var n = this.getParentCell();
            n && n.unembed(this, t);
            for(var r = this.getEmbeddedCells(), o = 0, a = r.length; o < a; o++){
                var s = r[o];
                s && s.remove(t);
            }
            return this.trigger("remove", this, e.attributes.cells, t), e.stopBatch("remove"), this;
        },
        toFront: function(i) {
            var t = this.graph;
            if (t) {
                i = i || {};
                var e, n = t.maxZIndex();
                i.deep ? (e = this.getEmbeddedCells({
                    deep: !0,
                    breadthFirst: !1 !== i.breadthFirst
                })).unshift(this) : e = [
                    this
                ], n = n - e.length + 1;
                var r = t.get("cells"), o = r.indexOf(this) !== r.length - e.length;
                o || (o = e.some(function(t, e) {
                    return t.get("z") !== n + e;
                })), o && (this.startBatch("to-front"), n += e.length, e.forEach(function(t, e) {
                    t.set("z", n + e, i);
                }), this.stopBatch("to-front"));
            }
            return this;
        },
        toBack: function(i) {
            var t = this.graph;
            if (t) {
                i = i || {};
                var e, n = t.minZIndex();
                i.deep ? (e = this.getEmbeddedCells({
                    deep: !0,
                    breadthFirst: !1 !== i.breadthFirst
                })).unshift(this) : e = [
                    this
                ];
                var r = 0 !== t.get("cells").indexOf(this);
                r || (r = e.some(function(t, e) {
                    return t.get("z") !== n + e;
                })), r && (this.startBatch("to-back"), n -= e.length, e.forEach(function(t, e) {
                    t.set("z", n + e, i);
                }), this.stopBatch("to-back"));
            }
            return this;
        },
        parent: function(t, e) {
            return void 0 === t ? this.get("parent") : this.set("parent", t, e);
        },
        embed: function(t, e) {
            var i = Array.isArray(t) ? t : [
                t
            ];
            if (!this.canEmbed(i)) throw new Error("Recursive embedding not allowed.");
            return this._embedCells(i, e), this;
        },
        unembed: function(t, e) {
            var i = Array.isArray(t) ? t : [
                t
            ];
            return this._unembedCells(i, e), this;
        },
        canEmbed: function(t) {
            var e = this;
            return (Array.isArray(t) ? t : [
                t
            ]).every(function(t) {
                return e !== t && !e.isEmbeddedIn(t);
            });
        },
        _embedCells: function(t, e) {
            var i = this;
            this.startBatch("embed");
            var n = io([], this.get("embeds"));
            t.forEach(function(t) {
                n[t.isLink() ? "unshift" : "push"](t.id), t.parent(i.id, e);
            }), this.set("embeds", so(n), e), this.stopBatch("embed");
        },
        _unembedCells: function(t, e) {
            this.startBatch("unembed"), t.forEach(function(t) {
                return t.unset("parent", e);
            }), this.set("embeds", Co.apply(void 0, [
                this.get("embeds")
            ].concat(t.map(function(t) {
                return t.id;
            }))), e), this.stopBatch("unembed");
        },
        getParentCell: function() {
            var t = this.parent(), e = this.graph;
            return t && e && e.getCell(t) || null;
        },
        getAncestors: function() {
            var t = [];
            if (!this.graph) return t;
            for(var e = this.getParentCell(); e;)t.push(e), e = e.getParentCell();
            return t;
        },
        getEmbeddedCells: function(e) {
            if (e = e || {}, this.graph) {
                var i;
                if (e.deep) {
                    if (e.breadthFirst) {
                        i = [];
                        for(var t = this.getEmbeddedCells(); 0 < t.length;){
                            var n = t.shift();
                            i.push(n), t.push.apply(t, n.getEmbeddedCells());
                        }
                    } else (i = this.getEmbeddedCells()).forEach(function(t) {
                        i.push.apply(i, t.getEmbeddedCells(e));
                    });
                } else i = po(this.get("embeds")).map(this.graph.getCell, this.graph);
                return i;
            }
            return [];
        },
        isEmbeddedIn: function(t, e) {
            var i = Go(t) ? t : t.id, n = this.parent();
            if (e = no({
                deep: !0
            }, e), this.graph && e.deep) {
                for(; n;){
                    if (n === i) return !0;
                    n = this.graph.getCell(n).parent();
                }
                return !1;
            }
            return n === i;
        },
        isEmbedded: function() {
            return !!this.parent();
        },
        clone: function(t) {
            if ((t = t || {}).deep) return po(Oo([
                this
            ].concat(this.getEmbeddedCells({
                deep: !0
            }))));
            var e = s.Model.prototype.clone.apply(this, arguments);
            return e.set(this.getIdAttribute(), this.generateId()), e.unset("embeds"), e.unset("parent"), e;
        },
        prop: function(t, e, i) {
            var n = Go(t);
            if (n || Array.isArray(t)) {
                if (1 < arguments.length) {
                    var r, o, a = (o = n ? (r = t).split("/") : (r = t.join("/"), t.slice()))[0], s = o.length;
                    if ((i = i || {}).propertyPath = r, i.propertyValue = e, i.propertyPathArray = o, 1 === s) return this.set(a, e, i);
                    for(var l = {}, c = l, u = a, h = 1; h < s; h++){
                        var g = o[h], d = Number.isFinite(n ? Number(g) : g);
                        c = c[u] = d ? [] : {}, u = g;
                    }
                    l = Tr(l, o, e, "/");
                    var f = zo({}, this.attributes);
                    i.rewrite && Lr(f, r, "/");
                    var p = zo(f, l);
                    return this.set(a, p[a], i);
                }
                return kr(this.attributes, t, "/");
            }
            return this.set(zo({}, this.attributes, t), e);
        },
        removeProp: function(t, e) {
            e = e || {};
            var i = Array.isArray(t) ? t : t.split("/"), n = i[0];
            if ("attrs" === n && (e.dirty = !0), 1 === i.length) return this.unset(t, e);
            var r = i.slice(1), o = co(this.get(n));
            return Lr(o, r, "/"), this.set(n, o, e);
        },
        attr: function(t, e, i) {
            var n = Array.from(arguments);
            return 0 === n.length ? this.get("attrs") : (Array.isArray(t) ? n[0] = [
                "attrs"
            ].concat(t) : Go(t) ? n[0] = "attrs/" + t : n[0] = {
                attrs: t
            }, this.prop.apply(this, n));
        },
        removeAttr: function(t, e) {
            return Array.isArray(t) ? this.removeProp([
                "attrs"
            ].concat(t)) : this.removeProp("attrs/" + t, e);
        },
        transition: function(r, e, o, i) {
            var n = this;
            i = i || "/", o = io({
                duration: 100,
                delay: 10,
                timingFunction: Hr.linear,
                valueFunction: Jr.number
            }, o);
            var a, s, l = 0, c = (function(t) {
                var e, i, n;
                (i = (t -= l = l || t) / o.duration) < 1 ? this._transitionIds[r] = e = Br(c) : (i = 1, delete this._transitionIds[r]), n = a(o.timingFunction(i)), o.transitionId = e, this.prop(r, n, o), e || this.trigger("transition:end", this, r);
            }).bind(this), u = this._scheduledTransitionIds;
            return s = setTimeout(function(t) {
                u[r] && (u[r] = Co(u[r], s), 0 === u[r].length && delete u[r]), n.stopPendingTransitions(r, i), a = o.valueFunction(kr(n.attributes, r, i), e), n._transitionIds[r] = Br(t), n.trigger("transition:start", n, r);
            }, o.delay, c), u[r] || (u[r] = []), u[r].push(s), s;
        },
        getTransitions: function() {
            return bo(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));
        },
        stopScheduledTransitions: function(t, e) {
            void 0 === e && (e = "/");
            var i = this._scheduledTransitionIds;
            void 0 === i && (i = {});
            var n = Object.keys(i);
            if (t) {
                var r = t.split(e);
                n = n.filter(function(t) {
                    return ho(r, t.split(e).slice(0, r.length));
                });
            }
            return n.forEach(function(t) {
                i[t].forEach(function(t) {
                    return clearTimeout(t);
                }), delete i[t];
            }), this;
        },
        stopPendingTransitions: function(t, e) {
            var i = this;
            void 0 === e && (e = "/");
            var n = this._transitionIds;
            void 0 === n && (n = {});
            var r = Object.keys(n);
            if (t) {
                var o = t.split(e);
                r = r.filter(function(t) {
                    return ho(o, t.split(e).slice(0, o.length));
                });
            }
            r.forEach(function(t) {
                var e = n[t];
                Or(e), delete n[t], i.trigger("transition:end", i, t);
            });
        },
        stopTransitions: function(t, e) {
            return void 0 === e && (e = "/"), this.stopScheduledTransitions(t, e), this.stopPendingTransitions(t, e), this;
        },
        addTo: function(t, e) {
            return t.addCell(this, e), this;
        },
        findView: function(t) {
            return t.findViewByModel(this);
        },
        isElement: function() {
            return !1;
        },
        isLink: function() {
            return !1;
        },
        startBatch: function(t, e) {
            return this.graph && this.graph.startBatch(t, io({}, e, {
                cell: this
            })), this;
        },
        stopBatch: function(t, e) {
            return this.graph && this.graph.stopBatch(t, io({}, e, {
                cell: this
            })), this;
        },
        getChangeFlag: function(t) {
            var e = 0;
            if (!t) return e;
            for(var i in t)t.hasOwnProperty(i) && this.hasChanged(i) && (e |= t[i]);
            return e;
        },
        angle: function() {
            return 0;
        },
        position: function() {
            return new qi(0, 0);
        },
        getPointFromConnectedLink: function() {
            return new qi;
        },
        getBBox: function() {
            return new In(0, 0, 0, 0);
        },
        getPointRotatedAroundCenter: function(t, e, i) {
            var n = new qi(e, i);
            return t && n.rotate(this.getBBox().center(), t), n;
        },
        getAbsolutePointFromRelative: function(t, e) {
            return this.getPointRotatedAroundCenter(-this.angle(), this.position().offset(t, e));
        },
        getRelativePointFromAbsolute: function(t, e) {
            return this.getPointRotatedAroundCenter(this.angle(), t, e).difference(this.position());
        }
    }, {
        getAttributeDefinition: function(t) {
            var e = this.attributes, i = ha;
            return e && e[t] || i[t];
        },
        define: function(t, e, i, n) {
            i = io({
                defaults: ro({
                    type: t
                }, e, this.prototype.defaults)
            }, i);
            var r = this.extend(i, n);
            return "undefined" != typeof joint && No(joint, "shapes") && Tr(joint.shapes, t, r, "."), r;
        }
    }), da = function(e, t, i) {
        if (Go(i)) {
            if (!fa[i]) throw new Error('Unknown wrapper: "' + i + '"');
            i = fa[i];
        }
        if (!go(i)) throw new Error("Wrapper must be a function.");
        po(t).forEach(function(t) {
            e[t] = i(e[t]);
        });
    }, fa = {
        cells: function(r) {
            return function() {
                var t = Array.from(arguments), e = t.length, i = 0 < e && t[0] || [], n = 1 < e && t[e - 1] || {};
                return Array.isArray(i) || (n instanceof ga ? i = t : i instanceof ga && (1 < t.length && t.pop(), i = t)), n instanceof ga && (n = {}), r.call(this, i, n);
            };
        }
    }, pa = {
        wrapWith: da,
        wrappers: fa,
        addClassNamePrefix: Nr,
        removeClassNamePrefix: xr,
        parseDOMJSON: Mr,
        hashCode: Sr,
        getByPath: kr,
        setByPath: Tr,
        unsetByPath: Lr,
        flattenObject: zr,
        uuid: Pr,
        guid: jr,
        toKebabCase: Zr,
        normalizeEvent: Gr,
        nextFrame: Br,
        cancelFrame: Or,
        shapePerimeterConnectionPoint: function(t, e, i, n) {
            var r, o;
            if (!i) {
                var a = e.$(".scalable")[0], s = e.$(".rotatable")[0];
                a && a.firstChild ? i = a.firstChild : s && s.firstChild && (i = s.firstChild);
            }
            return i ? (o = wr(i).findIntersection(n, t.paper.cells)) || (r = wr(i).getBBox({
                target: t.paper.cells
            })) : o = (r = e.model.getBBox()).intersectionWithLineFromCenterToPoint(n), o || r.center();
        },
        isPercentage: Er,
        parseCssNumeric: Rr,
        breakText: Yr,
        sanitizeHTML: Wr,
        downloadBlob: Ur,
        downloadDataUri: function(t, e) {
            var i = Fr(t);
            Ur(i, e);
        },
        dataUriToBlob: Fr,
        imageToDataUri: function(r, t) {
            if (!r || "data:" === r.substr(0, 5)) return setTimeout(function() {
                t(null, r);
            }, 0);
            var e = new XMLHttpRequest;
            e.open("GET", r, !0), e.addEventListener("error", function() {
                t(new Error("Failed to load image " + r));
            }), e.responseType = window.FileReader ? "blob" : "arraybuffer", e.addEventListener("load", function() {
                window.FileReader ? function(t, i) {
                    if (200 === t.status) {
                        var e = new FileReader;
                        e.onload = function(t) {
                            var e = t.target.result;
                            i(null, e);
                        }, e.onerror = function() {
                            i(new Error("Failed to load image " + r));
                        }, e.readAsDataURL(t.response);
                    } else i(new Error("Failed to load image " + r));
                }(e, t) : function(t, e) {
                    if (200 === t.status) {
                        var i = new Uint8Array(t.response), n = r.split(".").pop() || "png";
                        e(null, "data:image/" + (({
                            svg: "svg+xml"
                        })[n] || n) + ";base64," + btoa(function(t) {
                            for(var e = [], i = 0; i < t.length; i += 32768)e.push(String.fromCharCode.apply(null, t.subarray(i, i + 32768)));
                            return e.join("");
                        }(i)));
                    } else e(new Error("Failed to load image " + r));
                }(e, t);
            }), e.send();
        },
        getElementBBox: function(t) {
            var e = S(t);
            if (0 === e.length) throw new Error("Element not found");
            var i = e[0], n = i.ownerDocument, r = i.getBoundingClientRect(), o = 0, a = 0;
            if (i.ownerSVGElement) {
                var s = wr(i), l = s.getBBox({
                    target: s.svg()
                });
                o = r.width - l.width, a = r.height - l.height;
            }
            return {
                x: r.left + window.pageXOffset - n.documentElement.offsetLeft + o / 2,
                y: r.top + window.pageYOffset - n.documentElement.offsetTop + a / 2,
                width: r.width - o,
                height: r.height - a
            };
        },
        sortElements: Vr,
        setAttributesBySelector: function(t, e) {
            var n = S(t);
            Do(e, function(t, e) {
                var i = n.find(e).addBack().filter(e);
                No(t, "class") && (i.addClass(t.class), t = Mo(t, "class")), i.attr(t);
            });
        },
        normalizeSides: Xr,
        timing: Hr,
        interpolate: Jr,
        filter: _r,
        format: Qr,
        template: Kr,
        toggleFullScreen: function(t) {
            var e = window.top.document;
            function i(t, e) {
                for(var i = [
                    "webkit",
                    "moz",
                    "ms",
                    "o",
                    ""
                ], n = 0; n < i.length; n++){
                    var r = i[n], o = r ? r + e : e.substr(0, 1).toLowerCase() + e.substr(1);
                    if (void 0 !== t[o]) return go(t[o]) ? t[o]() : t[o];
                }
            }
            t = t || e.body, i(e, "FullscreenElement") || i(e, "FullScreenElement") ? i(e, "ExitFullscreen") || i(e, "CancelFullScreen") : i(t, "RequestFullscreen") || i(t, "RequestFullScreen");
        },
        mixin: qr,
        supplement: $r,
        deepMixin: to,
        deepSupplement: eo,
        assign: io,
        defaults: no,
        defaultsDeep: ro,
        invoke: oo,
        sortedIndex: ao,
        uniq: so,
        clone: lo,
        cloneDeep: co,
        isEmpty: uo,
        isEqual: ho,
        isFunction: go,
        isPlainObject: fo,
        toArray: po,
        debounce: mo,
        groupBy: Io,
        sortBy: vo,
        flattenDeep: Ao,
        without: Co,
        difference: yo,
        intersection: wo,
        union: bo,
        has: No,
        result: xo,
        omit: Mo,
        pick: So,
        bindAll: ko,
        forIn: Do,
        camelCase: To,
        uniqueId: Lo,
        merge: zo,
        isBoolean: Po,
        isObject: jo,
        isNumber: Zo,
        isString: Go,
        noop: Bo,
        cloneCells: Oo
    };
    function ma(t, e, i) {
        var n = t.toJSON();
        return n.angle = e || 0, no({}, i, n);
    }
    function Ia(t, e, i) {
        return t.map(function(t, e, i) {
            var n = this.pointAt((e + .5) / i.length);
            return (t.dx || t.dy) && n.offset(t.dx || 0, t.dy || 0), ma(n.round(), 0, t);
        }, rn(e, i));
    }
    function va(t, e, a, s) {
        var l = e.center(), c = e.width / e.height, u = e.topMiddle(), h = ln.fromRect(e);
        return t.map(function(t, e, i) {
            var n = a + s(e, i.length), r = u.clone().rotate(l, -n).scale(c, 1, l), o = t.compensateRotation ? -h.tangentTheta(r) : 0;
            return (t.dx || t.dy) && r.offset(t.dx || 0, t.dy || 0), t.dr && r.move(l, t.dr), ma(r.round(), o, t);
        });
    }
    function Aa(t, e) {
        var i = e.x;
        Go(i) && (i = parseFloat(i) / 100 * t.width);
        var n = e.y;
        return Go(n) && (n = parseFloat(n) / 100 * t.height), $i(i || 0, n || 0);
    }
    var Ca = {
        absolute: function(t, e, i) {
            return t.map(Aa.bind(null, e));
        },
        fn: function(t, e, i) {
            return i.fn(t, e, i);
        },
        line: function(t, e, i) {
            return Ia(t, Aa(e, i.start || e.origin()), Aa(e, i.end || e.corner()));
        },
        left: function(t, e, i) {
            return Ia(t, e.origin(), e.bottomLeft());
        },
        right: function(t, e, i) {
            return Ia(t, e.topRight(), e.corner());
        },
        top: function(t, e, i) {
            return Ia(t, e.origin(), e.topRight());
        },
        bottom: function(t, e, i) {
            return Ia(t, e.bottomLeft(), e.corner());
        },
        ellipseSpread: function(t, e, i) {
            var n = i.startAngle || 0, r = i.step || 360 / t.length;
            return va(t, e, n, function(t) {
                return t * r;
            });
        },
        ellipse: function(t, e, i) {
            var n = i.startAngle || 0, r = i.step || 20;
            return va(t, e, n, function(t, e) {
                return (t + .5 - e / 2) * r;
            });
        }
    };
    function ya(t, e) {
        return ro({}, t, e, {
            x: 0,
            y: 0,
            angle: 0,
            attrs: {
                ".": {
                    y: "0",
                    "text-anchor": "start"
                }
            }
        });
    }
    function wa(t, e, i, n) {
        n = no({}, n, {
            offset: 15
        });
        var r, o, a, s, l = e.center().theta(t), c = ba(e), u = n.offset, h = 0;
        s = l < c[1] || l > c[2] ? (a = ".3em", r = u, o = 0, "start") : l < c[0] ? (a = "0", r = 0, o = -u, i ? (h = -90, "start") : "middle") : l < c[3] ? (a = ".3em", r = -u, o = 0, "end") : (a = ".6em", r = 0, o = u, i ? (h = 90, "start") : "middle");
        var g = Math.round;
        return ya({
            x: g(r),
            y: g(o),
            angle: h,
            attrs: {
                ".": {
                    y: a,
                    "text-anchor": s
                }
            }
        });
    }
    function ba(t) {
        var e = t.center(), i = e.theta(t.origin()), n = e.theta(t.bottomLeft()), r = e.theta(t.corner());
        return [
            i,
            e.theta(t.topRight()),
            r,
            n
        ];
    }
    function Na(t, e, i, n) {
        var r, o, a, s, l = e.center().theta(t), c = (n = no({}, n, {
            offset: 15
        })).offset, u = 0, h = ba(e);
        s = l < h[1] || l > h[2] ? (a = ".3em", r = -c, o = 0, "end") : l < h[0] ? (a = ".6em", r = 0, o = c, i ? (u = 90, "start") : "middle") : l < h[3] ? (a = ".3em", r = c, o = 0, "start") : (a = "0em", r = 0, o = -c, i ? (u = -90, "start") : "middle");
        var g = Math.round;
        return ya({
            x: g(r),
            y: g(o),
            angle: u,
            attrs: {
                ".": {
                    y: a,
                    "text-anchor": s
                }
            }
        });
    }
    function xa(t, e, i) {
        i = no({}, i, {
            offset: 20
        });
        var n, r = $i(0, 0), o = -t.theta(r), a = o, s = t.clone().move(r, i.offset).difference(t).round(), l = ".3em";
        (o + 90) % 180 == 0 ? (n = e ? "end" : "middle", e || -270 !== o || (l = "0em")) : -270 < o && o < -90 ? (n = "start", a = o - 180) : n = "end";
        var c = Math.round;
        return ya({
            x: c(s.x),
            y: c(s.y),
            angle: e ? a : 0,
            attrs: {
                ".": {
                    y: l,
                    "text-anchor": n
                }
            }
        });
    }
    var Ma = {
        manual: function(t, e, i) {
            return ya(i, e);
        },
        left: function(t, e, i) {
            return ya(i, {
                x: -15,
                attrs: {
                    ".": {
                        y: ".3em",
                        "text-anchor": "end"
                    }
                }
            });
        },
        right: function(t, e, i) {
            return ya(i, {
                x: 15,
                attrs: {
                    ".": {
                        y: ".3em",
                        "text-anchor": "start"
                    }
                }
            });
        },
        top: function(t, e, i) {
            return ya(i, {
                y: -15,
                attrs: {
                    ".": {
                        "text-anchor": "middle"
                    }
                }
            });
        },
        bottom: function(t, e, i) {
            return ya(i, {
                y: 15,
                attrs: {
                    ".": {
                        y: ".6em",
                        "text-anchor": "middle"
                    }
                }
            });
        },
        outsideOriented: function(t, e, i) {
            return wa(t, e, !0, i);
        },
        outside: function(t, e, i) {
            return wa(t, e, !1, i);
        },
        insideOriented: function(t, e, i) {
            return Na(t, e, !0, i);
        },
        inside: function(t, e, i) {
            return Na(t, e, !1, i);
        },
        radial: function(t, e, i) {
            return xa(t.difference(e.center()), !1, i);
        },
        radialOriented: function(t, e, i) {
            return xa(t.difference(e.center()), !0, i);
        }
    }, Sa = ga.extend({
        markup: [
            '<path class="connection" stroke="black" d="M 0 0 0 0"/>',
            '<path class="marker-source" fill="black" stroke="black" d="M 0 0 0 0"/>',
            '<path class="marker-target" fill="black" stroke="black" d="M 0 0 0 0"/>',
            '<path class="connection-wrap" d="M 0 0 0 0"/>',
            '<g class="labels"/>',
            '<g class="marker-vertices"/>',
            '<g class="marker-arrowheads"/>',
            '<g class="link-tools"/>'
        ].join(""),
        toolMarkup: [
            '<g class="link-tool">',
            '<g class="tool-remove" event="remove">',
            '<circle r="11" />',
            '<path transform="scale(.8) translate(-16, -16)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z" />',
            "<title>Remove link.</title>",
            "</g>",
            '<g class="tool-options" event="link:options">',
            '<circle r="11" transform="translate(25)"/>',
            '<path fill="white" transform="scale(.55) translate(29, -16)" d="M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z"/>',
            "<title>Link options.</title>",
            "</g>",
            "</g>"
        ].join(""),
        doubleToolMarkup: void 0,
        vertexMarkup: [
            '<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">',
            '<circle class="marker-vertex" idx="<%= idx %>" r="10" />',
            '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>',
            '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">',
            "<title>Remove vertex.</title>",
            "</path>",
            "</g>"
        ].join(""),
        arrowheadMarkup: [
            '<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">',
            '<path class="marker-arrowhead" end="<%= end %>" d="M 26 0 L 0 13 L 26 26 z" />',
            "</g>"
        ].join(""),
        defaultLabel: void 0,
        labelMarkup: void 0,
        _builtins: {
            defaultLabel: {
                markup: [
                    {
                        tagName: "rect",
                        selector: "rect"
                    },
                    {
                        tagName: "text",
                        selector: "text"
                    }
                ],
                attrs: {
                    text: {
                        fill: "#000000",
                        fontSize: 14,
                        textAnchor: "middle",
                        yAlignment: "middle",
                        pointerEvents: "none"
                    },
                    rect: {
                        ref: "text",
                        fill: "#ffffff",
                        rx: 3,
                        ry: 3,
                        refWidth: 1,
                        refHeight: 1,
                        refX: 0,
                        refY: 0
                    }
                },
                position: {
                    distance: .5
                }
            }
        },
        defaults: {
            type: "link",
            source: {},
            target: {}
        },
        isLink: function() {
            return !0;
        },
        disconnect: function(t) {
            return this.set({
                source: {
                    x: 0,
                    y: 0
                },
                target: {
                    x: 0,
                    y: 0
                }
            }, t);
        },
        source: function(t, e, i) {
            var n, r;
            return void 0 === t ? lo(this.get("source")) : (r = t instanceof ga ? ((n = lo(e) || {}).id = t.id, i) : fo(t) ? (n = t, e) : ((n = lo(e) || {}).x = t.x, n.y = t.y, i), this.set("source", n, r));
        },
        target: function(t, e, i) {
            var n, r;
            return void 0 === t ? lo(this.get("target")) : (r = t instanceof ga ? ((n = lo(e) || {}).id = t.id, i) : fo(t) ? (n = t, e) : ((n = lo(e) || {}).x = t.x, n.y = t.y, i), this.set("target", n, r));
        },
        router: function(t, e, i) {
            if (void 0 === t) {
                var n = this.get("router");
                return n ? "object" == typeof n ? lo(n) : n : this.get("manhattan") ? {
                    name: "orthogonal"
                } : null;
            }
            var r = "object" == typeof t || "function" == typeof t, o = r ? t : {
                name: t,
                args: e
            }, a = r ? e : i;
            return this.set("router", o, a);
        },
        connector: function(t, e, i) {
            if (void 0 === t) {
                var n = this.get("connector");
                return n ? "object" == typeof n ? lo(n) : n : this.get("smooth") ? {
                    name: "smooth"
                } : null;
            }
            var r = "object" == typeof t || "function" == typeof t, o = r ? t : {
                name: t,
                args: e
            }, a = r ? e : i;
            return this.set("connector", o, a);
        },
        label: function(t, e, i) {
            var n = this.labels();
            return (t = isFinite(t) && null !== t ? 0 | t : 0) < 0 && (t = n.length + t), arguments.length <= 1 ? this.prop([
                "labels",
                t
            ]) : this.prop([
                "labels",
                t
            ], e, i);
        },
        labels: function(t, e) {
            return 0 === arguments.length ? (t = this.get("labels"), Array.isArray(t) ? t.slice() : []) : (Array.isArray(t) || (t = []), this.set("labels", t, e));
        },
        hasLabels: function() {
            var t = this.attributes.labels;
            return Array.isArray(t) && 0 < t.length;
        },
        insertLabel: function(t, e, i) {
            if (!e) throw new Error("dia.Link: no label provided");
            var n = this.labels(), r = n.length;
            return (t = isFinite(t) && null !== t ? 0 | t : r) < 0 && (t = r + t + 1), n.splice(t, 0, e), this.labels(n, i);
        },
        appendLabel: function(t, e) {
            return this.insertLabel(-1, t, e);
        },
        removeLabel: function(t, e) {
            var i = this.labels();
            return t = isFinite(t) && null !== t ? 0 | t : -1, i.splice(t, 1), this.labels(i, e);
        },
        vertex: function(t, e, i) {
            var n = this.vertices();
            if ((t = isFinite(t) && null !== t ? 0 | t : 0) < 0 && (t = n.length + t), arguments.length <= 1) return this.prop([
                "vertices",
                t
            ]);
            var r = this._normalizeVertex(e);
            return this.prop([
                "vertices",
                t
            ], r, i);
        },
        vertices: function(t, e) {
            if (0 === arguments.length) return t = this.get("vertices"), Array.isArray(t) ? t.slice() : [];
            Array.isArray(t) || (t = []);
            for(var i = [], n = 0; n < t.length; n++){
                var r = t[n], o = this._normalizeVertex(r);
                i.push(o);
            }
            return this.set("vertices", i, e);
        },
        insertVertex: function(t, e, i) {
            if (!e) throw new Error("dia.Link: no vertex provided");
            var n = this.vertices(), r = n.length;
            (t = isFinite(t) && null !== t ? 0 | t : r) < 0 && (t = r + t + 1);
            var o = this._normalizeVertex(e);
            return n.splice(t, 0, o), this.vertices(n, i);
        },
        removeVertex: function(t, e) {
            var i = this.vertices();
            return t = isFinite(t) && null !== t ? 0 | t : -1, i.splice(t, 1), this.vertices(i, e);
        },
        _normalizeVertex: function(t) {
            return !fo(t) ? {
                x: t.x,
                y: t.y
            } : t;
        },
        translate: function(e, i, t) {
            return (t = t || {}).translateBy = t.translateBy || this.id, t.tx = e, t.ty = i, this.applyToPoints(function(t) {
                return {
                    x: (t.x || 0) + e,
                    y: (t.y || 0) + i
                };
            }, t);
        },
        scale: function(e, i, n, t) {
            return this.applyToPoints(function(t) {
                return qi(t).scale(e, i, n).toJSON();
            }, t);
        },
        applyToPoints: function(t, e) {
            if (!go(t)) throw new TypeError("dia.Link: applyToPoints expects its first parameter to be a function.");
            var i = {}, n = this.attributes, r = n.source, o = n.target;
            r.id || (i.source = t(r)), o.id || (i.target = t(o));
            var a = this.vertices();
            return 0 < a.length && (i.vertices = a.map(t)), this.set(i, e);
        },
        getSourcePoint: function() {
            var t = this.getSourceCell();
            return t ? t.getPointFromConnectedLink(this, "source") : new qi(this.source());
        },
        getTargetPoint: function() {
            var t = this.getTargetCell();
            return t ? t.getPointFromConnectedLink(this, "target") : new qi(this.target());
        },
        getPointFromConnectedLink: function() {
            return this.getPolyline().pointAt(.5);
        },
        getPolyline: function() {
            var t = [
                this.getSourcePoint()
            ].concat(this.vertices().map(qi), [
                this.getTargetPoint()
            ]);
            return new wn(t);
        },
        getBBox: function() {
            return this.getPolyline().bbox();
        },
        reparent: function(t) {
            var e;
            if (this.graph) {
                var i = this.getSourceElement(), n = this.getTargetElement(), r = this.getParentCell();
                i && n && (e = i === n || i.isEmbeddedIn(n) ? n : n.isEmbeddedIn(i) ? i : this.graph.getCommonAncestor(i, n)), !r || e && e.id === r.id || r.unembed(this, t), e && e.embed(this, t);
            }
            return e;
        },
        hasLoop: function(t) {
            t = t || {};
            var e = this.attributes, i = e.source, n = e.target, r = i.id, o = n.id;
            if (!r || !o) return !1;
            var a = r === o;
            if (!a && t.deep && this.graph) {
                var s = this.getSourceCell(), l = this.getTargetCell();
                a = s.isEmbeddedIn(l) || l.isEmbeddedIn(s);
            }
            return a;
        },
        getSourceCell: function() {
            var t = this.graph, e = this.attributes.source;
            return e && e.id && t && t.getCell(e.id) || null;
        },
        getSourceElement: function() {
            var t = this, e = {};
            do {
                if (e[t.id]) return null;
                e[t.id] = !0, t = t.getSourceCell();
            }while (t && t.isLink());
            return t;
        },
        getTargetCell: function() {
            var t = this.graph, e = this.attributes.target;
            return e && e.id && t && t.getCell(e.id) || null;
        },
        getTargetElement: function() {
            var t = this, e = {};
            do {
                if (e[t.id]) return null;
                e[t.id] = !0, t = t.getTargetCell();
            }while (t && t.isLink());
            return t;
        },
        getRelationshipAncestor: function() {
            var t;
            if (this.graph) {
                var e = [
                    this,
                    this.getSourceElement(),
                    this.getTargetElement()
                ].filter(function(t) {
                    return !!t;
                });
                t = this.graph.getCommonAncestor.apply(this.graph, e);
            }
            return t || null;
        },
        isRelationshipEmbeddedIn: function(t) {
            var e = Go(t) || Zo(t) ? t : t.id, i = this.getRelationshipAncestor();
            return !!i && (i.id === e || i.isEmbeddedIn(e));
        },
        _getDefaultLabel: function() {
            var t = this.get("defaultLabel") || this.defaultLabel || {}, e = {};
            return e.markup = t.markup || this.get("labelMarkup") || this.labelMarkup, e.position = t.position, e.attrs = t.attrs, e.size = t.size, e;
        }
    }, {
        endsEqual: function(t, e) {
            var i = t.port === e.port || !t.port && !e.port;
            return t.id === e.id && i;
        }
    }), ka = function(t) {
        var e = co(t) || {};
        this.ports = [], this.groups = {}, this.portLayoutNamespace = Ca, this.portLabelLayoutNamespace = Ma, this._init(e);
    };
    ka.prototype = {
        getPorts: function() {
            return this.ports;
        },
        getGroup: function(t) {
            return this.groups[t] || {};
        },
        getPortsByGroup: function(e) {
            return this.ports.filter(function(t) {
                return t.group === e;
            });
        },
        getGroupPortsMetrics: function(t, r) {
            var e = this.getGroup(t), i = this.getPortsByGroup(t), n = e.position || {}, o = n.name, a = this.portLayoutNamespace;
            a[o] || (o = "left");
            var s = n.args || {}, l = i.map(function(t) {
                return t && t.position && t.position.args;
            }), c = a[o](l, r, s), u = {
                ports: i,
                result: []
            };
            return po(c).reduce((function(t, e, i) {
                var n = t.ports[i];
                return t.result.push({
                    portId: n.id,
                    portTransformation: e,
                    labelTransformation: this._getPortLabelLayout(n, qi(e), r),
                    portAttrs: n.attrs,
                    portSize: n.size,
                    labelSize: n.label.size
                }), t;
            }).bind(this), u), u.result;
        },
        _getPortLabelLayout: function(t, e, i) {
            var n = this.portLabelLayoutNamespace, r = t.label.position.name || "left";
            return n[r] ? n[r](e, i, t.label.position.args) : null;
        },
        _init: function(t) {
            if (jo(t.groups)) for(var e = Object.keys(t.groups), i = 0, n = e.length; i < n; i++){
                var r = e[i];
                this.groups[r] = this._evaluateGroup(t.groups[r]);
            }
            for(var o = po(t.items), a = 0, s = o.length; a < s; a++)this.ports.push(this._evaluatePort(o[a]));
        },
        _evaluateGroup: function(t) {
            return zo(t, {
                position: this._getPosition(t.position, !0),
                label: this._getLabel(t, !0)
            });
        },
        _evaluatePort: function(t) {
            var e = io({}, t), i = this.getGroup(t.group);
            return e.markup = e.markup || i.markup, e.attrs = zo({}, i.attrs, e.attrs), e.position = this._createPositionNode(i, e), e.label = zo({}, i.label, this._getLabel(e)), e.z = this._getZIndex(i, e), e.size = io({}, i.size, e.size), e;
        },
        _getZIndex: function(t, e) {
            return Zo(e.z) ? e.z : Zo(t.z) || "auto" === t.z ? t.z : "auto";
        },
        _createPositionNode: function(t, e) {
            return zo({
                name: "left",
                args: {}
            }, t.position, {
                args: e.args
            });
        },
        _getPosition: function(t, e) {
            var i, n = {};
            go(t) ? (i = "fn", n.fn = t) : Go(t) ? i = t : void 0 === t ? i = e ? "left" : null : Array.isArray(t) ? (i = "absolute", n.x = t[0], n.y = t[1]) : jo(t) && (i = t.name, io(n, t.args));
            var r = {
                args: n
            };
            return i && (r.name = i), r;
        },
        _getLabel: function(t, e) {
            var i = t.label || {}, n = i;
            return n.position = this._getPosition(i.position, e), n;
        }
    };
    var Da = {
        _initializePorts: function() {
            this._createPortData(), this.on("change:ports", function() {
                this._processRemovedPort(), this._createPortData();
            }, this);
        },
        _processRemovedPort: function() {
            var t = this.get("ports") || {}, e = {};
            po(t.items).forEach(function(t) {
                e[t.id] = !0;
            });
            var i = this.previous("ports") || {}, n = {};
            po(i.items).forEach(function(t) {
                e[t.id] || (n[t.id] = !0);
            });
            var r = this.graph;
            r && !uo(n) && (r.getConnectedLinks(this, {
                inbound: !0
            }).forEach(function(t) {
                n[t.get("target").port] && t.remove();
            }), r.getConnectedLinks(this, {
                outbound: !0
            }).forEach(function(t) {
                n[t.get("source").port] && t.remove();
            }));
        },
        hasPorts: function() {
            var t = this.prop("ports/items");
            return Array.isArray(t) && 0 < t.length;
        },
        hasPort: function(t) {
            return -1 !== this.getPortIndex(t);
        },
        getPorts: function() {
            return co(this.prop("ports/items")) || [];
        },
        getGroupPorts: function(e) {
            var t = po(this.prop([
                "ports",
                "items"
            ])).filter(function(t) {
                return t.group === e;
            });
            return co(t);
        },
        getPort: function(e) {
            return co(po(this.prop("ports/items")).find(function(t) {
                return t.id && t.id === e;
            }));
        },
        getPortsPositions: function(t) {
            return this._portSettingsData.getGroupPortsMetrics(t, In(this.size())).reduce(function(t, e) {
                var i = e.portTransformation;
                return t[e.portId] = {
                    x: i.x,
                    y: i.y,
                    angle: i.angle
                }, t;
            }, {});
        },
        getPortIndex: function(t) {
            var e = jo(t) ? t.id : t;
            return this._isValidPortId(e) ? po(this.prop("ports/items")).findIndex(function(t) {
                return t.id === e;
            }) : -1;
        },
        addPort: function(t, e) {
            if (!jo(t) || Array.isArray(t)) throw new Error("Element: addPort requires an object.");
            var i = io([], this.prop("ports/items"));
            return i.push(t), this.prop("ports/items", i, e), this;
        },
        insertPort: function(t, e, i) {
            var n = "number" == typeof t ? t : this.getPortIndex(t);
            if (!jo(e) || Array.isArray(e)) throw new Error("dia.Element: insertPort requires an object.");
            var r = io([], this.prop("ports/items"));
            return r.splice(n, 0, e), this.prop("ports/items", r, i), this;
        },
        portProp: function(t, e, i, n) {
            var r = this.getPortIndex(t);
            if (-1 === r) throw new Error("Element: unable to find port with id " + t);
            var o = Array.prototype.slice.call(arguments, 1);
            return Array.isArray(e) ? o[0] = [
                "ports",
                "items",
                r
            ].concat(e) : Go(e) ? o[0] = [
                "ports/items/",
                r,
                "/",
                e
            ].join("") : (o = [
                "ports/items/" + r
            ], fo(e) && (o.push(e), o.push(i))), this.prop.apply(this, o);
        },
        _validatePorts: function() {
            var t = this.get("ports") || {}, e = [], i = po((t = t || {}).items);
            return i.forEach(function(t) {
                "object" != typeof t && e.push("Element: invalid port ", t), this._isValidPortId(t.id) || (t.id = this.generatePortId());
            }, this), so(i, "id").length !== i.length && e.push("Element: found id duplicities in ports."), e;
        },
        generatePortId: function() {
            return this.generateId();
        },
        _isValidPortId: function(t) {
            return null != t && !jo(t);
        },
        addPorts: function(t, e) {
            return t.length && this.prop("ports/items", io([], this.prop("ports/items")).concat(t), e), this;
        },
        removePort: function(t, e) {
            var i = e || {}, n = this.getPortIndex(t);
            if (-1 !== n) {
                var r = io([], this.prop([
                    "ports",
                    "items"
                ]));
                r.splice(n, 1), i.rewrite = !0, this.startBatch("port-remove"), this.prop([
                    "ports",
                    "items"
                ], r, i), this.stopBatch("port-remove");
            }
            return this;
        },
        removePorts: function(t, e) {
            var i, n;
            if (Array.isArray(t)) {
                if (i = e || {}, 0 === t.length) return this.this;
                n = io([], this.prop([
                    "ports",
                    "items"
                ])).filter(function(i) {
                    return !t.some(function(t) {
                        var e = jo(t) ? t.id : t;
                        return i.id === e;
                    });
                });
            } else i = t || {}, n = [];
            return this.startBatch("port-remove"), i.rewrite = !0, this.prop([
                "ports",
                "items"
            ], n, i), this.stopBatch("port-remove"), this;
        },
        _createPortData: function() {
            var t, e = this._validatePorts();
            if (0 < e.length) throw this.set("ports", this.previous("ports")), new Error(e.join(" "));
            this._portSettingsData && (t = this._portSettingsData.getPorts()), this._portSettingsData = new ka(this.get("ports"));
            var i = this._portSettingsData.getPorts();
            if (t) {
                var n = i.filter(function(e) {
                    if (!t.find(function(t) {
                        return t.id === e.id;
                    })) return e;
                }), r = t.filter(function(e) {
                    if (!i.find(function(t) {
                        return t.id === e.id;
                    })) return e;
                });
                0 < r.length && this.trigger("ports:remove", this, r), 0 < n.length && this.trigger("ports:add", this, n);
            }
        }
    }, Ta = {
        portContainerMarkup: "g",
        portMarkup: [
            {
                tagName: "circle",
                selector: "circle",
                attributes: {
                    r: 10,
                    fill: "#FFFFFF",
                    stroke: "#000000"
                }
            }
        ],
        portLabelMarkup: [
            {
                tagName: "text",
                selector: "text",
                attributes: {
                    fill: "#000000"
                }
            }
        ],
        _portElementsCache: null,
        _initializePorts: function() {
            this._cleanPortsCache();
        },
        _refreshPorts: function() {
            this._removePorts(), this._cleanPortsCache(), this._renderPorts();
        },
        _cleanPortsCache: function() {
            this._portElementsCache = {};
        },
        _renderPorts: function() {
            for(var i = [], n = this._getContainerElement(), t = 0, e = n.node.childNodes.length; t < e; t++)i.push(n.node.childNodes[t]);
            var r = Io(this.model._portSettingsData.getPorts(), "z");
            po(r.auto).forEach(function(t) {
                var e = this._getPortElement(t);
                n.append(e), i.push(e);
            }, this);
            for(var o = Object.keys(r), a = 0; a < o.length; a++){
                var s = o[a];
                if ("auto" !== s) {
                    var l = parseInt(s, 10);
                    this._appendPorts(r[s], l, i);
                }
            }
            this._updatePorts();
        },
        _getContainerElement: function() {
            return this.rotatableNode || this.vel;
        },
        _appendPorts: function(t, e, i) {
            var n = this._getContainerElement(), r = po(t).map(this._getPortElement, this);
            i[e] || e < 0 ? wr(i[Math.max(e, 0)]).before(r) : n.append(r);
        },
        _getPortElement: function(t) {
            return this._portElementsCache[t.id] ? this._portElementsCache[t.id].portElement : this._createPortElement(t);
        },
        findPortNode: function(t, e) {
            var i = this._portElementsCache[t];
            if (!i) return null;
            var n = i.portContentElement.node, r = i.portContentSelectors, o = this.findBySelector(e, n, r)[0];
            return void 0 === o && (o = null), o;
        },
        _updatePorts: function() {
            this._updatePortGroup(void 0), Object.keys(this.model._portSettingsData.groups).forEach(this._updatePortGroup, this);
        },
        _removePorts: function() {
            oo(this._portElementsCache, "portElement.remove");
        },
        _createPortElement: function(t) {
            var e, i, n, r, o = wr(this.portContainerMarkup).addClass("joint-port"), a = this._getPortMarkup(t);
            if (Array.isArray(a)) {
                var s = this.parseDOMJSON(a, o.node), l = s.fragment;
                e = 1 < l.childNodes.length ? wr("g").append(l) : wr(l.firstChild), r = s.selectors;
            } else e = wr(a), Array.isArray(e) && (e = wr("g").append(e));
            if (!e) throw new Error("ElementView: Invalid port markup.");
            e.attr({
                port: t.id,
                "port-group": t.group
            });
            var c, u = this._getPortLabelMarkup(t.label);
            if (Array.isArray(u)) {
                var h = this.parseDOMJSON(u, o.node), g = h.fragment, d = h.selectors, f = g.childNodes.length;
                0 < f && (n = d, i = 1 === f ? wr(g.firstChild) : wr("g").append(g));
            } else i = wr(u), Array.isArray(i) && (i = wr("g").append(i));
            if (r && n) {
                for(var p in n)if (r[p] && p !== this.selector) throw new Error("ElementView: selectors within port must be unique.");
                c = io({}, r, n);
            } else c = r || n;
            return o.append(e.addClass("joint-port-body")), i && o.append(i.addClass("joint-port-label")), this._portElementsCache[t.id] = {
                portElement: o,
                portLabelElement: i,
                portSelectors: c,
                portLabelSelectors: n,
                portContentElement: e,
                portContentSelectors: r
            }, o;
        },
        _updatePortGroup: function(t) {
            for(var e = In(this.model.size()), i = this.model._portSettingsData.getGroupPortsMetrics(t, e), n = 0, r = i.length; n < r; n++){
                var o = i[n], a = o.portId, s = this._portElementsCache[a] || {}, l = o.portTransformation;
                this.applyPortTransform(s.portElement, l), this.updateDOMSubtreeAttributes(s.portElement.node, o.portAttrs, {
                    rootBBox: new In(o.portSize),
                    selectors: s.portSelectors
                });
                var c = o.labelTransformation;
                c && s.portLabelElement && (this.applyPortTransform(s.portLabelElement, c, -l.angle || 0), this.updateDOMSubtreeAttributes(s.portLabelElement.node, c.attrs, {
                    rootBBox: new In(o.labelSize),
                    selectors: s.portLabelSelectors
                }));
            }
        },
        applyPortTransform: function(t, e, i) {
            var n = wr.createSVGMatrix().rotate(i || 0).translate(e.x || 0, e.y || 0).rotate(e.angle || 0);
            t.transform(n, {
                absolute: !0
            });
        },
        _getPortMarkup: function(t) {
            return t.markup || this.model.get("portMarkup") || this.model.portMarkup || this.portMarkup;
        },
        _getPortLabelMarkup: function(t) {
            return t.markup || this.model.get("portLabelMarkup") || this.model.portLabelMarkup || this.portLabelMarkup;
        }
    }, La = ga.extend({
        defaults: {
            position: {
                x: 0,
                y: 0
            },
            size: {
                width: 1,
                height: 1
            },
            angle: 0
        },
        initialize: function() {
            this._initializePorts(), ga.prototype.initialize.apply(this, arguments);
        },
        _initializePorts: function() {},
        _refreshPorts: function() {},
        isElement: function() {
            return !0;
        },
        position: function(t, e, i) {
            var n, r = Zo(e), o = (i = (r ? i : t) || {}).parentRelative, a = i.deep, s = i.restrictedArea;
            if (o) {
                if (!this.graph) throw new Error("Element must be part of a graph.");
                var l = this.getParentCell();
                l && !l.isLink() && (n = l.get("position"));
            }
            if (r) {
                if (n && (t += n.x, e += n.y), a || s) {
                    var c = this.get("position"), u = c.x, h = c.y;
                    this.translate(t - u, e - h, i);
                } else this.set("position", {
                    x: t,
                    y: e
                }, i);
                return this;
            }
            var g = qi(this.get("position"));
            return o ? g.difference(n) : g;
        },
        translate: function(t, e, i) {
            if (e = e || 0, 0 === (t = t || 0) && 0 === e) return this;
            (i = i || {}).translateBy = i.translateBy || this.id;
            var n = this.get("position") || {
                x: 0,
                y: 0
            }, r = i.restrictedArea;
            if (r && i.translateBy === this.id) {
                if ("function" == typeof r) {
                    var o = r.call(this, n.x + t, n.y + e, i);
                    t = o.x - n.x, e = o.y - n.y;
                } else {
                    var a = this.getBBox({
                        deep: !0
                    }), s = n.x - a.x, l = n.y - a.y, c = Math.max(r.x + s, Math.min(r.x + r.width + s - a.width, n.x + t)), u = Math.max(r.y + l, Math.min(r.y + r.height + l - a.height, n.y + e));
                    t = c - n.x, e = u - n.y;
                }
            }
            var h = {
                x: n.x + t,
                y: n.y + e
            };
            return i.tx = t, i.ty = e, i.transition ? (jo(i.transition) || (i.transition = {}), this.transition("position", h, io({}, i.transition, {
                valueFunction: Jr.object
            })), oo(this.getEmbeddedCells(), "translate", t, e, i)) : (this.startBatch("translate", i), this.set("position", h, i), oo(this.getEmbeddedCells(), "translate", t, e, i), this.stopBatch("translate", i)), this;
        },
        size: function(t, e, i) {
            var n = this.get("size");
            return void 0 === t ? {
                width: n.width,
                height: n.height
            } : (jo(t) && (i = e, e = Zo(t.height) ? t.height : n.height, t = Zo(t.width) ? t.width : n.width), this.resize(t, e, i));
        },
        resize: function(t, e, i) {
            if (i = i || {}, this.startBatch("resize", i), i.direction) {
                var n = this.get("size");
                switch(i.direction){
                    case "left":
                    case "right":
                        e = n.height;
                        break;
                    case "top":
                    case "bottom":
                        t = n.width;
                }
                var r, o = Ti(this.get("angle") || 0), a = this.getBBox();
                if (o) {
                    var s = {
                        "top-right": 0,
                        right: 0,
                        "top-left": 1,
                        top: 1,
                        "bottom-left": 2,
                        left: 2,
                        "bottom-right": 3,
                        bottom: 3
                    }[i.direction];
                    i.absolute && (s += Math.floor((o + 45) / 90), s %= 4);
                    var l = a[[
                        "bottomLeft",
                        "corner",
                        "topRight",
                        "origin"
                    ][s]](), c = qi(l).rotate(a.center(), -o), u = Math.sqrt(t * t + e * e) / 2, h = s * Math.PI / 2;
                    h += Math.atan(s % 2 == 0 ? e / t : t / e), h -= Pi(o);
                    var g = qi.fromPolar(u, h, c);
                    r = qi(g).offset(t / -2, e / -2);
                } else switch(r = a.topLeft(), i.direction){
                    case "top":
                    case "top-right":
                        r.offset(0, a.height - e);
                        break;
                    case "left":
                    case "bottom-left":
                        r.offset(a.width - t, 0);
                        break;
                    case "top-left":
                        r.offset(a.width - t, a.height - e);
                }
                this.set("size", {
                    width: t,
                    height: e
                }, i), this.position(r.x, r.y, i);
            } else this.set("size", {
                width: t,
                height: e
            }, i);
            return this.stopBatch("resize", i), this;
        },
        scale: function(t, e, i, n) {
            var r = this.getBBox().scale(t, e, i);
            return this.startBatch("scale", n), this.position(r.x, r.y, n), this.resize(r.width, r.height, n), this.stopBatch("scale"), this;
        },
        fitEmbeds: function(t) {
            void 0 === t && (t = {});
            var e = this.graph;
            if (!e) throw new Error("Element must be part of a graph.");
            var i = this.getEmbeddedCells().filter(function(t) {
                return t.isElement();
            });
            if (0 === i.length) return this;
            this.startBatch("fit-embeds", t), t.deep && oo(i, "fitEmbeds", t);
            var n = Xr(t.padding), r = n.left, o = n.right, a = n.top, s = n.bottom, l = e.getCellsBBox(i), c = l.x, u = l.y, h = l.width, g = l.height;
            return c -= r, u -= a, h += r + o, g += s + a, this.set({
                position: {
                    x: c,
                    y: u
                },
                size: {
                    width: h,
                    height: g
                }
            }, t), this.stopBatch("fit-embeds"), this;
        },
        rotate: function(t, e, i, n) {
            if (i) {
                var r = this.getBBox().center(), o = this.get("size"), a = this.get("position");
                r.rotate(i, this.get("angle") - t);
                var s = r.x - o.width / 2 - a.x, l = r.y - o.height / 2 - a.y;
                this.startBatch("rotate", {
                    angle: t,
                    absolute: e,
                    origin: i
                }), this.position(a.x + s, a.y + l, n), this.rotate(t, e, null, n), this.stopBatch("rotate");
            } else this.set("angle", e ? t : (this.get("angle") + t) % 360, n);
            return this;
        },
        angle: function() {
            return Ti(this.get("angle") || 0);
        },
        getBBox: function(t) {
            void 0 === t && (t = {});
            var e = this.graph, i = this.attributes, n = t.deep, r = t.rotate;
            if (n && e) {
                var o = this.getEmbeddedCells({
                    deep: !0,
                    breadthFirst: !0
                });
                return o.push(this), e.getCellsBBox(o, t);
            }
            var a = i.angle;
            void 0 === a && (a = 0);
            var s = i.position, l = s.x, c = s.y, u = i.size, h = u.width, g = u.height, d = new In(l, c, h, g);
            return r && d.rotateAroundCenter(a), d;
        },
        getPointFromConnectedLink: function(t, e) {
            var i = this.getBBox(), n = i.center(), r = t.get(e);
            if (!r) return n;
            var o = r.port;
            if (!o || !this.hasPort(o)) return n;
            var a = this.portProp(o, [
                "group"
            ]), s = this.getPortsPositions(a), l = new qi(s[o]).offset(i.origin()), c = this.angle();
            return c && l.rotate(n, -c), l;
        }
    });
    io(La.prototype, Da);
    var za = s.Collection.extend({
        initialize: function(t, e) {
            e.cellNamespace ? this.cellNamespace = e.cellNamespace : this.cellNamespace = "undefined" != typeof joint && No(joint, "shapes") ? joint.shapes : null, this.graph = e.graph;
        },
        model: function(t, e) {
            var i = e.collection, n = i.cellNamespace, r = new ("link" === t.type ? Sa : kr(n, t.type, ".") || La)(t, e);
            return e.dry || (r.graph = i.graph), r;
        },
        comparator: function(t) {
            return t.get("z") || 0;
        }
    }), Pa = s.Model.extend({
        initialize: function(t, e) {
            var i = new za([], {
                model: (e = e || {}).cellModel,
                cellNamespace: e.cellNamespace,
                graph: this
            });
            s.Model.prototype.set.call(this, "cells", i), i.on("all", this.trigger, this), this.on("change:z", this._sortOnChangeZ, this), this._out = {}, this._in = {}, this._nodes = {}, this._edges = {}, this._batches = {}, i.on("add", this._restructureOnAdd, this), i.on("remove", this._restructureOnRemove, this), i.on("reset", this._restructureOnReset, this), i.on("change:source", this._restructureOnChangeSource, this), i.on("change:target", this._restructureOnChangeTarget, this), i.on("remove", this._removeCell, this);
        },
        _sortOnChangeZ: function() {
            this.get("cells").sort();
        },
        _restructureOnAdd: function(t) {
            if (t.isLink()) {
                this._edges[t.id] = !0;
                var e = t.attributes, i = e.source, n = e.target;
                i.id && ((this._out[i.id] || (this._out[i.id] = {}))[t.id] = !0), n.id && ((this._in[n.id] || (this._in[n.id] = {}))[t.id] = !0);
            } else this._nodes[t.id] = !0;
        },
        _restructureOnRemove: function(t) {
            if (t.isLink()) {
                delete this._edges[t.id];
                var e = t.attributes, i = e.source, n = e.target;
                i.id && this._out[i.id] && this._out[i.id][t.id] && delete this._out[i.id][t.id], n.id && this._in[n.id] && this._in[n.id][t.id] && delete this._in[n.id][t.id];
            } else delete this._nodes[t.id];
        },
        _restructureOnReset: function(t) {
            t = t.models, this._out = {}, this._in = {}, this._nodes = {}, this._edges = {}, t.forEach(this._restructureOnAdd, this);
        },
        _restructureOnChangeSource: function(t) {
            var e = t.previous("source");
            e.id && this._out[e.id] && delete this._out[e.id][t.id];
            var i = t.attributes.source;
            i.id && ((this._out[i.id] || (this._out[i.id] = {}))[t.id] = !0);
        },
        _restructureOnChangeTarget: function(t) {
            var e = t.previous("target");
            e.id && this._in[e.id] && delete this._in[e.id][t.id];
            var i = t.get("target");
            i.id && ((this._in[i.id] || (this._in[i.id] = {}))[t.id] = !0);
        },
        getOutboundEdges: function(t) {
            return this._out && this._out[t] || {};
        },
        getInboundEdges: function(t) {
            return this._in && this._in[t] || {};
        },
        toJSON: function() {
            var t = s.Model.prototype.toJSON.apply(this, arguments);
            return t.cells = this.get("cells").toJSON(), t;
        },
        fromJSON: function(t, e) {
            if (!t.cells) throw new Error("Graph JSON must contain cells array.");
            return this.set(t, e);
        },
        set: function(t, e, i) {
            var n;
            return "object" == typeof t ? (n = t, i = e) : (n = {})[t] = e, n.hasOwnProperty("cells") && (this.resetCells(n.cells, i), n = Mo(n, "cells")), s.Model.prototype.set.call(this, n, i);
        },
        clear: function(t) {
            t = io({}, t, {
                clear: !0
            });
            var e = this.get("cells");
            if (0 === e.length) return this;
            this.startBatch("clear", t);
            for(var i = e.sortBy(function(t) {
                return t.isLink() ? 1 : 2;
            }); i.shift().remove(t), 0 < i.length;);
            return this.stopBatch("clear"), this;
        },
        _prepareCell: function(t, e) {
            var i;
            if (t instanceof s.Model ? (i = t.attributes, t.graph || e && e.dry || (t.graph = this)) : i = t, !Go(i.type)) throw new TypeError("dia.Graph: cell type must be a string.");
            return t;
        },
        minZIndex: function() {
            var t = this.get("cells").first();
            return t && t.get("z") || 0;
        },
        maxZIndex: function() {
            var t = this.get("cells").last();
            return t && t.get("z") || 0;
        },
        addCell: function(t, e) {
            return Array.isArray(t) ? this.addCells(t, e) : (t instanceof s.Model ? t.has("z") || t.set("z", this.maxZIndex() + 1) : void 0 === t.z && (t.z = this.maxZIndex() + 1), this.get("cells").add(this._prepareCell(t, e), e || {}), this);
        },
        addCells: function(t, e) {
            return 0 === t.length || (t = Ao(t), e.maxPosition = e.position = t.length - 1, this.startBatch("add", e), t.forEach(function(t) {
                this.addCell(t, e), e.position--;
            }, this), this.stopBatch("add", e)), this;
        },
        resetCells: function(t, e) {
            var i = po(t).map(function(t) {
                return this._prepareCell(t, e);
            }, this);
            return this.get("cells").reset(i, e), this;
        },
        removeCells: function(t, e) {
            return t.length && (this.startBatch("remove"), oo(t, "remove", e), this.stopBatch("remove")), this;
        },
        _removeCell: function(t, e, i) {
            (i = i || {}).clear || (i.disconnectLinks ? this.disconnectLinks(t, i) : this.removeLinks(t, i)), this.get("cells").remove(t, {
                silent: !0
            }), t.graph === this && (t.graph = null);
        },
        getCell: function(t) {
            return this.get("cells").get(t);
        },
        getCells: function() {
            return this.get("cells").toArray();
        },
        getElements: function() {
            return this.get("cells").filter(function(t) {
                return t.isElement();
            });
        },
        getLinks: function() {
            return this.get("cells").filter(function(t) {
                return t.isLink();
            });
        },
        getFirstCell: function() {
            return this.get("cells").first();
        },
        getLastCell: function() {
            return this.get("cells").last();
        },
        getConnectedLinks: function(t, s) {
            var r = (s = s || {}).indirect, o = s.inbound, a = s.outbound;
            void 0 === o && void 0 === a && (o = a = !0);
            var l = [], c = {};
            function u(n, t) {
                if (Do(n.getOutboundEdges(t.id), (function(t, e) {
                    if (!c[e]) {
                        var i = n.getCell(e);
                        l.push(i), c[e] = !0, r && (o && h(n, i), a && u(n, i));
                    }
                }).bind(n)), r && t.isLink()) {
                    var e = t.getTargetCell();
                    e && e.isLink() && (c[e.id] || (l.push(e), u(n, e)));
                }
            }
            function h(n, t) {
                if (Do(n.getInboundEdges(t.id), (function(t, e) {
                    if (!c[e]) {
                        var i = n.getCell(e);
                        l.push(i), c[e] = !0, r && (o && h(n, i), a && u(n, i));
                    }
                }).bind(n)), r && t.isLink()) {
                    var e = t.getSourceCell();
                    e && e.isLink() && (c[e.id] || (l.push(e), h(n, e)));
                }
            }
            if (a && u(this, t), o && h(this, t), s.deep) {
                var e = t.getEmbeddedCells({
                    deep: !0
                }), g = {};
                e.forEach(function(t) {
                    t.isElement() && (g[t.id] = !0);
                }), e.forEach(function(t) {
                    t.isLink() || (a && Do(this.getOutboundEdges(t.id), (function(t, e) {
                        if (!c[e]) {
                            var i = this.getCell(e).attributes, n = i.source, r = i.target, o = n.id, a = r.id;
                            if (!s.includeEnclosed && o && g[o] && a && g[a]) return;
                            l.push(this.getCell(e)), c[e] = !0;
                        }
                    }).bind(this)), o && Do(this.getInboundEdges(t.id), (function(t, e) {
                        if (!c[e]) {
                            var i = this.getCell(e).attributes, n = i.source, r = i.target, o = n.id, a = r.id;
                            if (!s.includeEnclosed && o && g[o] && a && g[a]) return;
                            l.push(this.getCell(e)), c[e] = !0;
                        }
                    }).bind(this)));
                }, this);
            }
            return l;
        },
        getNeighbors: function(l, c) {
            c || (c = {});
            var u = c.inbound, h = c.outbound;
            void 0 === u && void 0 === h && (u = h = !0);
            var t = this.getConnectedLinks(l, c).reduce((function(t, e) {
                var i = e.attributes, n = i.source, r = i.target, o = e.hasLoop(c);
                if (u && No(n, "id") && !t[n.id]) {
                    var a = this.getCell(n.id);
                    a.isElement() && (!o && (!a || a === l || c.deep && a.isEmbeddedIn(l)) || (t[n.id] = a));
                }
                if (h && No(r, "id") && !t[r.id]) {
                    var s = this.getCell(r.id);
                    s.isElement() && (!o && (!s || s === l || c.deep && s.isEmbeddedIn(l)) || (t[r.id] = s));
                }
                return t;
            }).bind(this), {});
            if (l.isLink()) {
                if (u) {
                    var e = l.getSourceCell();
                    e && e.isElement() && !t[e.id] && (t[e.id] = e);
                }
                if (h) {
                    var i = l.getTargetCell();
                    i && i.isElement() && !t[i.id] && (t[i.id] = i);
                }
            }
            return po(t);
        },
        getCommonAncestor: function() {
            var t = Array.from(arguments).map(function(t) {
                for(var e = [], i = t.get("parent"); i;)e.push(i), i = this.getCell(i).get("parent");
                return e;
            }, this);
            t = t.sort(function(t, e) {
                return t.length - e.length;
            });
            var e = po(t.shift()).find(function(e) {
                return t.every(function(t) {
                    return t.includes(e);
                });
            });
            return this.getCell(e);
        },
        getSuccessors: function(e, t) {
            t = t || {};
            var i = [];
            return this.search(e, function(t) {
                t !== e && i.push(t);
            }, io({}, t, {
                outbound: !0
            })), i;
        },
        cloneCells: Oo,
        cloneSubgraph: function(t, e) {
            var i = this.getSubgraph(t, e);
            return this.cloneCells(i);
        },
        getSubgraph: function(t, e) {
            e = e || {};
            var a = [], s = {}, l = [], i = [];
            return po(t).forEach(function(t) {
                (s[t.id] || (a.push(t), (s[t.id] = t).isLink() ? i.push(t) : l.push(t)), e.deep) && t.getEmbeddedCells({
                    deep: !0
                }).forEach(function(t) {
                    s[t.id] || (a.push(t), (s[t.id] = t).isLink() ? i.push(t) : l.push(t));
                });
            }), i.forEach(function(t) {
                var e = t.attributes, i = e.source, n = e.target;
                if (i.id && !s[i.id]) {
                    var r = this.getCell(i.id);
                    a.push(r), s[r.id] = r, l.push(r);
                }
                if (n.id && !s[n.id]) {
                    var o = this.getCell(n.id);
                    a.push(this.getCell(n.id)), s[o.id] = o, l.push(o);
                }
            }, this), l.forEach(function(t) {
                this.getConnectedLinks(t, e).forEach(function(t) {
                    var e = t.attributes, i = e.source, n = e.target;
                    !s[t.id] && i.id && s[i.id] && n.id && s[n.id] && (a.push(t), s[t.id] = t);
                });
            }, this), a;
        },
        getPredecessors: function(e, t) {
            t = t || {};
            var i = [];
            return this.search(e, function(t) {
                t !== e && i.push(t);
            }, io({}, t, {
                inbound: !0
            })), i;
        },
        search: function(t, e, i) {
            (i = i || {}).breadthFirst ? this.bfs(t, e, i) : this.dfs(t, e, i);
        },
        bfs: function(t, e, i) {
            void 0 === i && (i = {});
            var n = {}, r = {}, o = [];
            for(o.push(t), r[t.id] = 0; 0 < o.length;){
                var a = o.shift();
                if (!n[a.id] && (n[a.id] = !0, false) !== e.call(this, a, r[a.id])) for(var s = this.getNeighbors(a, i), l = 0, c = s.length; l < c; l++){
                    var u = s[l];
                    r[u.id] = r[a.id] + 1, o.push(u);
                }
            }
        },
        dfs: function(t, e, i) {
            void 0 === i && (i = {});
            var n = {}, r = {}, o = [];
            for(o.push(t), r[t.id] = 0; 0 < o.length;){
                var a = o.pop();
                if (!n[a.id] && (n[a.id] = !0, false) !== e.call(this, a, r[a.id])) for(var s = this.getNeighbors(a, i), l = o.length, c = 0, u = s.length; c < u; c++){
                    var h = s[c];
                    r[h.id] = r[a.id] + 1, o.splice(l, 0, h);
                }
            }
        },
        getSources: function() {
            var i = [];
            return Do(this._nodes, (function(t, e) {
                this._in[e] && !uo(this._in[e]) || i.push(this.getCell(e));
            }).bind(this)), i;
        },
        getSinks: function() {
            var i = [];
            return Do(this._nodes, (function(t, e) {
                this._out[e] && !uo(this._out[e]) || i.push(this.getCell(e));
            }).bind(this)), i;
        },
        isSource: function(t) {
            return !this._in[t.id] || uo(this._in[t.id]);
        },
        isSink: function(t) {
            return !this._out[t.id] || uo(this._out[t.id]);
        },
        isSuccessor: function(e, i) {
            var n = !1;
            return this.search(e, function(t) {
                if (t === i && t !== e) return n = !0, false;
            }, {
                outbound: !0
            }), n;
        },
        isPredecessor: function(e, i) {
            var n = !1;
            return this.search(e, function(t) {
                if (t === i && t !== e) return n = !0, false;
            }, {
                inbound: !0
            }), n;
        },
        isNeighbor: function(t, r, e) {
            var o = (e = e || {}).inbound, a = e.outbound;
            void 0 === o && void 0 === a && (o = a = !0);
            var s = !1;
            return this.getConnectedLinks(t, e).forEach(function(t) {
                var e = t.attributes, i = e.source, n = e.target;
                return o && No(i, "id") && i.id === r.id ? (s = !0, false) : a && No(n, "id") && n.id === r.id ? (s = !0, false) : void 0;
            }), s;
        },
        disconnectLinks: function(e, i) {
            this.getConnectedLinks(e).forEach(function(t) {
                t.set(t.attributes.source.id === e.id ? "source" : "target", {
                    x: 0,
                    y: 0
                }, i);
            });
        },
        removeLinks: function(t, e) {
            oo(this.getConnectedLinks(t), "remove", e);
        },
        findModelsFromPoint: function(e) {
            return this.getElements().filter(function(t) {
                return t.getBBox({
                    rotate: !0
                }).containsPoint(e);
            });
        },
        findModelsInArea: function(t, e) {
            void 0 === e && (e = {});
            var i = new In(t), n = e.strict;
            void 0 === n && (n = !1);
            var r = n ? "containsRect" : "intersect";
            return this.getElements().filter(function(t) {
                return i[r](t.getBBox({
                    rotate: !0
                }));
            });
        },
        findModelsUnderElement: function(e, t) {
            void 0 === t && (t = {});
            var i = t.searchBy;
            void 0 === i && (i = "bbox");
            var n = e.getBBox().rotateAroundCenter(e.angle());
            return ("bbox" === i ? this.findModelsInArea(n) : this.findModelsFromPoint(n[i]())).filter(function(t) {
                return e.id !== t.id && !t.isEmbeddedIn(e);
            });
        },
        getBBox: function() {
            return this.getCellsBBox(this.getCells());
        },
        getCellsBBox: function(t, e) {
            void 0 === e && (e = {});
            var n = e.rotate;
            return void 0 === n && (n = !0), po(t).reduce(function(t, e) {
                var i = e.getBBox({
                    rotate: n
                });
                return i ? t ? t.union(i) : i : t;
            }, null);
        },
        translate: function(t, e, i) {
            var n = this.getCells().filter(function(t) {
                return !t.isEmbedded();
            });
            return oo(n, "translate", t, e, i), this;
        },
        resize: function(t, e, i) {
            return this.resizeCells(t, e, this.getCells(), i);
        },
        resizeCells: function(t, e, i, n) {
            var r = this.getCellsBBox(i);
            if (r) {
                var o = Math.max(t / r.width, 0), a = Math.max(e / r.height, 0);
                oo(i, "scale", o, a, r.origin(), n);
            }
            return this;
        },
        startBatch: function(t, e) {
            return e = e || {}, this._batches[t] = (this._batches[t] || 0) + 1, this.trigger("batch:start", io({}, e, {
                batchName: t
            }));
        },
        stopBatch: function(t, e) {
            return e = e || {}, this._batches[t] = (this._batches[t] || 0) - 1, this.trigger("batch:stop", io({}, e, {
                batchName: t
            }));
        },
        hasActiveBatch: function(t) {
            var e = this._batches;
            return (0 === arguments.length ? Object.keys(e) : Array.isArray(t) ? t : [
                t
            ]).some(function(t) {
                return 0 < e[t];
            });
        }
    }, {
        validations: {
            multiLinks: function(t, e) {
                var i = e.attributes, r = i.source, o = i.target;
                if (r.id && o.id) {
                    var n = e.getSourceCell();
                    if (n) {
                        if (1 < t.getConnectedLinks(n, {
                            outbound: !0
                        }).filter(function(t) {
                            var e = t.attributes, i = e.source, n = e.target;
                            return i && i.id === r.id && (!i.port || i.port === r.port) && n && n.id === o.id && (!n.port || n.port === o.port);
                        }).length) return !1;
                    }
                }
                return !0;
            },
            linkPinning: function(t, e) {
                var i = e.attributes, n = i.source, r = i.target;
                return n.id && r.id;
            }
        }
    });
    da(Pa.prototype, [
        "resetCells",
        "addCells",
        "removeCells"
    ], fa.cells);
    var ja = {}, Za = s.View.extend({
        options: {},
        theme: null,
        themeClassNamePrefix: Nr("theme-"),
        requireSetThemeOverride: !1,
        defaultTheme: br.defaultTheme,
        children: null,
        childNodes: null,
        DETACHABLE: !0,
        UPDATE_PRIORITY: 2,
        FLAG_INSERT: 1073741824,
        FLAG_REMOVE: 536870912,
        constructor: function(t) {
            this.requireSetThemeOverride = t && !!t.theme, this.options = io({}, this.options, t), s.View.call(this, t);
        },
        initialize: function() {
            (ja[this.cid] = this).setTheme(this.options.theme || this.defaultTheme), this.init();
        },
        unmount: function() {
            this.svgElement ? this.vel.remove() : this.$el.remove();
        },
        renderChildren: function(t) {
            if (t || (t = xo(this, "children")), t) {
                var e = this.svgElement, i = wr.namespace[e ? "svg" : "xhtml"], n = Mr(t, i);
                (e ? this.vel : this.$el).empty().append(n.fragment), this.childNodes = n.selectors;
            }
            return this;
        },
        findAttribute: function(t, e) {
            for(var i = e; i && 1 === i.nodeType;){
                var n = i.getAttribute(t);
                if (n) return n;
                if (i === this.el) return null;
                i = i.parentNode;
            }
            return null;
        },
        _ensureElement: function() {
            if (this.el) this.setElement(xo(this, "el"));
            else {
                var t = xo(this, "tagName"), e = io({}, xo(this, "attributes")), i = io({}, xo(this, "style"));
                this.id && (e.id = xo(this, "id")), this.setElement(this._createElement(t)), this._setAttributes(e), this._setStyle(i);
            }
            this._ensureElClassName();
        },
        _setAttributes: function(t) {
            this.svgElement ? this.vel.attr(t) : this.$el.attr(t);
        },
        _setStyle: function(t) {
            this.$el.css(t);
        },
        _createElement: function(t) {
            return this.svgElement ? document.createElementNS(wr.namespace.svg, t) : document.createElement(t);
        },
        _setElement: function(t) {
            this.$el = t instanceof s.$ ? t : s.$(t), this.el = this.$el[0], this.svgElement && (this.vel = wr(this.el));
        },
        _ensureElClassName: function() {
            var t = xo(this, "className");
            if (t) {
                var e = Nr(t);
                this.svgElement ? this.vel.removeClass(t).addClass(e) : this.$el.removeClass(t).addClass(e);
            }
        },
        init: function() {},
        onRender: function() {},
        confirmUpdate: function() {
            return 0;
        },
        setTheme: function(t, e) {
            return e = e || {}, this.theme && this.requireSetThemeOverride && !e.override || (this.removeThemeClassName(), this.addThemeClassName(t), this.onSetTheme(this.theme, t), this.theme = t), this;
        },
        addThemeClassName: function(t) {
            if (!(t = t || this.theme)) return this;
            var e = this.themeClassNamePrefix + t;
            return this.svgElement ? this.vel.addClass(e) : this.$el.addClass(e), this;
        },
        removeThemeClassName: function(t) {
            t = t || this.theme;
            var e = this.themeClassNamePrefix + t;
            return this.svgElement ? this.vel.removeClass(e) : this.$el.removeClass(e), this;
        },
        onSetTheme: function(t, e) {},
        remove: function() {
            return this.onRemove(), this.undelegateDocumentEvents(), ja[this.cid] = null, s.View.prototype.remove.apply(this, arguments), this;
        },
        onRemove: function() {},
        getEventNamespace: function() {
            return ".joint-event-ns-" + this.cid;
        },
        delegateElementEvents: function(t, e, i) {
            if (!e) return this;
            i || (i = {});
            var n = this.getEventNamespace();
            for(var r in e){
                var o = e[r];
                "function" != typeof o && (o = this[o]), o && S(t).on(r + n, i, o.bind(this));
            }
            return this;
        },
        undelegateElementEvents: function(t) {
            return S(t).off(this.getEventNamespace()), this;
        },
        delegateDocumentEvents: function(t, e) {
            return t || (t = xo(this, "documentEvents")), this.delegateElementEvents(document, t, e);
        },
        undelegateDocumentEvents: function() {
            return this.undelegateElementEvents(document);
        },
        eventData: function(t, e) {
            if (!t) throw new Error("eventData(): event object required.");
            var i = t.data, n = "__" + this.cid + "__";
            return void 0 === e ? i && i[n] || {} : (i || (i = t.data = {}), i[n] || (i[n] = {}), io(i[n], e), this);
        },
        stopPropagation: function(t) {
            return this.eventData(t, {
                propagationStopped: !0
            }), this;
        },
        isPropagationStopped: function(t) {
            return !!this.eventData(t).propagationStopped;
        }
    }, {
        extend: function() {
            var t = Array.from(arguments), e = t[0] && io({}, t[0]) || {}, i = t[1] && io({}, t[1]) || {}, n = e.render || this.prototype && this.prototype.render || null;
            return e.render = function() {
                return "function" == typeof n && n.apply(this, arguments), this.render.__render__ === n && this.onRender(), this;
            }, e.render.__render__ = n, s.View.extend.call(this, e, i);
        }
    });
    if (S.event && !("dbltap" in S.event.special)) {
        var Ga = br.doubleTapInterval;
        S.event.special.dbltap = {
            bindType: "touchend",
            delegateType: "touchend",
            handle: function(t) {
                for(var e, i = [], n = arguments.length - 1; 0 < n--;)i[n] = arguments[n + 1];
                var r = t.handleObj, o = t.target, a = S.data(o), s = (new Date).getTime(), l = "lastTouch" in a ? s - a.lastTouch : 0;
                l < Ga && 30 < l ? (a.lastTouch = null, t.type = r.origType, (e = r.handler).call.apply(e, [
                    this,
                    t
                ].concat(i))) : a.lastTouch = s;
            }
        };
    }
    var Ba = {
        views: ja,
        View: Za
    }, Oa = {
        CELLS: "cells",
        BACK: "back",
        FRONT: "front",
        TOOLS: "tools",
        LABELS: "labels"
    }, Ea = Za.extend({
        tagName: "g",
        svgElement: !0,
        pivotNodes: null,
        defaultTheme: null,
        options: {
            name: ""
        },
        className: function() {
            return Nr(this.options.name + "-layer");
        },
        init: function() {
            this.pivotNodes = {};
        },
        insertSortedNode: function(t, e) {
            this.el.insertBefore(t, this.insertPivot(e));
        },
        insertNode: function(t) {
            var e = this.el;
            t.parentNode !== e && e.appendChild(t);
        },
        insertPivot: function(t) {
            var e = this.el, i = this.pivotNodes;
            (t = +t) || (t = 0);
            var n = i[t];
            if (n) return n;
            n = i[t] = document.createComment("z-index:" + (t + 1));
            var r = -1 / 0;
            for(var o in i)(o = +o) < t && r < o && (r = o);
            if (r !== -1 / 0) {
                var a = i[r];
                e.insertBefore(n, a.nextSibling);
            } else e.insertBefore(n, e.firstChild);
            return n;
        },
        removePivots: function() {
            var t = this.el, e = this.pivotNodes;
            for(var i in e)t.removeChild(e[i]);
            this.pivotNodes = {};
        }
    });
    function Ra(t) {
        return t ? Array.isArray(t) ? t : [
            t
        ] : [];
    }
    var Ya = Za.extend({
        tagName: "g",
        svgElement: !0,
        className: "highlight",
        HIGHLIGHT_FLAG: 1,
        UPDATE_PRIORITY: 3,
        DETACHABLE: !1,
        UPDATABLE: !0,
        MOUNTABLE: !0,
        cellView: null,
        nodeSelector: null,
        node: null,
        updateRequested: !1,
        transformGroup: null,
        requestUpdate: function(t, e) {
            var i = t.paper;
            this.cellView = t, this.nodeSelector = e, i && (this.updateRequested = !0, i.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY));
        },
        confirmUpdate: function() {
            this.updateRequested = !1;
            var t = this.cellView, e = this.nodeSelector;
            return this.update(t, e), this.mount(), this.transform(), 0;
        },
        findNode: function(t, e) {
            var i;
            if (void 0 === e && (e = null), "string" == typeof e) i = t.findBySelector(e)[0];
            else if (fo(e)) {
                var n = t.model.isLink(), r = e.label;
                void 0 === r && (r = null);
                var o = e.port, a = e.selector;
                i = n && null !== r ? t.findLabelNode(r, a) : !n && o ? t.findPortNode(o, a) : t.findBySelector(a)[0];
            } else e && ((i = wr.toNode(e)) instanceof SVGElement || (i = null));
            return i || null;
        },
        mount: function() {
            var t = this.MOUNTABLE, e = this.cellView, i = this.el, n = this.options, r = this.transformGroup;
            if (t && !r) {
                var o = e.vel, a = e.paper, s = n.layer;
                if (s) {
                    var l = this.transformGroup = wr("g").addClass("highlight-transform").append(i);
                    a.getLayerView(s).insertSortedNode(l.node, n.z);
                } else i.parentNode && !i.nextSibling || o.append(i);
            }
        },
        unmount: function() {
            var t = this.MOUNTABLE, e = this.transformGroup, i = this.vel;
            t && (e ? (this.transformGroup = null, e.remove()) : i.remove());
        },
        transform: function() {
            var t = this.transformGroup, e = this.cellView, i = this.updateRequested;
            if (t && !e.model.isLink() && !i) {
                var n = e.getRootTranslateMatrix(), r = e.getRootRotateMatrix(), o = n.multiply(r);
                t.attr("transform", wr.matrixToTransformString(o));
            }
        },
        update: function() {
            var t = this.node, e = this.cellView, i = this.nodeSelector, n = this.updateRequested, r = this.id;
            if (!n) {
                var o = this.node = this.findNode(e, i);
                t && this.unhighlight(e, t), o ? (this.highlight(e, o), this.mount()) : (this.unmount(), e.notify("cell:highlight:invalid", r, this));
            }
        },
        onRemove: function() {
            var t = this.node, e = this.cellView, i = this.id, n = this.constructor;
            t && this.unhighlight(e, t), this.unmount(), n._removeRef(e, i);
        },
        highlight: function(t, e) {},
        unhighlight: function(t, e) {}
    }, {
        _views: {},
        highlight: function(t, e, i) {
            var n = this.uniqueId(e, i);
            this.add(t, e, n, i);
        },
        unhighlight: function(t, e, i) {
            var n = this.uniqueId(e, i);
            this.remove(t, n);
        },
        get: function(t, e) {
            void 0 === e && (e = null);
            var i = t.cid, n = this._views[i];
            if (null === e) {
                var r = [];
                if (!n) return r;
                for(var o in n){
                    var a = n[o];
                    a instanceof this && r.push(a);
                }
                return r;
            }
            if (!n) return null;
            if (e in n) {
                var s = n[e];
                if (s instanceof this) return s;
            }
            return null;
        },
        add: function(t, e, i, n) {
            if (void 0 === n && (n = {}), !i) throw new Error("dia.HighlighterView: An ID required.");
            var r = Ya.get(t, i);
            r && r.remove();
            var o = new this(n);
            return o.id = i, this._addRef(t, i, o), o.requestUpdate(t, e), o;
        },
        _addRef: function(t, e, i) {
            var n = t.cid, r = this._views, o = r[n];
            o || (o = r[n] = {}), o[e] = i;
        },
        _removeRef: function(t, e) {
            var i = t.cid, n = this._views, r = n[i];
            if (r) {
                for(var o in e && delete r[e], r)return;
                delete n[i];
            }
        },
        remove: function(t, e) {
            void 0 === e && (e = null), Ra(this.get(t, e)).forEach(function(t) {
                t.remove();
            });
        },
        update: function(t, e, i) {
            void 0 === e && (e = null), void 0 === i && (i = !1), Ra(this.get(t, e)).forEach(function(t) {
                (i || t.UPDATABLE) && t.update();
            });
        },
        transform: function(t, e) {
            void 0 === e && (e = null), Ra(this.get(t, e)).forEach(function(t) {
                t.UPDATABLE && t.transform();
            });
        },
        uniqueId: function(t, e) {
            return void 0 === e && (e = ""), wr.ensureId(t) + JSON.stringify(e);
        }
    }), Wa = {
        DEFAULT: "default",
        EMBEDDING: "embedding",
        CONNECTING: "connecting",
        MAGNET_AVAILABILITY: "magnetAvailability",
        ELEMENT_AVAILABILITY: "elementAvailability"
    }, Ua = Za.extend({
        tagName: "g",
        svgElement: !0,
        selector: "root",
        metrics: null,
        className: function() {
            var n = [
                "cell"
            ], t = this.model.get("type");
            return t && t.toLowerCase().split(".").forEach(function(t, e, i) {
                n.push("type-" + i.slice(0, e + 1).join("-"));
            }), n.join(" ");
        },
        _presentationAttributes: null,
        _flags: null,
        setFlags: function() {
            var t, e, i, n = {}, r = {}, o = 0, a = xo(this, "presentationAttributes");
            for(var s in a)if (a.hasOwnProperty(s)) {
                var l = a[s];
                for(Array.isArray(l) || (l = [
                    l
                ]), t = 0, e = l.length; t < e; t++){
                    var c = n[i = l[t]];
                    c || (c = n[i] = 1 << o++), r[s] |= c;
                }
            }
            var u = xo(this, "initFlag");
            for(Array.isArray(u) || (u = [
                u
            ]), t = 0, e = u.length; t < e; t++)n[i = u[t]] || (n[i] = 1 << o++);
            if (25 < o) throw new Error("dia.CellView: Maximum number of flags exceeded.");
            this._flags = n, this._presentationAttributes = r;
        },
        hasFlag: function(t, e) {
            return t & this.getFlag(e);
        },
        removeFlag: function(t, e) {
            return t ^ t & this.getFlag(e);
        },
        getFlag: function(t) {
            var e = this._flags;
            if (!e) return 0;
            var i = 0;
            if (Array.isArray(t)) for(var n = 0, r = t.length; n < r; n++)i |= e[t[n]];
            else i |= e[t];
            return i;
        },
        attributes: function() {
            var t = this.model;
            return {
                "model-id": t.id,
                "data-type": t.attributes.type
            };
        },
        constructor: function(t) {
            t.id = t.id || jr(this), Za.call(this, t);
        },
        initialize: function() {
            this.setFlags(), Za.prototype.initialize.apply(this, arguments), this.cleanNodesCache(), this.$el.data("view", this), this.startListening();
        },
        onMount: function() {},
        startListening: function() {
            this.listenTo(this.model, "change", this.onAttributesChange);
        },
        onAttributesChange: function(t, e) {
            var i = t.getChangeFlag(this._presentationAttributes);
            !e.updateHandled && i && (e.dirty && this.hasFlag(i, "UPDATE") && (i |= this.getFlag("RENDER")), e.tool && (e.async = !1), this.requestUpdate(i, e));
        },
        requestUpdate: function(t, e) {
            var i = this.paper;
            i && 0 < t && i.requestViewUpdate(this, t, this.UPDATE_PRIORITY, e);
        },
        parseDOMJSON: function(t, e) {
            var i = Mr(t), n = i.selectors, r = i.groupSelectors;
            for(var o in r){
                if (n[o]) throw new Error("dia.CellView: ambiguous group selector");
                n[o] = r[o];
            }
            if (e) {
                var a = this.selector;
                if (n[a]) throw new Error("dia.CellView: ambiguous root selector.");
                n[a] = e;
            }
            return {
                fragment: i.fragment,
                selectors: n
            };
        },
        can: function(t) {
            var e = go(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;
            return jo(e) && !1 !== e[t] || Po(e) && !1 !== e;
        },
        findBySelector: function(t, e, i) {
            if (e || (e = this.el), i || (i = this.selectors), !t || "." === t) return [
                e
            ];
            if (i) {
                var n = i[t];
                if (n) return Array.isArray(n) ? n : [
                    n
                ];
            }
            return br.useCSSSelectors ? S(e).find(t).toArray() : [];
        },
        notify: function(t) {
            if (this.paper) {
                var e = Array.prototype.slice.call(arguments, 1);
                this.trigger.apply(this, [
                    t
                ].concat(e)), this.paper.trigger.apply(this.paper, [
                    t,
                    this
                ].concat(e));
            }
        },
        getBBox: function(t) {
            var e;
            if (t && t.useModelGeometry) {
                var i = this.model;
                e = i.getBBox().bbox(i.angle());
            } else e = this.getNodeBBox(this.el);
            return this.paper.localToPaperRect(e);
        },
        getNodeBBox: function(t) {
            var e = this.getNodeBoundingRect(t), i = this.getNodeMatrix(t), n = this.getRootTranslateMatrix(), r = this.getRootRotateMatrix();
            return wr.transformRect(e, n.multiply(r).multiply(i));
        },
        getNodeUnrotatedBBox: function(t) {
            var e = this.getNodeBoundingRect(t), i = this.getNodeMatrix(t), n = this.getRootTranslateMatrix();
            return wr.transformRect(e, n.multiply(i));
        },
        getRootTranslateMatrix: function() {
            var t = this.model.position();
            return wr.createSVGMatrix().translate(t.x, t.y);
        },
        getRootRotateMatrix: function() {
            var t = wr.createSVGMatrix(), e = this.model, i = e.angle();
            if (i) {
                var n = e.getBBox(), r = n.width / 2, o = n.height / 2;
                t = t.translate(r, o).rotate(i).translate(-r, -o);
            }
            return t;
        },
        _notifyHighlight: function(t, e, i) {
            void 0 === i && (i = {});
            var n, r = this.el;
            if (n = "string" == typeof e ? void 0 === (n = this.findBySelector(e)[0]) ? r : n : void 0 === (n = this.$(e)[0]) ? r : n, i.partial = n !== r, void 0 === i.type) {
                var o;
                switch(!0){
                    case i.embedding:
                        o = Wa.EMBEDDING;
                        break;
                    case i.connecting:
                        o = Wa.CONNECTING;
                        break;
                    case i.magnetAvailability:
                        o = Wa.MAGNET_AVAILABILITY;
                        break;
                    case i.elementAvailability:
                        o = Wa.ELEMENT_AVAILABILITY;
                        break;
                    default:
                        o = Wa.DEFAULT;
                }
                i.type = o;
            }
            return this.notify(t, n, i), this;
        },
        highlight: function(t, e) {
            return this._notifyHighlight("cell:highlight", t, e);
        },
        unhighlight: function(t, e) {
            return void 0 === e && (e = {}), this._notifyHighlight("cell:unhighlight", t, e);
        },
        findMagnet: function(t) {
            var e = this.el, i = this.$(t)[0];
            i || (i = e);
            do {
                var n = i.getAttribute("magnet"), r = i === e;
                if ((n || r) && "false" !== n) return i;
                if (r) return;
                i = i.parentNode;
            }while (i);
        },
        findProxyNode: function(t, e) {
            t || (t = this.el);
            var i = t.getAttribute(e + "-selector");
            if (i) {
                var n = this.findBySelector(i)[0];
                if (n) return n;
            }
            return t;
        },
        getSelector: function(t, e) {
            var i;
            if (t === this.el) return "string" == typeof e && (i = "> " + e), i;
            if (t) {
                var n = wr(t).index() + 1;
                i = t.tagName + ":nth-child(" + n + ")", e && (i += " > " + e), i = this.getSelector(t.parentNode, i);
            }
            return i;
        },
        addLinkFromMagnet: function(t, e, i) {
            var n = this.paper, r = n.model, o = n.getDefaultLink(this, t);
            return o.set({
                source: this.getLinkEnd(t, e, i, o, "source"),
                target: {
                    x: e,
                    y: i
                }
            }).addTo(r, {
                async: !1,
                ui: !0
            }), o.findView(n);
        },
        getLinkEnd: function(t) {
            for(var e, i = [], n = arguments.length - 1; 0 < n--;)i[n] = arguments[n + 1];
            var r = this.model, o = r.id, a = this.findAttribute("port", t), s = t.getAttribute("joint-selector"), l = {
                id: o
            };
            return null != s && (l.magnet = s), null != a ? (l.port = a, r.hasPort(a) || s || (l.selector = this.getSelector(t))) : null == s && this.el !== t && (l.selector = this.getSelector(t)), (e = this).customizeLinkEnd.apply(e, [
                l,
                t
            ].concat(i));
        },
        customizeLinkEnd: function(t, e, i, n, r, o) {
            var a = this.paper, s = a.options.connectionStrategy;
            if ("function" == typeof s) {
                var l = s.call(a, t, this, e, new qi(i, n), r, o, a);
                if (l) return l;
            }
            return t;
        },
        getMagnetFromLinkEnd: function(t) {
            var e, i = this.el, n = t.port, r = t.magnet, o = this.model;
            return e = null != n && o.isElement() && o.hasPort(n) ? this.findPortNode(n, r) || i : (r || (r = t.selector), r || null == n || (r = '[port="' + n + '"]'), this.findBySelector(r, i, this.selectors)[0]), this.findProxyNode(e, "magnet");
        },
        dragLinkStart: function(t, e, i, n) {
            this.model.startBatch("add-link");
            var r = this.addLinkFromMagnet(e, i, n);
            r.notifyPointerdown(t, i, n), r.eventData(t, r.startArrowheadMove("target", {
                whenNotAllowed: "remove"
            })), this.eventData(t, {
                linkView: r
            });
        },
        dragLink: function(t, e, i) {
            var n = this.eventData(t), r = n.linkView;
            if (r) r.pointermove(t, e, i);
            else {
                var o = this.paper, a = o.options.magnetThreshold, s = this.getEventTarget(t), l = n.targetMagnet;
                if ("onleave" === a) {
                    if (l === s || wr(l).contains(s)) return;
                } else if (o.eventData(t).mousemoved <= a) return;
                this.dragLinkStart(t, l, e, i);
            }
        },
        dragLinkEnd: function(t, e, i) {
            var n = this.eventData(t).linkView;
            n && (n.pointerup(t, e, i), this.model.stopBatch("add-link"));
        },
        getAttributeDefinition: function(t) {
            return this.model.constructor.getAttributeDefinition(t);
        },
        setNodeAttributes: function(t, e) {
            uo(e) || (t instanceof SVGElement ? wr(t).attr(e) : S(t).attr(e));
        },
        processNodeAttributes: function(t, e) {
            var i, n, r, o, a, s, l, c, u, h = [];
            for(i in e)e.hasOwnProperty(i) && (n = e[i], !(r = this.getAttributeDefinition(i)) || go(r.qualify) && !r.qualify.call(this, n, t, e) ? (s || (s = {}), s[Zr(i)] = n) : (Go(r.set) && (s || (s = {}), s[r.set] = n), null !== n && h.push(i, r)));
            for(o = 0, a = h.length; o < a; o += 2)i = h[o], r = h[o + 1], n = e[i], go(r.set) && (l || (l = {}), l[i] = n), go(r.position) && (c || (c = {}), c[i] = n), go(r.offset) && (u || (u = {}), u[i] = n);
            return {
                raw: e,
                normal: s,
                set: l,
                position: c,
                offset: u
            };
        },
        updateRelativeAttributes: function(t, e, i, n) {
            var r, o;
            n || (n = {});
            var a = e.raw || {}, s = e.normal || {}, l = e.set, c = e.position, u = e.offset;
            for(r in l){
                o = l[r];
                var h = this.getAttributeDefinition(r).set.call(this, o, i.clone(), t, a);
                jo(h) ? io(s, h) : void 0 !== h && (s[r] = h);
            }
            if (t instanceof HTMLElement) this.setNodeAttributes(t, s);
            else {
                var g, d, f, p = s.transform, m = wr.transformStringToMatrix(p), I = qi(m.e, m.f);
                if (p && (s = Mo(s, "transform"), m.e = m.f = 0), c || u) {
                    var v = this.getNodeScale(t, n.scalableNode);
                    g = v.sx, d = v.sy;
                }
                var A = !1;
                for(r in c)o = c[r], (f = this.getAttributeDefinition(r).position.call(this, o, i.clone(), t, a)) && (I.offset(qi(f).scale(g, d)), A || (A = !0));
                this.setNodeAttributes(t, s);
                var C = !1;
                if (u) {
                    var y = this.getNodeBoundingRect(t);
                    if (0 < y.width && 0 < y.height) {
                        var w = wr.transformRect(y, m).scale(1 / g, 1 / d);
                        for(r in u)o = u[r], (f = this.getAttributeDefinition(r).offset.call(this, o, w, t, a)) && (I.offset(qi(f).scale(g, d)), C || (C = !0));
                    }
                }
                (void 0 !== p || A || C) && (I.round(1), m.e = I.x, m.f = I.y, t.setAttribute("transform", wr.matrixToTransformString(m)));
            }
        },
        getNodeScale: function(t, e) {
            var i, n;
            if (e && e.contains(t)) {
                var r = e.scale();
                i = 1 / r.sx, n = 1 / r.sy;
            } else n = i = 1;
            return {
                sx: i,
                sy: n
            };
        },
        cleanNodesCache: function() {
            this.metrics = {};
        },
        nodeCache: function(t) {
            var e = this.metrics;
            if (!e) return {};
            var i = wr.ensureId(t), n = e[i];
            return n || (n = e[i] = {}), n;
        },
        getNodeData: function(t) {
            var e = this.nodeCache(t);
            return e.data || (e.data = {}), e.data;
        },
        getNodeBoundingRect: function(t) {
            var e = this.nodeCache(t);
            return void 0 === e.boundingRect && (e.boundingRect = wr(t).getBBox()), new In(e.boundingRect);
        },
        getNodeMatrix: function(t) {
            var e = this.nodeCache(t);
            if (void 0 === e.magnetMatrix) {
                var i = this.rotatableNode || this.el;
                e.magnetMatrix = wr(t).getTransformToElement(i);
            }
            return wr.createSVGMatrix(e.magnetMatrix);
        },
        getNodeShape: function(t) {
            var e = this.nodeCache(t);
            return void 0 === e.geometryShape && (e.geometryShape = wr(t).toGeometryShape()), e.geometryShape.clone();
        },
        isNodeConnection: function(t) {
            return this.model.isLink() && (!t || t === this.el);
        },
        findNodesAttributes: function(t, e, i, n) {
            var r, o, a, s, l = {}, c = [];
            for(var u in t)if (t.hasOwnProperty(u) && (a = t[u], fo(a))) {
                var h = i[u] = this.findBySelector(u, e, n);
                for(r = 0, o = h.length; r < o; r++){
                    var g = h[r];
                    s = wr.ensureId(g);
                    var d = n && n[u] === g, f = l[s];
                    if (f) {
                        f.array || (c.push(s), f.array = !0, f.attributes = [
                            f.attributes
                        ], f.selectedLength = [
                            f.selectedLength
                        ]);
                        var p = f.attributes, m = f.selectedLength;
                        if (d) p.unshift(a), m.unshift(-1);
                        else {
                            var I = ao(m, o);
                            p.splice(I, 0, a), m.splice(I, 0, o);
                        }
                    } else l[s] = {
                        attributes: a,
                        selectedLength: d ? -1 : o,
                        node: g,
                        array: !1
                    };
                }
            }
            for(r = 0, o = c.length; r < o; r++)(a = l[s = c[r]]).attributes = zo.apply(void 0, [
                {}
            ].concat(a.attributes.reverse()));
            return l;
        },
        getEventTarget: function(t, e) {
            void 0 === e && (e = {});
            var i = t.target, n = t.type, r = t.clientX;
            void 0 === r && (r = 0);
            var o = t.clientY;
            return void 0 === o && (o = 0), e.fromPoint || "touchmove" === n || "touchend" === n ? document.elementFromPoint(r, o) : i;
        },
        updateDOMSubtreeAttributes: function(t, e, i) {
            i || (i = {}), i.rootBBox || (i.rootBBox = In()), i.selectors || (i.selectors = this.selectors);
            var n, r, o, a, s, l, c = {}, u = {}, h = [], g = [], d = i.roAttributes, f = this.findNodesAttributes(d || e, t, c, i.selectors), p = d ? this.findNodesAttributes(e, t, c, i.selectors) : f;
            for(var m in f)if (o = (a = f[m]).attributes, r = a.node, (s = this.processNodeAttributes(r, o)).set || s.position || s.offset) {
                var I, v = p[m] && p[m].attributes, A = v && void 0 === o.ref ? v.ref : o.ref;
                if (A) {
                    if (!(I = (c[A] || this.findBySelector(A, t, i.selectors))[0])) throw new Error('dia.CellView: "' + A + '" reference does not exist.');
                } else I = null;
                if (n = {
                    node: r,
                    refNode: I,
                    processedAttributes: s,
                    allAttributes: v
                }, I) {
                    var C = g.findIndex(function(t) {
                        return t.refNode === r;
                    });
                    -1 < C ? g.splice(C, 0, n) : g.push(n);
                } else h.push(n);
            } else this.setNodeAttributes(r, s.normal);
            h.push.apply(h, g);
            for(var y = 0, w = h.length; y < w; y++){
                n = h[y], r = n.node, I = n.refNode;
                var b = wr(i.rotatableNode), N = I ? wr.ensureId(I) : "", x = !!b && !!I && b.contains(I), M = u[N];
                if (!M) {
                    var S = x ? b : t;
                    M = u[N] = I ? wr(I).getBBox({
                        target: S
                    }) : i.rootBBox;
                }
                d ? (s = this.processNodeAttributes(r, n.allAttributes), this.mergeProcessedAttributes(s, n.processedAttributes)) : s = n.processedAttributes;
                var k = M;
                x && !b.contains(r) && (l || (l = wr.transformStringToMatrix(b.attr("transform"))), k = wr.transformRect(M, l)), this.updateRelativeAttributes(r, s, k, i);
            }
        },
        mergeProcessedAttributes: function(t, e) {
            t.set || (t.set = {}), t.position || (t.position = {}), t.offset || (t.offset = {}), io(t.set, e.set), io(t.position, e.position), io(t.offset, e.offset);
            var i = t.normal && t.normal.transform;
            void 0 !== i && e.normal && (e.normal.transform = i), t.normal = e.normal;
        },
        onRemove: function() {
            this.removeTools(), this.removeHighlighters();
        },
        _toolsView: null,
        hasTools: function(t) {
            var e = this._toolsView;
            return !!e && (!t || e.getName() === t);
        },
        addTools: function(t) {
            return this.removeTools(), t && ((this._toolsView = t).configure({
                relatedView: this
            }), t.listenTo(this.paper, "tools:event", this.onToolEvent.bind(this))), this;
        },
        updateTools: function(t) {
            var e = this._toolsView;
            return e && e.update(t), this;
        },
        removeTools: function() {
            var t = this._toolsView;
            return t && (t.remove(), this._toolsView = null), this;
        },
        hideTools: function() {
            var t = this._toolsView;
            return t && t.hide(), this;
        },
        showTools: function() {
            var t = this._toolsView;
            return t && t.show(), this;
        },
        onToolEvent: function(t) {
            switch(t){
                case "remove":
                    this.removeTools();
                    break;
                case "hide":
                    this.hideTools();
                    break;
                case "show":
                    this.showTools();
            }
        },
        removeHighlighters: function() {
            Ya.remove(this);
        },
        updateHighlighters: function(t) {
            void 0 === t && (t = !1), Ya.update(this, null, t);
        },
        transformHighlighters: function() {
            Ya.transform(this);
        },
        pointerdblclick: function(t, e, i) {
            this.notify("cell:pointerdblclick", t, e, i);
        },
        pointerclick: function(t, e, i) {
            this.notify("cell:pointerclick", t, e, i);
        },
        contextmenu: function(t, e, i) {
            this.notify("cell:contextmenu", t, e, i);
        },
        pointerdown: function(t, e, i) {
            var n = this.model, r = n.graph;
            r && (n.startBatch("pointer"), this.eventData(t, {
                graph: r
            })), this.notify("cell:pointerdown", t, e, i);
        },
        pointermove: function(t, e, i) {
            this.notify("cell:pointermove", t, e, i);
        },
        pointerup: function(t, e, i) {
            var n = this.eventData(t).graph;
            this.notify("cell:pointerup", t, e, i), n && n.stopBatch("pointer", {
                cell: this.model
            });
        },
        mouseover: function(t) {
            this.notify("cell:mouseover", t);
        },
        mouseout: function(t) {
            this.notify("cell:mouseout", t);
        },
        mouseenter: function(t) {
            this.notify("cell:mouseenter", t);
        },
        mouseleave: function(t) {
            this.notify("cell:mouseleave", t);
        },
        mousewheel: function(t, e, i, n) {
            this.notify("cell:mousewheel", t, e, i, n);
        },
        onevent: function(t, e, i, n) {
            this.notify(e, t, i, n);
        },
        onmagnet: function() {},
        magnetpointerdblclick: function() {},
        magnetcontextmenu: function() {},
        checkMouseleave: function(t) {
            var e = this.paper;
            e.isAsync() && e.dumpView(this);
            var i = this.getEventTarget(t, {
                fromPoint: !0
            }), n = e.findView(i);
            n !== this && (this.mouseleave(t), n && n.mouseenter(t));
        },
        setInteractivity: function(t) {
            this.options.interactive = t;
        }
    }, {
        Highlighting: Wa,
        addPresentationAttributes: function(t) {
            return zo({}, xo(this.prototype, "presentationAttributes"), t, function(t, e) {
                if (t && e) return "string" == typeof t && (t = [
                    t
                ]), "string" == typeof e && (e = [
                    e
                ]), Array.isArray(t) && Array.isArray(e) ? so(t.concat(e)) : void 0;
            });
        }
    }), Fa = {
        UPDATE: "UPDATE",
        TRANSLATE: "TRANSLATE",
        TOOLS: "TOOLS",
        RESIZE: "RESIZE",
        PORTS: "PORTS",
        ROTATE: "ROTATE",
        RENDER: "RENDER"
    }, Va = Ua.extend({
        _removePorts: function() {},
        _renderPorts: function() {},
        className: function() {
            var t = Ua.prototype.className.apply(this).split(" ");
            return t.push("element"), t.join(" ");
        },
        initialize: function() {
            Ua.prototype.initialize.apply(this, arguments), this._initializePorts();
        },
        presentationAttributes: {
            attrs: [
                Fa.UPDATE
            ],
            position: [
                Fa.TRANSLATE,
                Fa.TOOLS
            ],
            size: [
                Fa.RESIZE,
                Fa.PORTS,
                Fa.TOOLS
            ],
            angle: [
                Fa.ROTATE,
                Fa.TOOLS
            ],
            markup: [
                Fa.RENDER
            ],
            ports: [
                Fa.PORTS
            ]
        },
        initFlag: [
            Fa.RENDER
        ],
        UPDATE_PRIORITY: 0,
        confirmUpdate: function(t, e) {
            var i = br.useCSSSelectors;
            this.hasFlag(t, Fa.PORTS) && (this._removePorts(), this._cleanPortsCache());
            var n = !1;
            if (this.hasFlag(t, Fa.RENDER)) this.render(), this.updateTools(e), this.updateHighlighters(!0), n = !0, t = this.removeFlag(t, [
                Fa.RENDER,
                Fa.UPDATE,
                Fa.RESIZE,
                Fa.TRANSLATE,
                Fa.ROTATE,
                Fa.PORTS,
                Fa.TOOLS
            ]);
            else {
                var r = !1;
                this.hasFlag(t, Fa.RESIZE) && (this.resize(e), r = !0, t = this.removeFlag(t, [
                    Fa.RESIZE,
                    Fa.UPDATE
                ])), this.hasFlag(t, Fa.UPDATE) && (this.update(this.model, null, e), t = this.removeFlag(t, Fa.UPDATE), r = !0, i && (t = this.removeFlag(t, Fa.PORTS))), this.hasFlag(t, Fa.TRANSLATE) && (this.translate(), t = this.removeFlag(t, Fa.TRANSLATE), n = !0), this.hasFlag(t, Fa.ROTATE) && (this.rotate(), t = this.removeFlag(t, Fa.ROTATE), n = !0), this.hasFlag(t, Fa.PORTS) && (this._renderPorts(), r = !0, t = this.removeFlag(t, Fa.PORTS)), r && this.updateHighlighters(!1);
            }
            return n && this.transformHighlighters(), this.hasFlag(t, Fa.TOOLS) && (this.updateTools(e), t = this.removeFlag(t, Fa.TOOLS)), t;
        },
        _initializePorts: function() {},
        update: function(t, e) {
            this.cleanNodesCache();
            var i = br.useCSSSelectors;
            i && this._removePorts();
            var n = this.model, r = n.attr();
            this.updateDOMSubtreeAttributes(this.el, r, {
                rootBBox: new In(n.size()),
                selectors: this.selectors,
                scalableNode: this.scalableNode,
                rotatableNode: this.rotatableNode,
                roAttributes: e === r ? null : e
            }), i && this._renderPorts();
        },
        rotatableSelector: "rotatable",
        scalableSelector: "scalable",
        scalableNode: null,
        rotatableNode: null,
        renderMarkup: function() {
            var t = this.model, e = t.get("markup") || t.markup;
            if (!e) throw new Error("dia.ElementView: markup required");
            if (Array.isArray(e)) return this.renderJSONMarkup(e);
            if ("string" == typeof e) return this.renderStringMarkup(e);
            throw new Error("dia.ElementView: invalid markup");
        },
        renderJSONMarkup: function(t) {
            var e = this.parseDOMJSON(t, this.el), i = this.selectors = e.selectors;
            this.rotatableNode = wr(i[this.rotatableSelector]) || null, this.scalableNode = wr(i[this.scalableSelector]) || null, this.vel.append(e.fragment);
        },
        renderStringMarkup: function(t) {
            var e = this.vel;
            e.append(wr(t)), this.rotatableNode = e.findOne(".rotatable"), this.scalableNode = e.findOne(".scalable"), (this.selectors = {})[this.selector] = this.el;
        },
        render: function() {
            return this.vel.empty(), this.renderMarkup(), this.scalableNode && this.update(), this.resize(), this.rotatableNode ? (this.rotate(), this.translate()) : this.updateTransformation(), br.useCSSSelectors || this._renderPorts(), this;
        },
        resize: function(t) {
            if (this.scalableNode) return this.sgResize(t);
            this.model.attributes.angle && this.rotate(), this.update();
        },
        translate: function() {
            if (this.rotatableNode) return this.rgTranslate();
            this.updateTransformation();
        },
        rotate: function() {
            if (this.rotatableNode) return this.rgRotate(), void this.update();
            this.updateTransformation();
        },
        updateTransformation: function() {
            var t = this.getTranslateString(), e = this.getRotateString();
            e && (t += " " + e), this.vel.attr("transform", t);
        },
        getTranslateString: function() {
            var t = this.model.attributes.position;
            return "translate(" + t.x + "," + t.y + ")";
        },
        getRotateString: function() {
            var t = this.model.attributes, e = t.angle;
            if (!e) return null;
            var i = t.size;
            return "rotate(" + e + "," + i.width / 2 + "," + i.height / 2 + ")";
        },
        rgRotate: function() {
            this.rotatableNode.attr("transform", this.getRotateString());
        },
        rgTranslate: function() {
            this.vel.attr("transform", this.getTranslateString());
        },
        sgResize: function(t) {
            var e = this.model, i = e.angle(), n = e.size(), r = this.scalableNode, o = !1;
            0 < r.node.getElementsByTagName("path").length && (o = !0);
            var a = r.getBBox({
                recursive: o
            }), s = n.width / (a.width || 1), l = n.height / (a.height || 1);
            r.attr("transform", "scale(" + s + "," + l + ")");
            var c = this.rotatableNode, u = c && c.attr("transform");
            if (u) {
                c.attr("transform", u + " rotate(" + -i + "," + n.width / 2 + "," + n.height / 2 + ")");
                var h = r.getBBox({
                    target: this.paper.cells
                });
                e.set("position", {
                    x: h.x,
                    y: h.y
                }, io({
                    updateHandled: !0
                }, t)), this.translate(), this.rotate();
            }
            this.update();
        },
        prepareEmbedding: function(t) {
            void 0 === t && (t = {});
            var e = t.model || this.model, i = (t.paper || this.paper).model, n = t.initialZIndices = {}, r = e.getEmbeddedCells({
                deep: !0
            }), o = i.getConnectedLinks(e, {
                deep: !0,
                includeEnclosed: !0
            });
            [
                e
            ].concat(r, o).forEach(function(t) {
                return n[t.id] = t.attributes.z;
            }), e.startBatch("to-front"), e.toFront({
                deep: !0,
                ui: !0
            });
            var a = i.getElements().reduce(function(t, e) {
                return Math.max(t, e.attributes.z || 0);
            }, 0);
            o.forEach(function(t) {
                t.attributes.z <= a && t.set("z", a + 1, {
                    ui: !0
                });
            }), e.stopBatch("to-front");
            var s = e.parent();
            s ? (i.getCell(s).unembed(e, {
                ui: !0
            }), t.initialParentId = s) : t.initialParentId = null;
        },
        processEmbedding: function(t, e, i, n) {
            void 0 === t && (t = {});
            var r, o = t.model || this.model, a = t.paper || this.paper, s = a.model, l = a.options, c = l.findParentBy, u = l.frontParentOnly, h = l.validateEmbedding;
            r = (r = go(c) ? po(c.call(s, this, e, i, n)) : "pointer" === c ? po(s.findModelsFromPoint({
                x: i,
                y: n
            })) : s.findModelsUnderElement(o, {
                searchBy: c
            })).filter(function(t) {
                return t instanceof ga && o.id !== t.id && !t.isEmbeddedIn(o);
            }), u && (r = r.slice(-1));
            for(var g = null, d = t.candidateEmbedView, f = r.length - 1; 0 <= f; f--){
                var p = r[f];
                if (d && d.model.id == p.id) {
                    g = d;
                    break;
                }
                var m = p.findView(a);
                if (!go(h) || h.call(a, this, m)) {
                    g = m;
                    break;
                }
            }
            g && g != d && (this.clearEmbedding(t), t.candidateEmbedView = g.highlight(g.findProxyNode(null, "container"), {
                embedding: !0
            })), !g && d && this.clearEmbedding(t);
        },
        clearEmbedding: function(t) {
            t || (t = {});
            var e = t.candidateEmbedView;
            e && (e.unhighlight(e.findProxyNode(null, "container"), {
                embedding: !0
            }), t.candidateEmbedView = null);
        },
        finalizeEmbedding: function(t) {
            void 0 === t && (t = {});
            var e = t.candidateEmbedView, i = t.model || this.model, n = t.paper || this.paper;
            if (e) e.model.embed(i, {
                ui: !0
            }), e.unhighlight(e.findProxyNode(null, "container"), {
                embedding: !0
            }), t.candidateEmbedView = null;
            else {
                var r = n.options.validateUnembedding;
                if (t.initialParentId && "function" == typeof r && !r.call(n, this)) return void this._disallowUnembed(t);
            }
            n.model.getConnectedLinks(i, {
                deep: !0
            }).forEach(function(t) {
                t.reparent({
                    ui: !0
                });
            });
        },
        _disallowUnembed: function(t) {
            var e = t.model, i = t.whenNotAllowed;
            void 0 === i && (i = "revert");
            var n = e || this.model, r = (t.paper || this.paper).model;
            switch(i){
                case "remove":
                    n.remove({
                        ui: !0
                    });
                    break;
                case "revert":
                    var o = t.initialParentId, a = t.initialPosition, s = t.initialZIndices;
                    if (a) {
                        var l = a.x, c = a.y;
                        n.position(l, c, {
                            deep: !0,
                            ui: !0
                        });
                    }
                    s && Object.keys(s).forEach(function(t) {
                        var e = r.getCell(t);
                        e && e.set("z", s[t], {
                            ui: !0
                        });
                    });
                    var u = r.getCell(o);
                    u && u.embed(n, {
                        ui: !0
                    });
            }
        },
        getDelegatedView: function() {
            for(var t = this, e = t.model, i = t.paper; t && !e.isLink();){
                if (!e.isEmbedded() || t.can("stopDelegation")) return t;
                e = e.getParentCell(), t = i.findViewByModel(e);
            }
            return null;
        },
        findProxyNode: function(t, e) {
            t || (t = this.el);
            var i = t.getAttribute(e + "-selector");
            if (i) {
                var n = this.findAttribute("port", t);
                if (n) {
                    var r = this.findPortNode(n, i);
                    if (r) return r;
                } else {
                    var o = this.findBySelector(i)[0];
                    if (o) return o;
                }
            }
            return t;
        },
        notifyPointerdown: function(t, e, i) {
            Ua.prototype.pointerdown.call(this, t, e, i), this.notify("element:pointerdown", t, e, i);
        },
        notifyPointermove: function(t, e, i) {
            Ua.prototype.pointermove.call(this, t, e, i), this.notify("element:pointermove", t, e, i);
        },
        notifyPointerup: function(t, e, i) {
            this.notify("element:pointerup", t, e, i), Ua.prototype.pointerup.call(this, t, e, i);
        },
        pointerdblclick: function(t, e, i) {
            Ua.prototype.pointerdblclick.apply(this, arguments), this.notify("element:pointerdblclick", t, e, i);
        },
        pointerclick: function(t, e, i) {
            Ua.prototype.pointerclick.apply(this, arguments), this.notify("element:pointerclick", t, e, i);
        },
        contextmenu: function(t, e, i) {
            Ua.prototype.contextmenu.apply(this, arguments), this.notify("element:contextmenu", t, e, i);
        },
        pointerdown: function(t, e, i) {
            this.isPropagationStopped(t) || (this.notifyPointerdown(t, e, i), this.dragStart(t, e, i));
        },
        pointermove: function(t, e, i) {
            var n = this.eventData(t);
            switch(n.action){
                case "magnet":
                    this.dragMagnet(t, e, i);
                    break;
                case "move":
                    (n.delegatedView || this).drag(t, e, i);
                default:
                    this.notifyPointermove(t, e, i);
            }
            this.eventData(t, n);
        },
        pointerup: function(t, e, i) {
            var n = this.eventData(t);
            switch(n.action){
                case "magnet":
                    this.dragMagnetEnd(t, e, i);
                    break;
                case "move":
                    (n.delegatedView || this).dragEnd(t, e, i);
                default:
                    this.notifyPointerup(t, e, i);
            }
            var r = n.targetMagnet;
            r && this.magnetpointerclick(t, r, e, i), this.checkMouseleave(t);
        },
        mouseover: function(t) {
            Ua.prototype.mouseover.apply(this, arguments), this.notify("element:mouseover", t);
        },
        mouseout: function(t) {
            Ua.prototype.mouseout.apply(this, arguments), this.notify("element:mouseout", t);
        },
        mouseenter: function(t) {
            Ua.prototype.mouseenter.apply(this, arguments), this.notify("element:mouseenter", t);
        },
        mouseleave: function(t) {
            Ua.prototype.mouseleave.apply(this, arguments), this.notify("element:mouseleave", t);
        },
        mousewheel: function(t, e, i, n) {
            Ua.prototype.mousewheel.apply(this, arguments), this.notify("element:mousewheel", t, e, i, n);
        },
        onmagnet: function(t, e, i) {
            this.dragMagnetStart(t, e, i);
        },
        magnetpointerdblclick: function(t, e, i, n) {
            this.notify("element:magnet:pointerdblclick", t, e, i, n);
        },
        magnetcontextmenu: function(t, e, i, n) {
            this.notify("element:magnet:contextmenu", t, e, i, n);
        },
        dragStart: function(t, e, i) {
            var n = this.getDelegatedView();
            if (n && n.can("elementMove")) {
                this.eventData(t, {
                    action: "move",
                    delegatedView: n
                });
                var r = n.model.position();
                n.eventData(t, {
                    initialPosition: r,
                    pointerOffset: r.difference(e, i),
                    restrictedArea: this.paper.getRestrictedArea(n, e, i)
                });
            }
        },
        dragMagnetStart: function(t, e, i) {
            if (this.can("addLinkFromMagnet")) {
                var n = t.currentTarget, r = this.paper;
                this.eventData(t, {
                    targetMagnet: n
                }), t.stopPropagation(), r.options.validateMagnet(this, n, t) ? (r.options.magnetThreshold <= 0 && this.dragLinkStart(t, n, e, i), this.eventData(t, {
                    action: "magnet"
                }), this.stopPropagation(t)) : this.pointerdown(t, e, i), r.delegateDragEvents(this, t.data);
            }
        },
        drag: function(t, e, i) {
            var n = this.paper, r = n.options.gridSize, o = this.model, a = this.eventData(t), s = a.pointerOffset, l = a.restrictedArea, c = a.embedding, u = Li(e + s.x, r), h = Li(i + s.y, r);
            o.position(u, h, {
                restrictedArea: l,
                deep: !0,
                ui: !0
            }), n.options.embeddingMode && (c || (this.prepareEmbedding(a), c = !0), this.processEmbedding(a, t, e, i)), this.eventData(t, {
                embedding: c
            });
        },
        dragMagnet: function(t, e, i) {
            this.dragLink(t, e, i);
        },
        dragEnd: function(t, e, i) {
            var n = this.eventData(t);
            n.embedding && this.finalizeEmbedding(n);
        },
        dragMagnetEnd: function(t, e, i) {
            this.dragLinkEnd(t, e, i);
        },
        magnetpointerclick: function(t, e, i, n) {
            var r = this.paper;
            r.eventData(t).mousemoved > r.options.clickThreshold || this.notify("element:magnet:pointerclick", t, e, i, n);
        }
    }, {
        Flags: Fa
    });
    io(Va.prototype, Ta);
    var Xa = {
        N: "S",
        S: "N",
        E: "W",
        W: "E"
    }, Ha = {
        N: -Math.PI / 2 * 3,
        S: -Math.PI / 2,
        E: 0,
        W: Math.PI
    };
    function Ja(t, e, i) {
        var n = new qi(t.x, e.y);
        return i.containsPoint(n) && (n = new qi(e.x, t.y)), n;
    }
    function _a(t, e) {
        return t["W" === e || "E" === e ? "width" : "height"];
    }
    function Qa(t, e) {
        return t.x === e.x ? t.y > e.y ? "N" : "S" : t.y === e.y ? t.x > e.x ? "W" : "E" : null;
    }
    function Ka(t) {
        return new In(t.x, t.y, 0, 0);
    }
    function qa(t) {
        var e = Xr(t.padding || t.elementPadding || 20);
        return {
            x: -e.left,
            y: -e.top,
            width: e.left + e.right,
            height: e.top + e.bottom
        };
    }
    function $a(t, e) {
        return t.sourceBBox.clone().moveAndExpand(qa(e));
    }
    function ts(t, e) {
        return t.targetBBox.clone().moveAndExpand(qa(e));
    }
    function es(t, e, i) {
        var n = new qi(t.x, e.y), r = new qi(e.x, t.y), o = Qa(t, n), a = Qa(t, r), s = Xa[i], l = o === i || o !== s && (a === s || a !== i) ? n : r;
        return {
            points: [
                l
            ],
            direction: Qa(l, e)
        };
    }
    function is(t, e, i) {
        var n = Ja(t, e, i);
        return {
            points: [
                n
            ],
            direction: Qa(n, e)
        };
    }
    function ns(e, t, i, n) {
        var r, o = {}, a = [
            new qi(e.x, t.y),
            new qi(t.x, e.y)
        ], s = a.filter(function(t) {
            return !i.containsPoint(t);
        }), l = s.filter(function(t) {
            return Qa(t, e) !== n;
        });
        if (0 < l.length) r = (r = l.filter(function(t) {
            return Qa(e, t) === n;
        }).pop()) || l[0], o.points = [
            r
        ], o.direction = Qa(r, t);
        else {
            r = yo(a, s)[0];
            var c = new qi(t).move(r, -_a(i, n) / 2), u = Ja(c, e, i);
            o.points = [
                u,
                c
            ], o.direction = Qa(c, t);
        }
        return o;
    }
    function rs(t, e, i, n) {
        var r = is(e, t, n), o = r.points[0];
        if (i.containsPoint(o)) {
            var a = (r = is(t, e, i)).points[0];
            if (n.containsPoint(a)) {
                var s = new qi(t).move(a, -_a(i, Qa(t, a)) / 2), l = new qi(e).move(o, -_a(n, Qa(e, o)) / 2), c = new nn(s, l).midpoint(), u = is(t, c, i), h = es(c, e, u.direction);
                r.points = [
                    u.points[0],
                    h.points[0]
                ], r.direction = h.direction;
            }
        }
        return r;
    }
    function os(t, e, i, n, r) {
        var o, a, s, l = {}, c = i.union(n).inflate(1), u = c.center().distance(e) > c.center().distance(t), h = u ? e : t, g = u ? t : e;
        return a = Ja(o = r ? (o = qi.fromPolar(c.width + c.height, Ha[r], h), c.pointNearestToPoint(o).move(o, -1)) : c.pointNearestToPoint(h).move(h, 1), g, c), o.round().equals(a.round()) ? (a = qi.fromPolar(c.width + c.height, Pi(o.theta(h)) + Math.PI / 2, g), s = Ja(o, a = c.pointNearestToPoint(a).move(g, 1).round(), c), l.points = u ? [
            a,
            s,
            o
        ] : [
            o,
            s,
            a
        ]) : l.points = u ? [
            a,
            o
        ] : [
            o,
            a
        ], l.direction = Qa(u ? o : a, e), l;
    }
    function as(t, e, i) {
        var n, r, o, a, s, l = $a(i, e), c = ts(i, e), u = (r = e, (n = i).sourceAnchor ? n.sourceAnchor : $a(n, r).center()), h = (a = e, (o = i).targetAnchor ? o.targetAnchor : ts(o, a).center());
        l = l.union(Ka(u)), c = c.union(Ka(h)), (t = po(t).map(qi)).unshift(u), t.push(h);
        for(var g = [], d = 0, f = t.length - 1; d < f; d++){
            var p = null, m = t[d], I = t[d + 1], v = !!Qa(m, I);
            if (0 === d) d + 1 === f ? l.intersect(c.clone().inflate(1)) ? p = os(m, I, l, c) : v || (p = rs(m, I, l, c)) : l.containsPoint(I) ? p = os(m, I, l, Ka(I).moveAndExpand(qa(e))) : v || (p = is(m, I, l));
            else if (d + 1 === f) {
                var A = v && Qa(I, m) === s;
                c.containsPoint(m) || A ? p = os(m, I, Ka(m).moveAndExpand(qa(e)), c, s) : v || (p = ns(m, I, c, s));
            } else v || (p = es(m, I, s));
            s = p ? (Array.prototype.push.apply(g, p.points), p.direction) : Qa(m, I), d + 1 < f && g.push(I);
        }
        return g;
    }
    var ss = {
        step: 10,
        maximumLoops: 2e3,
        precision: 1,
        maxAllowedDirectionChange: 90,
        perpendicular: !0,
        excludeEnds: [],
        excludeTypes: [
            "basic.Text"
        ],
        startDirections: [
            "top",
            "right",
            "bottom",
            "left"
        ],
        endDirections: [
            "top",
            "right",
            "bottom",
            "left"
        ],
        directionMap: {
            top: {
                x: 0,
                y: -1
            },
            right: {
                x: 1,
                y: 0
            },
            bottom: {
                x: 0,
                y: 1
            },
            left: {
                x: -1,
                y: 0
            }
        },
        cost: function() {
            return this.step;
        },
        directions: function() {
            var t = this.step, e = this.cost();
            return [
                {
                    offsetX: t,
                    offsetY: 0,
                    cost: e
                },
                {
                    offsetX: -t,
                    offsetY: 0,
                    cost: e
                },
                {
                    offsetX: 0,
                    offsetY: t,
                    cost: e
                },
                {
                    offsetX: 0,
                    offsetY: -t,
                    cost: e
                }
            ];
        },
        penalties: function() {
            return {
                0: 0,
                45: this.step / 2,
                90: this.step / 2
            };
        },
        paddingBox: function() {
            var t = this.step;
            return {
                x: -t,
                y: -t,
                width: 2 * t,
                height: 2 * t
            };
        },
        isPointObstacle: null,
        fallbackRouter: function(t, e, i) {
            if (!go(as)) throw new Error("Manhattan requires the orthogonal router as default fallback.");
            return as(t, io({}, ss, e), i);
        },
        fallbackRoute: function(t, e, i) {
            return null;
        },
        draggingRoute: null
    };
    function ls(t) {
        this.map = {}, this.options = t, this.mapGridSize = 100;
    }
    function cs() {
        this.items = [], this.hash = {}, this.values = {}, this.OPEN = 1, this.CLOSE = 2;
    }
    function us(t, e) {
        return e && e.paddingBox ? t.sourceBBox.clone().moveAndExpand(e.paddingBox) : t.sourceBBox.clone();
    }
    function hs(t, e) {
        return e && e.paddingBox ? t.targetBBox.clone().moveAndExpand(e.paddingBox) : t.targetBBox.clone();
    }
    function gs(t, e) {
        return t.sourceAnchor ? t.sourceAnchor : us(t, e).center();
    }
    function ds(t, e, i, n, r) {
        var o, a, s, l, c, u, h, g, d, f, p = 360 / i, m = t.theta((o = t, a = e, s = n, l = r.step, c = a.x - o.x, u = a.y - o.y, h = c / s.x, g = u / s.y, d = h * l, f = g * l, new qi(o.x + d, o.y + f))), I = Ti(m + p / 2);
        return p * Math.floor(I / p);
    }
    function fs(t, e) {
        var i = Math.abs(t - e);
        return 180 < i ? 360 - i : i;
    }
    function ps(t, e) {
        if (!t) return e;
        var i = Math.abs(t), n = Math.round(i / e);
        return n ? e + (i - n * e) / n : i;
    }
    function ms(t, e) {
        return t.round(e);
    }
    function Is(t, e, i) {
        var n, r, o, a, s;
        return ms((n = t.clone(), o = (r = e).source, a = Li(n.x - o.x, r.x) + o.x, s = Li(n.y - o.y, r.y) + o.y, new qi(a, s)), i);
    }
    function vs(t) {
        return t.clone().toString();
    }
    function As(t) {
        return new qi(0 === t.x ? 0 : Math.abs(t.x) / t.x, 0 === t.y ? 0 : Math.abs(t.y) / t.y);
    }
    function Cs(t, e, i, n, r, o, a) {
        for(var s, l = [], c = As(r.difference(i)), u = vs(i), h = t[u]; h;){
            var g = As((s = e[u]).difference(h));
            g.equals(c) || (l.unshift(s), c = g), h = t[u = vs(h)];
        }
        var d = e[u];
        return As(d.difference(n)).equals(c) || l.unshift(d), l;
    }
    function ys(t, e) {
        for(var i = 1 / 0, n = 0, r = e.length; n < r; n++){
            var o = t.manhattanDistance(e[n]);
            o < i && (i = o);
        }
        return i;
    }
    function ws(g, d, t, f, e) {
        var p = e.precision, m = e.directionMap, I = g.difference(d.center()), i = jo(m) ? Object.keys(m) : [], v = po(t), n = i.reduce(function(t, e) {
            if (v.includes(e)) {
                for(var i, n = m[e], r = new qi(g.x + n.x * (Math.abs(I.x) + d.width), g.y + n.y * (Math.abs(I.y) + d.height)), o = new nn(g, r).intersect(d) || [], a = o.length, s = null, l = 0; l < a; l++){
                    var c = o[l], u = g.squaredDistance(c);
                    (void 0 === i || i < u) && (i = u, s = c);
                }
                if (s) {
                    var h = Is(s, f, p);
                    d.containsPoint(h) && (h = Is(h.offset(n.x * f.x, n.y * f.y), f, p)), t.push(h);
                }
            }
            return t;
        }, []);
        return d.containsPoint(g) || n.push(Is(g, f, p)), n;
    }
    function bs(t, e, i, n) {
        var r, o, a, s, l = n.precision;
        r = ms(t instanceof In ? gs(this, n).clone() : t.clone(), l), o = ms(e instanceof In ? (a = this, s = n, a.targetAnchor ? a.targetAnchor : hs(a, s).center()).clone() : e.clone(), l);
        var c, u, h, g, d, f, p, m, I, v, A = (c = n.step, h = o, {
            source: (u = r).clone(),
            x: ps(h.x - u.x, c),
            y: ps(h.y - u.y, c)
        });
        if (f = t instanceof In ? ws(g = r, t, n.startDirections, A, n) : [
            g = r
        ], p = e instanceof In ? ws(d = o, e, n.endDirections, A, n) : [
            d = o
        ], f = f.filter(function(t) {
            return !i(t);
        }), p = p.filter(function(t) {
            return !i(t);
        }), 0 < f.length && 0 < p.length) {
            for(var C = new cs, y = {}, w = {}, b = {}, N = 0, x = f.length; N < x; N++){
                var M = f[N], S = vs(M);
                C.add(S, ys(M, p)), y[S] = M, b[S] = 0;
            }
            var k, D, T = n.previousDirectionAngle, L = void 0 === T, z = n.directions;
            m = A, v = (I = n).step, po(I.directions).forEach(function(t) {
                t.gridOffsetX = t.offsetX / v * m.x, t.gridOffsetY = t.offsetY / v * m.y;
            });
            for(var P = z.length, j = po(p).reduce(function(t, e) {
                var i = vs(e);
                return t.push(i), t;
            }, []), Z = n.maximumLoops; !C.isEmpty() && 0 < Z;){
                var G, B = C.pop(), O = y[B], E = w[B], R = b[B], Y = void 0 === E, W = O.equals(g);
                G = Y ? L ? W ? null : ds(g, O, P, A, n) : T : ds(E, O, P, A, n);
                var U = f.length === p.length;
                if (U) {
                    for(var F = 0; F < f.length; F++)if (!f[F].equals(p[F])) {
                        U = !1;
                        break;
                    }
                }
                if (!(Y && U) && 0 <= j.indexOf(B)) return n.previousDirectionAngle = G, Cs(w, y, O, g, d);
                for(N = 0; N < P; N++){
                    var V = (k = z[N]).angle;
                    if (D = fs(G, V), L && W || !(D > n.maxAllowedDirectionChange)) {
                        var X = Is(O.clone().offset(k.gridOffsetX, k.gridOffsetY), A, l), H = vs(X);
                        if (!C.isClose(H) && !i(X)) {
                            if (0 <= j.indexOf(H)) {
                                if (!X.equals(d)) {
                                    if (fs(V, ds(X, d, P, A, n)) > n.maxAllowedDirectionChange) continue;
                                }
                            }
                            var J = R + k.cost + (W ? 0 : n.penalties[D]);
                            (!C.isOpen(H) || J < b[H]) && (y[H] = X, w[H] = O, b[H] = J, C.add(H, J + ys(X, p)));
                        }
                    }
                }
                Z--;
            }
        }
        return n.fallbackRoute.call(this, g, d, n);
    }
    function Ns(t, e, i) {
        !function(t) {
            if (t.directions = xo(t, "directions"), t.penalties = xo(t, "penalties"), t.paddingBox = xo(t, "paddingBox"), t.padding = xo(t, "padding"), t.padding) {
                var e = Xr(t.padding);
                t.paddingBox = {
                    x: -e.left,
                    y: -e.top,
                    width: e.left + e.right,
                    height: e.top + e.bottom
                };
            }
            po(t.directions).forEach(function(t) {
                var e = new qi(0, 0), i = new qi(t.offsetX, t.offsetY);
                t.angle = Ti(e.theta(i));
            });
        }(e), i.options.perpendicular = !!e.perpendicular;
        var n, r = us(i, e), o = hs(i, e), a = gs(i, e);
        if ("function" == typeof e.isPointObstacle) n = e.isPointObstacle;
        else {
            var s = new ls(e);
            s.build(i.paper.model, i.model), n = function(t) {
                return !s.isPointAccessible(t);
            };
        }
        for(var l, c, u = po(t).map(qi), h = [], g = a, d = 0, f = u.length; d <= f; d++){
            var p = null;
            if (c = l || r, !(l = u[d])) {
                if (l = o, (!i.model.get("source").id || !i.model.get("target").id) && go(e.draggingRoute)) {
                    var m = c === r ? a : c, I = l.origin();
                    p = e.draggingRoute.call(i, m, I, e);
                }
            }
            if (null === (p = p || bs.call(i, c, l, n, e))) return e.fallbackRouter(t, e, i);
            var v = p[0];
            v && v.equals(g) && p.shift(), g = p[p.length - 1] || g, Array.prototype.push.apply(h, p);
        }
        return h;
    }
    ls.prototype.build = function(r, o) {
        var h = this.options, g = po(h.excludeEnds).reduce(function(t, e) {
            var i = o.get(e);
            if (i) {
                var n = r.getCell(i.id);
                n && t.push(n);
            }
            return t;
        }, []), d = [], t = r.getCell(o.get("source").id);
        t && (d = bo(d, t.getAncestors().map(function(t) {
            return t.id;
        })));
        var e = r.getCell(o.get("target").id);
        e && (d = bo(d, e.getAncestors().map(function(t) {
            return t.id;
        })));
        var f = this.mapGridSize;
        return r.getElements().reduce(function(t, e) {
            var i = po(h.excludeTypes).includes(e.get("type")), n = g.find(function(t) {
                return t.id === e.id;
            }), r = d.includes(e.id);
            if (!(i || n || r)) for(var o = e.getBBox().moveAndExpand(h.paddingBox), a = o.origin().snapToGrid(f), s = o.corner().snapToGrid(f), l = a.x; l <= s.x; l += f)for(var c = a.y; c <= s.y; c += f){
                var u = l + "@" + c;
                t[u] = t[u] || [], t[u].push(o);
            }
            return t;
        }, this.map), this;
    }, ls.prototype.isPointAccessible = function(e) {
        var t = e.clone().snapToGrid(this.mapGridSize).toString();
        return po(this.map[t]).every(function(t) {
            return !t.containsPoint(e);
        });
    }, cs.prototype.add = function(t, e) {
        this.hash[t] ? this.items.splice(this.items.indexOf(t), 1) : this.hash[t] = this.OPEN, this.values[t] = e;
        var i = ao(this.items, t, (function(t) {
            return this.values[t];
        }).bind(this));
        this.items.splice(i, 0, t);
    }, cs.prototype.remove = function(t) {
        this.hash[t] = this.CLOSE;
    }, cs.prototype.isOpen = function(t) {
        return this.hash[t] === this.OPEN;
    }, cs.prototype.isClose = function(t) {
        return this.hash[t] === this.CLOSE;
    }, cs.prototype.isEmpty = function() {
        return 0 === this.items.length;
    }, cs.prototype.pop = function() {
        var t = this.items.shift();
        return this.remove(t), t;
    };
    var xs = function(t, e, i) {
        return Ns(t, io({}, ss, e), i);
    }, Ms = {
        maxAllowedDirectionChange: 45,
        diagonalCost: function() {
            var t = this.step;
            return Math.ceil(Math.sqrt(t * t << 1));
        },
        directions: function() {
            var t = this.step, e = this.cost(), i = this.diagonalCost();
            return [
                {
                    offsetX: t,
                    offsetY: 0,
                    cost: e
                },
                {
                    offsetX: t,
                    offsetY: t,
                    cost: i
                },
                {
                    offsetX: 0,
                    offsetY: t,
                    cost: e
                },
                {
                    offsetX: -t,
                    offsetY: t,
                    cost: i
                },
                {
                    offsetX: -t,
                    offsetY: 0,
                    cost: e
                },
                {
                    offsetX: -t,
                    offsetY: -t,
                    cost: i
                },
                {
                    offsetX: 0,
                    offsetY: -t,
                    cost: e
                },
                {
                    offsetX: t,
                    offsetY: -t,
                    cost: i
                }
            ];
        },
        fallbackRoute: function(t, e, i) {
            var n = t.theta(e), r = [], o = {
                x: e.x,
                y: t.y
            }, a = {
                x: t.x,
                y: e.y
            };
            if (90 < n % 180) {
                var s = o;
                o = a, a = s;
            }
            var l = n % 90 < 45 ? o : a, c = new nn(t, l), u = 90 * Math.ceil(n / 90), h = qi.fromPolar(c.squaredLength(), Pi(u + 135), l), g = new nn(e, h), d = c.intersection(g), f = d || e, p = d ? f : t, m = 360 / i.directions.length, I = p.theta(e), v = Ti(I + m / 2), A = m * Math.floor(v / m);
            return i.previousDirectionAngle = A, f && r.push(f.round()), r.push(e), r;
        }
    }, Ss = {
        normal: function(t, e, i) {
            return t;
        },
        oneSide: function(t, e, i) {
            var n, r, o, a = e.side || "bottom", s = Xr(e.padding || 40), l = i.sourceBBox, c = i.targetBBox, u = l.center(), h = c.center();
            switch(a){
                case "bottom":
                    o = 1, n = "y", r = "height";
                    break;
                case "top":
                    o = -1, n = "y", r = "height";
                    break;
                case "left":
                    o = -1, n = "x", r = "width";
                    break;
                case "right":
                    o = 1, n = "x", r = "width";
                    break;
                default:
                    throw new Error("Router: invalid side");
            }
            return u[n] += o * (l[r] / 2 + s[a]), h[n] += o * (c[r] / 2 + s[a]), 0 < o * (u[n] - h[n]) ? h[n] = u[n] : u[n] = h[n], [
                u
            ].concat(t, h);
        },
        orthogonal: as,
        manhattan: xs,
        metro: function(t, e, i) {
            if (!go(xs)) throw new Error("Metro requires the manhattan router.");
            return xs(t, io({}, Ms, e), i);
        }
    }, ks = [
        "arc",
        "gap",
        "cubic"
    ], Ds = [
        "smooth"
    ], Ts = 1 / 3, Ls = 2 / 3;
    function zs(t, e, i) {
        var r = [].concat(t, i, e);
        return r.reduce(function(t, e, i) {
            var n = r[i + 1];
            return null != n && (t[i] = rn(e, n)), t;
        }, []);
    }
    function Ps(t, e) {
        return rn(t, e).squaredLength();
    }
    function js(S, k, D, T) {
        var L, z = new Tn;
        return L = Tn.createSegment("M", S[0].start), z.appendSegment(L), po(S).forEach(function(t, e) {
            if (t.isJump) {
                var i, n, r, o;
                if ("arc" === D) {
                    i = -90, n = t.start.difference(t.end);
                    var a = Number(n.x < 0 || 0 === n.x && n.y < 0);
                    a && (i += 180);
                    var s, l = t.midpoint(), c = new nn(l, t.end).rotate(l, i);
                    r = (s = new nn(t.start, l)).pointAt(2 / 3).rotate(t.start, i), o = c.pointAt(1 / 3).rotate(c.end, -i), L = Tn.createSegment("C", r, o, c.end), z.appendSegment(L), s = new nn(l, t.end), r = c.pointAt(1 / 3).rotate(c.end, i), o = s.pointAt(1 / 3).rotate(t.end, -i), L = Tn.createSegment("C", r, o, t.end), z.appendSegment(L);
                } else if ("gap" === D) L = Tn.createSegment("M", t.end), z.appendSegment(L);
                else if ("cubic" === D) {
                    i = t.start.theta(t.end);
                    var u = .6 * k, h = 1.35 * k;
                    n = t.start.difference(t.end), (a = Number(n.x < 0 || 0 === n.x && n.y < 0)) && (h *= -1), r = qi(t.start.x + u, t.start.y + h).rotate(t.start, i), o = qi(t.end.x - u, t.end.y + h).rotate(t.end, i), L = Tn.createSegment("C", r, o, t.end), z.appendSegment(L);
                }
            } else {
                var g = S[e + 1];
                0 == T || !g || g.isJump ? (L = Tn.createSegment("L", t.end), z.appendSegment(L)) : (d = T, f = z, p = t.end, m = t.start, I = g.end, A = p.distance(m) / 2, C = p.distance(I) / 2, y = -Math.min(d, A), w = -Math.min(d, C), b = p.clone().move(m, y).round(), N = p.clone().move(I, w).round(), x = new qi(Ts * b.x + Ls * p.x, Ls * p.y + Ts * b.y), M = new qi(Ts * N.x + Ls * p.x, Ls * p.y + Ts * N.y), v = Tn.createSegment("L", b), f.appendSegment(v), v = Tn.createSegment("C", x, M, N), f.appendSegment(v));
            }
            var d, f, p, m, I, v, A, C, y, w, b, N, x, M;
        }), z;
    }
    var Zs = {
        AUTO: "auto",
        HORIZONTAL: "horizontal",
        VERTICAL: "vertical",
        CLOSEST_POINT: "closest-point",
        OUTWARDS: "outwards"
    }, Gs = {
        UP: "up",
        DOWN: "down",
        LEFT: "left",
        RIGHT: "right",
        AUTO: "auto",
        CLOSEST_POINT: "closest-point",
        OUTWARDS: "outwards"
    }, Bs = function(t, e, i, n, r) {
        void 0 === i && (i = []), void 0 === n && (n = {});
        var o = Boolean(n.raw), a = n.direction;
        void 0 === a && (a = Zs.AUTO);
        var s = n.precision;
        void 0 === s && (s = 3);
        var l = {
            coeff: n.distanceCoefficient || .6,
            angleTangentCoefficient: n.angleTangentCoefficient || 80,
            tau: n.tension || .5,
            sourceTangent: n.sourceTangent ? new qi(n.sourceTangent) : null,
            targetTangent: n.targetTangent ? new qi(n.targetTangent) : null
        };
        "string" == typeof n.sourceDirection ? l.sourceDirection = n.sourceDirection : "number" == typeof n.sourceDirection ? l.sourceDirection = new qi(1, 0).rotate(null, n.sourceDirection) : l.sourceDirection = n.sourceDirection ? new qi(n.sourceDirection).normalize() : null, "string" == typeof n.targetDirection ? l.targetDirection = n.targetDirection : "number" == typeof n.targetDirection ? l.targetDirection = new qi(1, 0).rotate(null, n.targetDirection) : l.targetDirection = n.targetDirection ? new qi(n.targetDirection).normalize() : null;
        var c, u, h = [
            t
        ].concat(i.map(function(t) {
            return new qi(t);
        }), [
            e
        ]);
        if (l.sourceTangent) c = l.sourceTangent;
        else {
            var g = function(t, e, i, n) {
                if (n.sourceDirection) switch(n.sourceDirection){
                    case Gs.UP:
                        return new qi(0, -1);
                    case Gs.DOWN:
                        return new qi(0, 1);
                    case Gs.LEFT:
                        return new qi(-1, 0);
                    case Gs.RIGHT:
                        return new qi(1, 0);
                    case Gs.AUTO:
                        return Os(t, e, n);
                    case Gs.CLOSEST_POINT:
                        return Rs(t, e, n);
                    case Gs.OUTWARDS:
                        return Ws(t, e, n);
                    default:
                        return n.sourceDirection;
                }
                switch(i){
                    case Zs.HORIZONTAL:
                        return function(t, e, i) {
                            var n, r = t.sourceBBox;
                            n = r.width && r.height ? r.sideNearestToPoint(e[0]) : r.x > e[1].x ? "right" : "left";
                            switch(n){
                                case "left":
                                    return new qi(-1, 0);
                                case "right":
                                default:
                                    return new qi(1, 0);
                            }
                        }(t, e);
                    case Zs.VERTICAL:
                        return function(t, e, i) {
                            var n, r = t.sourceBBox;
                            n = r.width && r.height ? r.sideNearestToPoint(e[0]) : r.y > e[1].y ? "bottom" : "top";
                            switch(n){
                                case "top":
                                    return new qi(0, -1);
                                case "bottom":
                                default:
                                    return new qi(0, 1);
                            }
                        }(t, e);
                    case Zs.CLOSEST_POINT:
                        return Rs(t, e, n);
                    case Zs.OUTWARDS:
                        return Ws(t, e, n);
                    case Zs.AUTO:
                    default:
                        return Os(t, e, n);
                }
            }(r, h, a, l), d = h[0].distance(h[1]) * l.coeff, f = Vs(g, h[1].difference(h[0]).normalize());
            if (f > Math.PI / 4) {
                var p = d + (f - Math.PI / 4) * l.angleTangentCoefficient;
                c = g.clone().scale(p, p);
            } else c = g.clone().scale(d, d);
        }
        if (l.targetTangent) u = l.targetTangent;
        else {
            var m = function(t, e, i, n) {
                if (n.targetDirection) switch(n.targetDirection){
                    case Gs.UP:
                        return new qi(0, -1);
                    case Gs.DOWN:
                        return new qi(0, 1);
                    case Gs.LEFT:
                        return new qi(-1, 0);
                    case Gs.RIGHT:
                        return new qi(0, 1);
                    case Gs.AUTO:
                        return Es(t, e, n);
                    case Gs.CLOSEST_POINT:
                        return Ys(t, e, n);
                    case Gs.OUTWARDS:
                        return Us(t, e, n);
                    default:
                        return n.targetDirection;
                }
                switch(i){
                    case Zs.HORIZONTAL:
                        return function(t, e, i) {
                            var n, r = t.targetBBox;
                            n = r.width && r.height ? r.sideNearestToPoint(e[e.length - 1]) : r.x > e[e.length - 2].x ? "left" : "right";
                            switch(n){
                                case "left":
                                    return new qi(-1, 0);
                                case "right":
                                default:
                                    return new qi(1, 0);
                            }
                        }(t, e);
                    case Zs.VERTICAL:
                        return function(t, e, i) {
                            var n, r = t.targetBBox;
                            n = r.width && r.height ? r.sideNearestToPoint(e[e.length - 1]) : r.y > e[e.length - 2].y ? "top" : "bottom";
                            switch(n){
                                case "top":
                                    return new qi(0, -1);
                                case "bottom":
                                default:
                                    return new qi(0, 1);
                            }
                        }(t, e);
                    case Zs.CLOSEST_POINT:
                        return Ys(t, e, n);
                    case Zs.OUTWARDS:
                        return Us(t, e, n);
                    case Zs.AUTO:
                    default:
                        return Es(t, e, n);
                }
            }(r, h, a, l), I = h.length - 1, v = h[I - 1].distance(h[I]) * l.coeff, A = Vs(m, h[I - 1].difference(h[I]).normalize());
            if (A > Math.PI / 4) {
                var C = v + (A - Math.PI / 4) * l.angleTangentCoefficient;
                u = m.clone().scale(C, C);
            } else u = m.clone().scale(v, v);
        }
        var y = (function(t, e, i, n) {
            for(var r = n.tau, o = n.coeff, a = [], s = [], l = [], c = t.length - 1, u = 0; u < c; u++)a[u] = t[u].distance(t[u + 1]);
            s[0] = e, s[c] = i;
            for(var h = 1; h < c; h++){
                var g = void 0, d = void 0;
                g = 1 === h ? t[h - 1].clone().offset(s[h - 1].x, s[h - 1].y) : t[h - 1].clone(), d = h === c - 1 ? t[h + 1].clone().offset(s[h + 1].x, s[h + 1].y) : t[h + 1].clone();
                var f = g.difference(t[h]).normalize(), p = d.difference(t[h]).normalize(), m = Vs(f, p), I = (Math.PI - m) / 2, v = void 0, A = Xs(f, p), C = void 0;
                C = Xs(t[h].difference(t[h + 1]), t[h].difference(t[h - 1])), A < 0 && (I = -I), m < Math.PI / 2 && (I < 0 && C < 0 || 0 < I && 0 < C) && (I -= Math.PI), Fs(v = p.clone(), I);
                var y = v.clone(), w = v.clone(), b = a[h - 1] * o, N = a[h] * o;
                y.scale(b, b), w.scale(N, N), s[h] = [
                    y,
                    w
                ];
            }
            for(var x = 0; x < c; x++){
                var M = void 0, S = void 0;
                M = 0 === x ? t[x + 1].difference(s[x].x / r, s[x].y / r) : t[x + 1].difference(s[x][1].x / r, s[x][1].y / r), S = x === c - 1 ? t[x].clone().offset(s[x + 1].x / r, s[x + 1].y / r) : t[x].difference(s[x + 1][0].x / r, s[x + 1][0].y / r), l[x] = [
                    M,
                    t[x],
                    t[x + 1],
                    S
                ];
            }
            return l;
        })(h, c, u, l).map(function(t) {
            return function(t, e) {
                var i = e.tau, n = new qi;
                n.x = t[1].x + (t[2].x - t[0].x) / (6 * i), n.y = t[1].y + (t[2].y - t[0].y) / (6 * i);
                var r = new qi;
                return r.x = t[2].x + (t[3].x - t[1].x) / (6 * i), r.y = t[2].y + (t[3].y - t[1].y) / (6 * i), new kn(t[1], n, r, t[2]);
            }(t, l);
        }), w = new Tn(y).round(s);
        return o ? w : w.serialize();
    };
    function Os(t, e, i) {
        var n = t.sourceBBox;
        switch(n.width && n.height ? n.sideNearestToPoint(e[0]) : n.sideNearestToPoint(e[1])){
            case "top":
                return new qi(0, -1);
            case "bottom":
                return new qi(0, 1);
            case "right":
                return new qi(1, 0);
            case "left":
                return new qi(-1, 0);
        }
    }
    function Es(t, e, i) {
        var n = t.targetBBox;
        switch(n.width && n.height ? n.sideNearestToPoint(e[e.length - 1]) : n.sideNearestToPoint(e[e.length - 2])){
            case "top":
                return new qi(0, -1);
            case "bottom":
                return new qi(0, 1);
            case "right":
                return new qi(1, 0);
            case "left":
                return new qi(-1, 0);
        }
    }
    function Rs(t, e, i) {
        return e[1].difference(e[0]).normalize();
    }
    function Ys(t, e, i) {
        var n = e.length - 1;
        return e[n - 1].difference(e[n]).normalize();
    }
    function Ws(t, e, i) {
        var n = t.sourceBBox.center();
        return e[0].difference(n).normalize();
    }
    function Us(t, e, i) {
        var n = t.targetBBox.center();
        return e[e.length - 1].difference(n).normalize();
    }
    function Fs(t, e) {
        var i = Math.cos(e), n = Math.sin(e), r = i * t.x - n * t.y, o = n * t.x + i * t.y;
        t.x = r, t.y = o;
    }
    function Vs(t, e) {
        var i = t.dot(e) / (t.magnitude() * e.magnitude());
        return i < -1 && (i = -1), 1 < i && (i = 1), Math.acos(i);
    }
    function Xs(t, e) {
        return t.x * e.y - t.y * e.x;
    }
    Bs.Directions = Zs, Bs.TangentDirections = Gs;
    var Hs = {
        jumpover: function(t, e, i, n) {
            !function(t) {
                var e = t.paper, i = e._jumpOverUpdateList;
                if (null == i) {
                    i = e._jumpOverUpdateList = [];
                    var n = e.model;
                    n.on("batch:stop", function() {
                        this.hasActiveBatch() || function(t) {
                            for(var e = t._jumpOverUpdateList, i = 0; i < e.length; i++){
                                var n = e[i], r = n.getFlag(n.constructor.Flags.CONNECTOR);
                                n.requestUpdate(r);
                            }
                        }(e);
                    }), n.on("reset", function() {
                        i = e._jumpOverUpdateList = [];
                    });
                }
                i.indexOf(t) < 0 && (i.push(t), t.listenToOnce(t.model, "change:connector remove", function() {
                    i.splice(i.indexOf(t), 1);
                }));
            }(this);
            var r = n.raw, o = n.size || 5, a = n.jump && ("" + n.jump).toLowerCase(), s = n.radius || 0, l = n.ignoreConnectors || Ds;
            -1 === ks.indexOf(a) && (a = ks[0]);
            var c = this.paper, u = c.model.getLinks();
            if (1 === u.length) return js(zs(t, e, i), o, a, s);
            var g = this.model, h = u.indexOf(g), d = c.options.defaultConnector || {}, f = u.filter(function(t, e) {
                var i = t.get("connector") || d;
                return !(po(l).includes(i.name) || h < e && "jumpover" === i.name);
            }), p = f.map(function(t) {
                return c.findViewByModel(t);
            }), m = zs(t, e, i), I = p.map(function(t) {
                return null == t ? [] : t === this ? m : zs(t.sourcePoint, t.targetPoint, t.route);
            }, this), v = js(m.reduce(function(t, a) {
                var c, u, h, e = f.reduce(function(t, e, i) {
                    if (e !== g) {
                        var n = (r = a, o = I[i], po(o).reduce(function(t, e) {
                            var i = r.intersection(e);
                            return i && t.push(i), t;
                        }, []));
                        t.push.apply(t, n);
                    }
                    var r, o;
                    return t;
                }, []).sort(function(t, e) {
                    return Ps(a.start, t) - Ps(a.start, e);
                });
                return 0 < e.length ? t.push.apply(t, (c = a, h = o, (u = e).reduce(function(t, e, i) {
                    if (!0 === e.skip) return t;
                    var n = t.pop() || c, r = $i(e).move(n.start, -h), o = $i(e).move(n.start, +h), a = u[i + 1];
                    if (null != a) {
                        var s = o.distance(a);
                        s <= h && (o = a.move(n.start, s), a.skip = !0);
                    } else if (r.distance(n.end) < 2 * h + 1) return t.push(n), t;
                    if (o.distance(n.start) < 2 * h + 1) return t.push(n), t;
                    var l = rn(r, o);
                    return l.isJump = !0, t.push(rn(n.start, r), l, rn(o, n.end)), t;
                }, []))) : t.push(a), t;
            }, []), o, a, s);
            return r ? v : v.serialize();
        },
        normal: function(t, e, i, n) {
            var r = n && n.raw, o = [
                t
            ].concat(i).concat([
                e
            ]), a = new wn(o), s = new Tn(a);
            return r ? s : s.serialize();
        },
        rounded: function(t, e, i, n) {
            n || (n = {});
            var r, o = n.radius || 10, a = n.raw, s = new Tn;
            r = Tn.createSegment("M", t), s.appendSegment(r);
            for(var l, c, u, h, g, d, f, p, m, I, v, A = 0, C = i.length; A < C; A++)l = new qi(i[A]), c = i[A - 1] || t, u = i[A + 1] || e, h = g || l.distance(c) / 2, g = l.distance(u) / 2, d = -Math.min(o, h), f = -Math.min(o, g), p = l.clone().move(c, d).round(), m = l.clone().move(u, f).round(), I = new qi(1 / 3 * p.x + 2 / 3 * l.x, 2 / 3 * l.y + 1 / 3 * p.y), v = new qi(1 / 3 * m.x + 2 / 3 * l.x, 2 / 3 * l.y + 1 / 3 * m.y), r = Tn.createSegment("L", p), s.appendSegment(r), r = Tn.createSegment("C", I, v, m), s.appendSegment(r);
            return r = Tn.createSegment("L", e), s.appendSegment(r), a ? s : s.serialize();
        },
        smooth: function(t, e, i, n) {
            var r, o = n && n.raw;
            if (i && 0 !== i.length) {
                var a = [
                    t
                ].concat(i).concat([
                    e
                ]), s = kn.throughPoints(a);
                r = new Tn(s);
            } else {
                var l;
                if (r = new Tn, l = Tn.createSegment("M", t), r.appendSegment(l), Math.abs(t.x - e.x) >= Math.abs(t.y - e.y)) {
                    var c = (t.x + e.x) / 2;
                    l = Tn.createSegment("C", c, t.y, c, e.y, e.x, e.y), r.appendSegment(l);
                } else {
                    var u = (t.y + e.y) / 2;
                    l = Tn.createSegment("C", t.x, u, e.x, u, e.x, e.y), r.appendSegment(l);
                }
            }
            return o ? r : r.serialize();
        },
        curve: Bs
    }, Js = {
        RENDER: "RENDER",
        UPDATE: "UPDATE",
        TOOLS: "TOOLS",
        LEGACY_TOOLS: "LEGACY_TOOLS",
        LABELS: "LABELS",
        VERTICES: "VERTICES",
        SOURCE: "SOURCE",
        TARGET: "TARGET",
        CONNECTOR: "CONNECTOR"
    }, _s = Ua.extend({
        className: function() {
            var t = Ua.prototype.className.apply(this).split(" ");
            return t.push("link"), t.join(" ");
        },
        options: {
            shortLinkLength: 105,
            doubleLinkTools: !1,
            longLinkLength: 155,
            linkToolsOffset: 40,
            doubleLinkToolsOffset: 65,
            sampleInterval: 50
        },
        _labelCache: null,
        _labelSelectors: null,
        _markerCache: null,
        _V: null,
        _dragData: null,
        metrics: null,
        decimalsRounding: 2,
        initialize: function() {
            Ua.prototype.initialize.apply(this, arguments), this._labelCache = {}, this._labelSelectors = {}, this._markerCache = {}, this._V = {}, this.cleanNodesCache();
        },
        presentationAttributes: {
            markup: [
                Js.RENDER
            ],
            attrs: [
                Js.UPDATE
            ],
            router: [
                Js.UPDATE
            ],
            connector: [
                Js.CONNECTOR
            ],
            smooth: [
                Js.UPDATE
            ],
            manhattan: [
                Js.UPDATE
            ],
            toolMarkup: [
                Js.LEGACY_TOOLS
            ],
            labels: [
                Js.LABELS
            ],
            labelMarkup: [
                Js.LABELS
            ],
            vertices: [
                Js.VERTICES,
                Js.UPDATE
            ],
            vertexMarkup: [
                Js.VERTICES
            ],
            source: [
                Js.SOURCE,
                Js.UPDATE
            ],
            target: [
                Js.TARGET,
                Js.UPDATE
            ]
        },
        initFlag: [
            Js.RENDER,
            Js.SOURCE,
            Js.TARGET,
            Js.TOOLS
        ],
        UPDATE_PRIORITY: 1,
        confirmUpdate: function(t, e) {
            if (e || (e = {}), this.hasFlag(t, Js.SOURCE)) {
                if (!this.updateEndProperties("source")) return t;
                t = this.removeFlag(t, Js.SOURCE);
            }
            if (this.hasFlag(t, Js.TARGET)) {
                if (!this.updateEndProperties("target")) return t;
                t = this.removeFlag(t, Js.TARGET);
            }
            var i = this.paper, n = this.sourceView, r = this.targetView;
            if (i && (n && !i.isViewMounted(n) || r && !i.isViewMounted(r))) return t;
            if (this.hasFlag(t, Js.RENDER)) return this.render(), this.updateHighlighters(!0), this.updateTools(e), t = this.removeFlag(t, [
                Js.RENDER,
                Js.UPDATE,
                Js.VERTICES,
                Js.LABELS,
                Js.TOOLS,
                Js.LEGACY_TOOLS,
                Js.CONNECTOR
            ]);
            var o = !1;
            this.hasFlag(t, Js.VERTICES) && (this.renderVertexMarkers(), t = this.removeFlag(t, Js.VERTICES));
            var a = this.model, s = a.attributes, l = this.hasFlag(t, Js.LABELS), c = this.hasFlag(t, Js.LEGACY_TOOLS);
            l && (this.onLabelsChange(a, s.labels, e), t = this.removeFlag(t, Js.LABELS), o = !0), c && (this.renderTools(), t = this.removeFlag(t, Js.LEGACY_TOOLS));
            var u = this.hasFlag(t, Js.UPDATE), h = this.hasFlag(t, Js.CONNECTOR);
            return (u || h) && (u ? e.translateBy && a.isRelationshipEmbeddedIn(e.translateBy) ? this.translate(e.tx, e.ty) : this.update() : (this.updatePath(), this.updateDOM()), this.updateTools(e), t = this.removeFlag(t, [
                Js.UPDATE,
                Js.TOOLS,
                Js.CONNECTOR
            ]), o = (c = l = !1, true)), l && this.updateLabelPositions(), c && this.updateToolsPosition(), o && this.updateHighlighters(), this.hasFlag(t, Js.TOOLS) && (this.updateTools(e), t = this.removeFlag(t, Js.TOOLS)), t;
        },
        requestConnectionUpdate: function(t) {
            this.requestUpdate(this.getFlag(Js.UPDATE), t);
        },
        isLabelsRenderRequired: function(t) {
            void 0 === t && (t = {});
            var e = this.model.previous("labels");
            if (!e) return !0;
            if ("propertyPathArray" in t && "propertyValue" in t) {
                var i = t.propertyPathArray || [], n = i.length;
                if (1 < n) {
                    if (!!e[i[1]]) {
                        if (2 === n) return "markup" in Object(t.propertyValue);
                        if ("markup" !== i[2]) return !1;
                    }
                }
            }
            return !0;
        },
        onLabelsChange: function(t, e, i) {
            this.isLabelsRenderRequired(i) ? this.renderLabels() : this.updateLabels();
        },
        render: function() {
            return this.vel.empty(), this.unmountLabels(), this._V = {}, this.renderMarkup(), this.renderLabels(), this.update(), this;
        },
        renderMarkup: function() {
            var t = this.model, e = t.get("markup") || t.markup;
            if (!e) throw new Error("dia.LinkView: markup required");
            if (Array.isArray(e)) return this.renderJSONMarkup(e);
            if ("string" == typeof e) return this.renderStringMarkup(e);
            throw new Error("dia.LinkView: invalid markup");
        },
        renderJSONMarkup: function(t) {
            var e = this.parseDOMJSON(t, this.el);
            this.selectors = e.selectors, this.vel.append(e.fragment);
        },
        renderStringMarkup: function(t) {
            var e = wr(t);
            Array.isArray(e) || (e = [
                e
            ]);
            for(var i = this._V, n = 0, r = e.length; n < r; n++){
                var o = e[n], a = o.attr("class");
                a && (a = xr(a), i[S.camelCase(a)] = o);
            }
            this.renderTools(), this.renderVertexMarkers(), this.renderArrowheadMarkers(), this.vel.append(e);
        },
        _getLabelMarkup: function(t) {
            if (t) {
                if (Array.isArray(t)) return this.parseDOMJSON(t, null);
                if ("string" == typeof t) return this._getLabelStringMarkup(t);
                throw new Error("dia.linkView: invalid label markup");
            }
        },
        _getLabelStringMarkup: function(t) {
            var e = wr(t), i = document.createDocumentFragment();
            if (Array.isArray(e)) for(var n = 0, r = e.length; n < r; n++){
                var o = e[n].node;
                i.appendChild(o);
            }
            else i.appendChild(e.node);
            return {
                fragment: i,
                selectors: {}
            };
        },
        _normalizeLabelMarkup: function(t) {
            if (t) {
                var e, i = t.fragment;
                if (!(t.fragment instanceof DocumentFragment && t.fragment.hasChildNodes())) throw new Error("dia.LinkView: invalid label markup.");
                var n = i.childNodes;
                return (e = 1 < n.length || "G" !== n[0].nodeName.toUpperCase() ? wr("g").append(i) : wr(n[0])).addClass("label"), {
                    node: e.node,
                    selectors: t.selectors
                };
            }
        },
        renderLabels: function() {
            var t = this._V, e = t.labels, i = this._labelCache = {}, n = this._labelSelectors = {}, r = this.model, o = r.attributes.labels || [], a = o.length;
            if (0 === a) return e && e.remove(), this;
            e ? e.empty() : (e = t.labels = wr("g").addClass("labels"), this.options.labelsLayer && (e.addClass(Nr(xo(this, "className"))), e.attr("model-id", r.id)));
            for(var s = 0; s < a; s++){
                var l, c, u = o[s], h = this._normalizeLabelMarkup(this._getLabelMarkup(u.markup));
                if (h) l = h.node, c = h.selectors;
                else {
                    var g = r._builtins.defaultLabel, d = this._normalizeLabelMarkup(this._getLabelMarkup(g.markup)), f = r._getDefaultLabel(), p = this._normalizeLabelMarkup(this._getLabelMarkup(f.markup)) || d;
                    l = p.node, c = p.selectors;
                }
                l.setAttribute("label-idx", s), e.append(l), i[s] = l;
                var m = this.selector;
                if (c[m]) throw new Error("dia.LinkView: ambiguous label root selector.");
                c[m] = l, n[s] = c;
            }
            return e.parent() || this.mountLabels(), this.updateLabels(), this;
        },
        mountLabels: function() {
            var t = this.el, e = this.paper, i = this.model, n = this._V, r = this.options, o = n.labels;
            if (o && i.hasLabels()) {
                var a = o.node;
                r.labelsLayer ? e.getLayerView(r.labelsLayer).insertSortedNode(a, i.get("z")) : a.parentNode !== t && t.appendChild(a);
            }
        },
        unmountLabels: function() {
            var t = this.options, e = this._V;
            if (e) {
                var i = e.labels;
                i && t.labelsLayer && i.remove();
            }
        },
        onMount: function() {
            this.mountLabels();
        },
        unmount: function() {
            Ua.prototype.unmount.apply(this, arguments), this.unmountLabels();
        },
        findLabelNode: function(t, e) {
            var i = this._labelCache[t];
            if (!i) return null;
            var n = this._labelSelectors[t], r = this.findBySelector(e, i, n)[0];
            return void 0 === r && (r = null), r;
        },
        _mergeLabelAttrs: function(t, e, i, n) {
            return null === e ? null : void 0 !== e ? t ? zo({}, i, e) : zo({}, n, i, e) : null === i ? null : void 0 !== i ? t ? i : zo({}, n, i) : t ? void 0 : n;
        },
        updateLabels: function() {
            if (!this._V.labels) return this;
            for(var t = this.model, e = t.get("labels") || [], i = this.can("labelMove"), n = t._builtins.defaultLabel.attrs, r = t._getDefaultLabel(), o = r.markup, a = r.attrs, s = 0, l = e.length; s < l; s++){
                var c = this._labelCache[s];
                c.setAttribute("cursor", i ? "move" : "default");
                var u = this._labelSelectors[s], h = e[s], g = h.markup, d = h.attrs, f = this._mergeLabelAttrs(g || o, d, a, n);
                this.updateDOMSubtreeAttributes(c, f, {
                    rootBBox: new In(h.size),
                    selectors: u
                });
            }
            return this;
        },
        renderTools: function() {
            if (!this._V.linkTools) return this;
            var t, e = S(this._V.linkTools.node).empty(), i = Kr(this.model.get("toolMarkup") || this.model.toolMarkup), n = wr(i());
            (e.append(n.node), this._toolCache = n, this.options.doubleLinkTools) && (t = this.model.get("doubleToolMarkup") || this.model.doubleToolMarkup ? (i = Kr(this.model.get("doubleToolMarkup") || this.model.doubleToolMarkup), wr(i())) : n.clone(), e.append(t.node), this._tool2Cache = t);
            return this;
        },
        renderVertexMarkers: function() {
            if (!this._V.markerVertices) return this;
            var i = S(this._V.markerVertices.node).empty(), n = Kr(this.model.get("vertexMarkup") || this.model.vertexMarkup);
            return this.model.vertices().forEach(function(t, e) {
                i.append(wr(n(io({
                    idx: e
                }, t))).node);
            }), this;
        },
        renderArrowheadMarkers: function() {
            if (!this._V.markerArrowheads) return this;
            var t = S(this._V.markerArrowheads.node);
            t.empty();
            var e = Kr(this.model.get("arrowheadMarkup") || this.model.arrowheadMarkup);
            return this._V.sourceArrowhead = wr(e({
                end: "source"
            })), this._V.targetArrowhead = wr(e({
                end: "target"
            })), t.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node), this;
        },
        removeRedundantLinearVertices: function(t) {
            var e = this.model, i = e.vertices(), n = [
                this.sourceAnchor
            ].concat(i, [
                this.targetAnchor
            ]), r = n.length, o = new wn(n);
            o.simplify({
                threshold: .001
            });
            var a = o.points.map(function(t) {
                return t.toJSON();
            }), s = a.length;
            return r === s ? 0 : (e.vertices(a.slice(1, s - 1), t), r - s);
        },
        updateDefaultConnectionPath: function() {
            var t = this._V;
            t.connection && t.connection.attr("d", this.getSerializedConnection()), t.connectionWrap && t.connectionWrap.attr("d", this.getSerializedConnection()), t.markerSource && t.markerTarget && this._translateAndAutoOrientArrows(t.markerSource, t.markerTarget);
        },
        getEndView: function(t) {
            switch(t){
                case "source":
                    return this.sourceView || null;
                case "target":
                    return this.targetView || null;
                default:
                    throw new Error("dia.LinkView: type parameter required.");
            }
        },
        getEndAnchor: function(t) {
            switch(t){
                case "source":
                    return new qi(this.sourceAnchor);
                case "target":
                    return new qi(this.targetAnchor);
                default:
                    throw new Error("dia.LinkView: type parameter required.");
            }
        },
        getEndConnectionPoint: function(t) {
            switch(t){
                case "source":
                    return new qi(this.sourcePoint);
                case "target":
                    return new qi(this.targetPoint);
                default:
                    throw new Error("dia.LinkView: type parameter required.");
            }
        },
        getEndMagnet: function(t) {
            switch(t){
                case "source":
                    var e = this.sourceView;
                    if (!e) break;
                    return this.sourceMagnet || e.el;
                case "target":
                    var i = this.targetView;
                    if (!i) break;
                    return this.targetMagnet || i.el;
                default:
                    throw new Error("dia.LinkView: type parameter required.");
            }
            return null;
        },
        update: function() {
            return this.updateRoute(), this.updatePath(), this.updateDOM(), this;
        },
        translate: function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            var i = this.route, n = this.path;
            if (i && n) {
                var r = new wn(i);
                r.translate(t, e), this.route = r.points, this._translateConnectionPoints(t, e), n.translate(t, e), this.updateDOM();
            }
        },
        updateDOM: function() {
            var t = this.el, e = this.model, i = this.selectors;
            this.cleanNodesCache(), this.updateDOMSubtreeAttributes(t, e.attr(), {
                selectors: i
            }), this.updateDefaultConnectionPath(), this.updateLabelPositions(), this.updateToolsPosition(), this.updateArrowheadMarkers(), this.options.perpendicular = null;
        },
        updateRoute: function() {
            var t = this.model.vertices(), e = this.findAnchors(t), i = this.sourceAnchor = e.source, n = this.targetAnchor = e.target, r = this.findRoute(t);
            this.route = r;
            var o = this.findConnectionPoints(r, i, n);
            this.sourcePoint = o.source, this.targetPoint = o.target;
        },
        updatePath: function() {
            var t = this.route, e = this.sourcePoint, i = this.targetPoint, n = this.findMarkerPoints(t, e, i), r = this.findPath(t, n.source || e, n.target || i);
            this.path = r;
        },
        findMarkerPoints: function(t, e, i) {
            var n, r, o = t[0], a = t[t.length - 1], s = this._markerCache;
            return this._V.markerSource && (s.sourceBBox = s.sourceBBox || this._V.markerSource.getBBox(), n = qi(e).move(o || i, s.sourceBBox.width * this._V.markerSource.scale().sx * -1).round()), this._V.markerTarget && (s.targetBBox = s.targetBBox || this._V.markerTarget.getBBox(), r = qi(i).move(a || e, s.targetBBox.width * this._V.markerTarget.scale().sx * -1).round()), s.sourcePoint = n || e.clone(), s.targetPoint = r || i.clone(), {
                source: n,
                target: r
            };
        },
        findAnchorsOrdered: function(t, e, i, n) {
            var r, o, a, s, l = this.model, c = l.get(t), u = l.get(i), h = this.getEndView(t), g = this.getEndView(i), d = this.getEndMagnet(t), f = this.getEndMagnet(i);
            r = h ? (a = e ? new qi(e) : g ? f : new qi(u), this.getAnchor(c.anchor, h, d, a, t)) : new qi(c), o = g ? (s = new qi(n || r), this.getAnchor(u.anchor, g, f, s, i)) : new qi(u);
            var p = {};
            return p[t] = r, p[i] = o, p;
        },
        findAnchors: function(t) {
            var e = this.model, i = t[0], n = t[t.length - 1];
            return e.target().priority && !e.source().priority ? this.findAnchorsOrdered("target", n, "source", i) : this.findAnchorsOrdered("source", i, "target", n);
        },
        findConnectionPoints: function(t, e, i) {
            var n, r, o, a, s = t[0], l = t[t.length - 1], c = this.model, u = c.get("source"), h = c.get("target"), g = this.sourceView, d = this.targetView, f = this.paper.options;
            if (g && !g.isNodeConnection(this.sourceMagnet)) {
                n = this.sourceMagnet || g.el;
                var p = u.connectionPoint || f.defaultConnectionPoint, m = new nn(s || i, e);
                o = this.getConnectionPoint(p, g, n, m, "source");
            } else o = e;
            if (d && !d.isNodeConnection(this.targetMagnet)) {
                r = this.targetMagnet || d.el;
                var I = h.connectionPoint || f.defaultConnectionPoint, v = new nn(l || e, i);
                a = this.getConnectionPoint(I, d, r, v, "target");
            } else a = i;
            return {
                source: o,
                target: a
            };
        },
        getAnchor: function(t, e, i, n, r) {
            var o, a = e.isNodeConnection(i), s = this.paper.options;
            if (t || (t = a ? s.defaultLinkAnchor : s.perpendicularLinks || this.options.perpendicular ? {
                name: "perpendicular"
            } : s.defaultAnchor), !t) throw new Error("Anchor required.");
            if ("function" == typeof t) o = t;
            else {
                var l = t.name;
                if ("function" != typeof (o = s[a ? "linkAnchorNamespace" : "anchorNamespace"][l])) throw new Error("Unknown anchor: " + l);
            }
            var c = o.call(this, e, i, n, t.args || {}, r, this);
            return c ? c.round(this.decimalsRounding) : new qi;
        },
        getConnectionPoint: function(t, e, i, n, r) {
            var o, a, s = n.end, l = this.paper.options;
            if ("function" == typeof l.linkConnectionPoint) {
                var c = i === e.el ? void 0 : i;
                if (o = l.linkConnectionPoint(this, e, c, n.start, r)) return o;
            }
            if (!t) return s;
            if ("function" == typeof t) a = t;
            else {
                var u = t.name;
                if ("function" != typeof (a = l.connectionPointNamespace[u])) throw new Error("Unknown connection point: " + u);
            }
            return (o = a.call(this, n, e, i, t.args || {}, r, this)) ? o.round(this.decimalsRounding) : s;
        },
        _translateConnectionPoints: function(t, e) {
            var i = this._markerCache;
            i.sourcePoint.offset(t, e), i.targetPoint.offset(t, e), this.sourcePoint.offset(t, e), this.targetPoint.offset(t, e), this.sourceAnchor.offset(t, e), this.targetAnchor.offset(t, e);
        },
        _normalizeLabelPosition: function(t) {
            return "number" == typeof t ? {
                distance: t,
                offset: null,
                angle: 0,
                args: null
            } : t;
        },
        updateLabelPositions: function() {
            if (!this._V.labels) return this;
            if (!this.path) return this;
            var t = this.model, e = t.get("labels") || [];
            if (!e.length) return this;
            for(var i = t._builtins.defaultLabel.position, n = t._getDefaultLabel(), r = this._normalizeLabelPosition(n.position), o = zo({}, i, r), a = 0, s = e.length; a < s; a++){
                var l = this._labelCache[a];
                if (l) {
                    var c = e[a], u = this._normalizeLabelPosition(c.position), h = zo({}, o, u), g = this._getLabelTransformationMatrix(h);
                    l.setAttribute("transform", wr.matrixToTransformString(g)), this._cleanLabelMatrices(a);
                }
            }
            return this;
        },
        _cleanLabelMatrices: function(t) {
            var e = this.metrics, i = this._labelSelectors[t];
            if (i) for(var n in i){
                var r = i[n].id;
                r && r in e && delete e[r].magnetMatrix;
            }
        },
        updateToolsPosition: function() {
            if (!this._V.linkTools) return this;
            var t = "", e = this.options.linkToolsOffset, i = this.getConnectionLength();
            if (!Number.isNaN(i)) {
                i < this.options.shortLinkLength && (t = "scale(.5)", e /= 2);
                var n = this.getPointAtLength(e);
                if (this._toolCache.attr("transform", "translate(" + n.x + ", " + n.y + ") " + t), this.options.doubleLinkTools && i >= this.options.longLinkLength) {
                    var r = this.options.doubleLinkToolsOffset || e;
                    n = this.getPointAtLength(i - r), this._tool2Cache.attr("transform", "translate(" + n.x + ", " + n.y + ") " + t), this._tool2Cache.attr("visibility", "visible");
                } else this.options.doubleLinkTools && this._tool2Cache.attr("visibility", "hidden");
            }
            return this;
        },
        updateArrowheadMarkers: function() {
            if (!this._V.markerArrowheads) return this;
            if ("none" === S.css(this._V.markerArrowheads.node, "display")) return this;
            var t = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;
            return this._V.sourceArrowhead.scale(t), this._V.targetArrowhead.scale(t), this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead), this;
        },
        updateEndProperties: function(t) {
            var e = this.model, i = this.paper, n = t + "View", r = e.get(t), o = r && r.id;
            if (!o) return this[n] = null, this.updateEndMagnet(t), !0;
            var a = i.getModelById(o);
            if (!a) throw new Error("LinkView: invalid " + t + " cell.");
            var s = a.findView(i);
            return !!s && (this[n] = s, this.updateEndMagnet(t), !0);
        },
        updateEndMagnet: function(t) {
            var e = t + "Magnet", i = this.getEndView(t);
            if (i) {
                var n = i.getMagnetFromLinkEnd(this.model.get(t));
                n === i.el && (n = null), this[e] = n;
            } else this[e] = null;
        },
        _translateAndAutoOrientArrows: function(t, e) {
            var i = po(this.route);
            t && t.translateAndAutoOrient(this.sourcePoint, i[0] || this.targetPoint, this.paper.cells), e && e.translateAndAutoOrient(this.targetPoint, i[i.length - 1] || this.sourcePoint, this.paper.cells);
        },
        _getLabelPositionAngle: function(t) {
            return (this.model.label(t).position || {}).angle || 0;
        },
        _getLabelPositionArgs: function(t) {
            return (this.model.label(t).position || {}).args;
        },
        _getDefaultLabelPositionArgs: function() {
            return (this.model._getDefaultLabel().position || {}).args;
        },
        _mergeLabelPositionArgs: function(t, e) {
            return null === t ? null : void 0 === t ? null === e ? null : e : zo({}, e, t);
        },
        addLabel: function(t, e, i, n) {
            var r, o, a, s = 0;
            a = "number" != typeof t ? (r = t.x, o = t.y, "number" == typeof e ? (s = e, i) : e) : (r = t, o = e, "number" == typeof i ? (s = i, n) : i);
            var l = this._getDefaultLabelPositionArgs(), c = a, u = this._mergeLabelPositionArgs(c, l), h = {
                position: this.getLabelPosition(r, o, s, u)
            };
            return this.model.insertLabel(-1, h, a), -1;
        },
        addVertex: function(t, e, i) {
            var n = "number" != typeof t, r = n ? t.x : t, o = n ? t.y : e, a = n ? e : i, s = {
                x: r,
                y: o
            }, l = this.getVertexIndex(r, o);
            return this.model.insertVertex(l, s, a), l;
        },
        sendToken: function(t, e, i) {
            var n, r, o;
            o = jo(e) ? (n = e.duration, r = "reverse" === e.direction, e.connection) : (n = e, r = !1, null);
            var a = {
                dur: (n = n || 1e3) + "ms",
                repeatCount: 1,
                calcMode: "linear",
                fill: "freeze"
            };
            r && (a.keyPoints = "1;0", a.keyTimes = "0;1");
            var s, l, c, u = wr(t);
            if ("string" == typeof o) s = this.findBySelector(o, this.el, this.selectors)[0];
            else {
                var h = this._V;
                s = h.connection ? h.connection.node : this.el.querySelector("path");
            }
            if (!(s instanceof SVGPathElement)) throw new Error("dia.LinkView: token animation requires a valid connection path.");
            u.appendTo(this.paper.cells).animateAlongPath(a, s), setTimeout((l = u, c = i, function() {
                l.remove(), "function" == typeof c && c();
            }), n);
        },
        findRoute: function(t) {
            t || (t = []);
            var e = this.paper.options.routerNamespace || Ss, i = this.model.router(), n = this.paper.options.defaultRouter;
            if (!i) {
                if (!n) return t.map(qi);
                i = n;
            }
            var r = go(i) ? i : e[i.name];
            if (!go(r)) throw new Error('dia.LinkView: unknown router: "' + i.name + '".');
            var o = i.args || {}, a = r.call(this, t, o, this);
            return a || t.map(qi);
        },
        findPath: function(t, e, i) {
            var n = this.paper.options.connectorNamespace || Hs, r = this.model.connector(), o = this.paper.options.defaultConnector;
            r || (r = o || {});
            var a = go(r) ? r : n[r.name];
            if (!go(a)) throw new Error('dia.LinkView: unknown connector: "' + r.name + '".');
            var s = lo(r.args || {});
            s.raw = !0;
            var l = a.call(this, e, i, t, s, this);
            return "string" == typeof l && (l = new Tn(wr.normalizePathData(l))), l;
        },
        getConnection: function() {
            var t = this.path;
            return t ? t.clone() : null;
        },
        getSerializedConnection: function() {
            var t = this.path;
            if (!t) return null;
            var e = this.metrics;
            if (e.hasOwnProperty("data")) return e.data;
            var i = t.serialize();
            return e.data = i;
        },
        getConnectionSubdivisions: function() {
            var t = this.path;
            if (!t) return null;
            var e = this.metrics;
            if (e.hasOwnProperty("segmentSubdivisions")) return e.segmentSubdivisions;
            var i = t.getSegmentSubdivisions();
            return e.segmentSubdivisions = i;
        },
        getConnectionLength: function() {
            var t = this.path;
            if (!t) return 0;
            var e = this.metrics;
            if (e.hasOwnProperty("length")) return e.length;
            var i = t.length({
                segmentSubdivisions: this.getConnectionSubdivisions()
            });
            return e.length = i;
        },
        getPointAtLength: function(t) {
            var e = this.path;
            return e ? e.pointAtLength(t, {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }) : null;
        },
        getPointAtRatio: function(t) {
            var e = this.path;
            return e ? (Er(t) && (t = parseFloat(t) / 100), e.pointAt(t, {
                segmentSubdivisions: this.getConnectionSubdivisions()
            })) : null;
        },
        getTangentAtLength: function(t) {
            var e = this.path;
            return e ? e.tangentAtLength(t, {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }) : null;
        },
        getTangentAtRatio: function(t) {
            var e = this.path;
            return e ? e.tangentAt(t, {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }) : null;
        },
        getClosestPoint: function(t) {
            var e = this.path;
            return e ? e.closestPoint(t, {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }) : null;
        },
        getClosestPointLength: function(t) {
            var e = this.path;
            return e ? e.closestPointLength(t, {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }) : null;
        },
        getClosestPointRatio: function(t) {
            var e = this.path;
            return e ? e.closestPointNormalizedLength(t, {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }) : null;
        },
        getLabelPosition: function(t, e, i, n) {
            var r, o = {}, a = 0;
            (r = "number" == typeof i ? (a = i, n) : i) && (o.args = r);
            var s, l, c = !(r && r.absoluteDistance), u = r && r.absoluteDistance && r.reverseDistance, h = r && r.absoluteOffset, g = this.path, d = {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }, f = new qi(t, e), p = g.closestPointT(f, d), m = g.lengthAtT(p, d);
            if (c && (m = m / this.getConnectionLength() || 0), u && (m = -1 * (this.getConnectionLength() - m) || 1), o.distance = m, h || (s = g.tangentAtT(p)), s) l = s.pointOffset(f);
            else {
                var I = g.pointAtT(p), v = f.difference(I);
                l = {
                    x: v.x,
                    y: v.y
                };
            }
            return o.offset = l, o.angle = a, o;
        },
        _getLabelTransformationMatrix: function(t) {
            var e, i = 0, n = {};
            if ("number" == typeof t) e = t;
            else {
                if ("number" != typeof t.distance) throw new Error("dia.LinkView: invalid label position distance.");
                n = t.args || {}, e = t.distance, i = t.angle || 0;
            }
            var r = 0 < e && e <= 1, o = 0, a = {
                x: 0,
                y: 0
            };
            if (t.offset) {
                var s = t.offset;
                "number" == typeof s && (o = s), s.x && (a.x = s.x), s.y && (a.y = s.y);
            }
            var l, c = 0 !== a.x || 0 !== a.y || 0 === o, u = n.keepGradient, h = n.ensureLegibility, g = this.path, d = {
                segmentSubdivisions: this.getConnectionSubdivisions()
            }, f = r ? e * this.getConnectionLength() : e, p = g.tangentAtLength(f, d), m = i;
            if (p) {
                if (c) (l = p.start).offset(a);
                else {
                    var I = p.clone();
                    I.rotate(p.start, -90), I.setLength(o), l = I.end;
                }
                u && (m = p.angle() + i, h && (m = Ti((m + 90) % 180 - 90)));
            } else l = g.start, c && l.offset(a);
            return wr.createSVGMatrix().translate(l.x, l.y).rotate(m);
        },
        getLabelCoordinates: function(t) {
            var e = this._getLabelTransformationMatrix(t);
            return new qi(e.e, e.f);
        },
        getVertexIndex: function(t, e) {
            for(var i = this.model.vertices(), n = this.getClosestPointLength(new qi(t, e)), r = 0, o = i.length; r < o; r++){
                var a = i[r];
                if (n < this.getClosestPointLength(a)) break;
            }
            return r;
        },
        notifyPointerdown: function(t, e, i) {
            Ua.prototype.pointerdown.call(this, t, e, i), this.notify("link:pointerdown", t, e, i);
        },
        notifyPointermove: function(t, e, i) {
            Ua.prototype.pointermove.call(this, t, e, i), this.notify("link:pointermove", t, e, i);
        },
        notifyPointerup: function(t, e, i) {
            this.notify("link:pointerup", t, e, i), Ua.prototype.pointerup.call(this, t, e, i);
        },
        pointerdblclick: function(t, e, i) {
            Ua.prototype.pointerdblclick.apply(this, arguments), this.notify("link:pointerdblclick", t, e, i);
        },
        pointerclick: function(t, e, i) {
            Ua.prototype.pointerclick.apply(this, arguments), this.notify("link:pointerclick", t, e, i);
        },
        contextmenu: function(t, e, i) {
            Ua.prototype.contextmenu.apply(this, arguments), this.notify("link:contextmenu", t, e, i);
        },
        pointerdown: function(t, e, i) {
            switch(this.notifyPointerdown(t, e, i), t.target.getAttribute("class")){
                case "marker-vertex":
                    return void this.dragVertexStart(t, e, i);
                case "marker-vertex-remove":
                case "marker-vertex-remove-area":
                    return void this.dragVertexRemoveStart(t, e, i);
                case "marker-arrowhead":
                    return void this.dragArrowheadStart(t, e, i);
                case "connection":
                case "connection-wrap":
                    return void this.dragConnectionStart(t, e, i);
                case "marker-source":
                case "marker-target":
                    return;
            }
            this.dragStart(t, e, i);
        },
        pointermove: function(t, e, i) {
            var n = this._dragData;
            switch(n && this.eventData(t, n), this.eventData(t).action){
                case "vertex-move":
                    this.dragVertex(t, e, i);
                    break;
                case "label-move":
                    this.dragLabel(t, e, i);
                    break;
                case "arrowhead-move":
                    this.dragArrowhead(t, e, i);
                    break;
                case "move":
                    this.drag(t, e, i);
            }
            n && io(n, this.eventData(t)), this.notifyPointermove(t, e, i);
        },
        pointerup: function(t, e, i) {
            var n = this._dragData;
            switch(n && (this.eventData(t, n), this._dragData = null), this.eventData(t).action){
                case "vertex-move":
                    this.dragVertexEnd(t, e, i);
                    break;
                case "label-move":
                    this.dragLabelEnd(t, e, i);
                    break;
                case "arrowhead-move":
                    this.dragArrowheadEnd(t, e, i);
                    break;
                case "move":
                    this.dragEnd(t, e, i);
            }
            this.notifyPointerup(t, e, i), this.checkMouseleave(t);
        },
        mouseover: function(t) {
            Ua.prototype.mouseover.apply(this, arguments), this.notify("link:mouseover", t);
        },
        mouseout: function(t) {
            Ua.prototype.mouseout.apply(this, arguments), this.notify("link:mouseout", t);
        },
        mouseenter: function(t) {
            Ua.prototype.mouseenter.apply(this, arguments), this.notify("link:mouseenter", t);
        },
        mouseleave: function(t) {
            Ua.prototype.mouseleave.apply(this, arguments), this.notify("link:mouseleave", t);
        },
        mousewheel: function(t, e, i, n) {
            Ua.prototype.mousewheel.apply(this, arguments), this.notify("link:mousewheel", t, e, i, n);
        },
        onevent: function(t, e, i, n) {
            if (wr(t.target).findParentByClass("link-tool", this.el)) {
                if (t.stopPropagation(), this.can("useLinkTools")) {
                    if ("remove" === e) return void this.model.remove({
                        ui: !0
                    });
                    this.notify(e, t, i, n);
                }
                this.notifyPointerdown(t, i, n), this.paper.delegateDragEvents(this, t.data);
            } else Ua.prototype.onevent.apply(this, arguments);
        },
        onlabel: function(t, e, i) {
            this.notifyPointerdown(t, e, i), this.dragLabelStart(t, e, i), this.eventData(t).stopPropagation && t.stopPropagation();
        },
        dragConnectionStart: function(t, e, i) {
            if (this.can("vertexAdd")) {
                var n = this.addVertex({
                    x: e,
                    y: i
                }, {
                    ui: !0
                });
                this.eventData(t, {
                    action: "vertex-move",
                    vertexIdx: n
                });
            }
        },
        dragLabelStart: function(t, e, i) {
            if (this.can("labelMove")) {
                var n = t.currentTarget, r = parseInt(n.getAttribute("label-idx"), 10), o = this._getLabelPositionAngle(r), a = this._getLabelPositionArgs(r), s = this._getDefaultLabelPositionArgs(), l = this._mergeLabelPositionArgs(a, s);
                this.eventData(t, {
                    action: "label-move",
                    labelIdx: r,
                    positionAngle: o,
                    positionArgs: l,
                    stopPropagation: !0
                });
            } else this.eventData(t, {
                stopPropagation: !0
            });
            this.paper.delegateDragEvents(this, t.data);
        },
        dragVertexStart: function(t, e, i) {
            if (this.can("vertexMove")) {
                var n = t.target, r = parseInt(n.getAttribute("idx"), 10);
                this.eventData(t, {
                    action: "vertex-move",
                    vertexIdx: r
                });
            }
        },
        dragVertexRemoveStart: function(t, e, i) {
            if (this.can("vertexRemove")) {
                var n = t.target, r = parseInt(n.getAttribute("idx"), 10);
                this.model.removeVertex(r);
            }
        },
        dragArrowheadStart: function(t, e, i) {
            if (this.can("arrowheadMove")) {
                var n = t.target.getAttribute("end"), r = this.startArrowheadMove(n, {
                    ignoreBackwardsCompatibility: !0
                });
                this.eventData(t, r);
            }
        },
        dragStart: function(t, e, i) {
            this.can("linkMove") && this.eventData(t, {
                action: "move",
                dx: e,
                dy: i
            });
        },
        dragLabel: function(t, e, i) {
            var n = this.eventData(t), r = {
                position: this.getLabelPosition(e, i, n.positionAngle, n.positionArgs)
            };
            this.paper.options.snapLabels && delete r.position.offset, this.model.label(n.labelIdx, r);
        },
        dragVertex: function(t, e, i) {
            var n = this.eventData(t);
            this.model.vertex(n.vertexIdx, {
                x: e,
                y: i
            }, {
                ui: !0
            });
        },
        dragArrowhead: function(t, e, i) {
            this.paper.options.snapLinks ? this._snapArrowhead(t, e, i) : this._connectArrowhead(this.getEventTarget(t), e, i, this.eventData(t));
        },
        drag: function(t, e, i) {
            var n = this.eventData(t);
            this.model.translate(e - n.dx, i - n.dy, {
                ui: !0
            }), this.eventData(t, {
                dx: e,
                dy: i
            });
        },
        dragLabelEnd: function() {},
        dragVertexEnd: function() {},
        dragArrowheadEnd: function(t, e, i) {
            var n = this.eventData(t), r = this.paper;
            r.options.snapLinks ? this._snapArrowheadEnd(n) : this._connectArrowheadEnd(n, e, i), r.linkAllowed(this) ? (this._finishEmbedding(n), this._notifyConnectEvent(n, t)) : this._disallow(n), this._afterArrowheadMove(n);
        },
        dragEnd: function() {},
        _disallow: function(t) {
            switch(t.whenNotAllowed){
                case "remove":
                    this.model.remove({
                        ui: !0
                    });
                    break;
                case "revert":
                default:
                    this.model.set(t.arrowhead, t.initialEnd, {
                        ui: !0
                    });
            }
        },
        _finishEmbedding: function(t) {
            this.paper.options.embeddingMode && this.model.reparent() && (t.z = null);
        },
        _notifyConnectEvent: function(t, e) {
            var i = t.arrowhead, n = t.initialEnd, r = this.model.prop(i);
            if (r && !Sa.endsEqual(n, r)) {
                var o = this.paper;
                n.id && this.notify("link:disconnect", e, o.findViewByModel(n.id), t.initialMagnet, i), r.id && this.notify("link:connect", e, o.findViewByModel(r.id), t.magnetUnderPointer, i);
            }
        },
        _snapArrowhead: function(t, e, i) {
            var r = this.paper, n = r.options, o = n.snapLinks, a = n.connectionStrategy, s = this.eventData(t), l = o.radius || 50, c = r.findViewsInArea({
                x: e - l,
                y: i - l,
                width: 2 * l,
                height: 2 * l
            }), u = s.closestView || null, h = s.closestMagnet || null, g = s.magnetProxy || null;
            s.closestView = s.closestMagnet = s.magnetProxy = null;
            var d, f = Number.MAX_VALUE, p = new qi(e, i);
            c.forEach(function(n) {
                var e = [];
                "false" !== n.el.getAttribute("magnet") && e.push({
                    bbox: n.model.getBBox(),
                    magnet: n.el
                }), n.$("[magnet]").toArray().forEach(function(t) {
                    e.push({
                        bbox: n.getNodeBBox(t),
                        magnet: t
                    });
                }), e.forEach(function(t) {
                    var e = t.magnet, i = t.bbox.center().squaredDistance(p);
                    i < f && (h === e || r.options.validateConnection.apply(r, s.validateConnectionArgs(n, n.el === e ? null : e))) && (f = i, s.closestView = n, s.closestMagnet = e);
                });
            }, this);
            var m = null, I = s.closestView, v = s.closestMagnet;
            v && (m = s.magnetProxy = I.findProxyNode(v, "highlighter"));
            var A = s.arrowhead, C = h !== v;
            if (u && C && u.unhighlight(g, {
                connecting: !0,
                snapping: !0
            }), I) {
                var y = s.prevEnd, w = s.prevX, b = s.prevY;
                if (s.prevX = e, s.prevY = i, !C && ("function" != typeof a || w === e && b === i)) return;
                if (d = I.getLinkEnd(v, e, i, this.model, A), !C && ho(y, d)) return;
                s.prevEnd = d, C && I.highlight(m, {
                    connecting: !0,
                    snapping: !0
                });
            } else d = {
                x: e,
                y: i
            };
            this.model.set(A, d || {
                x: e,
                y: i
            }, {
                ui: !0
            }), u && this.notify("link:snap:disconnect", t, u, h, A), I && this.notify("link:snap:connect", t, I, v, A);
        },
        _snapArrowheadEnd: function(t) {
            var e = t.closestView, i = t.closestMagnet;
            e && i && (e.unhighlight(t.magnetProxy, {
                connecting: !0,
                snapping: !0
            }), t.magnetUnderPointer = e.findMagnet(i)), t.closestView = t.closestMagnet = null;
        },
        _connectArrowhead: function(t, e, i, n) {
            var r = this.paper, o = this.model;
            if (n.eventTarget !== t) {
                n.magnetProxy && n.viewUnderPointer.unhighlight(n.magnetProxy, {
                    connecting: !0
                });
                var a = n.viewUnderPointer = r.findView(t);
                if (a) {
                    var s = n.magnetUnderPointer = a.findMagnet(t), l = n.magnetProxy = a.findProxyNode(s, "highlighter");
                    s && this.paper.options.validateConnection.apply(r, n.validateConnectionArgs(a, s)) ? l && a.highlight(l, {
                        connecting: !0
                    }) : (n.magnetUnderPointer = null, n.magnetProxy = null);
                } else n.magnetUnderPointer = null, n.magnetProxy = null;
            }
            n.eventTarget = t, o.set(n.arrowhead, {
                x: e,
                y: i
            }, {
                ui: !0
            });
        },
        _connectArrowheadEnd: function(t, e, i) {
            void 0 === t && (t = {});
            var n = this.model, r = t.viewUnderPointer, o = t.magnetUnderPointer, a = t.magnetProxy, s = t.arrowhead;
            if (o && a && r) {
                r.unhighlight(a, {
                    connecting: !0
                });
                var l = r.getLinkEnd(o, e, i, n, s);
                n.set(s, l, {
                    ui: !0
                });
            }
        },
        _beforeArrowheadMove: function(t) {
            t.z = this.model.get("z"), this.model.toFront();
            var e = this.el.style;
            t.pointerEvents = e.pointerEvents, e.pointerEvents = "none", this.paper.options.markAvailable && this._markAvailableMagnets(t);
        },
        _afterArrowheadMove: function(t) {
            null !== t.z && (this.model.set("z", t.z, {
                ui: !0
            }), t.z = null), this.el.style.pointerEvents = t.pointerEvents, this.paper.options.markAvailable && this._unmarkAvailableMagnets(t);
        },
        _createValidateConnectionArgs: function(t) {
            var e, i = [];
            i[4] = t, i[5] = this;
            var n = 0, r = 0;
            e = "source" === t ? (n = 2, "target") : (r = 2, "source");
            var o = this.model.get(e);
            if (o.id) {
                var a = i[n] = this.paper.findViewByModel(o.id), s = a.getMagnetFromLinkEnd(o);
                s === a.el && (s = void 0), i[n + 1] = s;
            }
            return function(t, e) {
                return i[r] = t, i[r + 1] = t.el === e ? void 0 : e, i;
            };
        },
        _markAvailableMagnets: function(t) {
            function e(t, e) {
                var i = t.paper;
                return i.options.validateConnection.apply(i, this.validateConnectionArgs(t, e));
            }
            var i = this.paper, n = i.model.getCells();
            t.marked = {};
            for(var r = 0, o = n.length; r < o; r++){
                var a = n[r].findView(i);
                if (a) {
                    var s = Array.prototype.slice.call(a.el.querySelectorAll("[magnet]"));
                    "false" !== a.el.getAttribute("magnet") && s.push(a.el);
                    var l = s.filter(e.bind(t, a));
                    if (0 < l.length) {
                        for(var c = 0, u = l.length; c < u; c++)a.highlight(l[c], {
                            magnetAvailability: !0
                        });
                        a.highlight(null, {
                            elementAvailability: !0
                        }), t.marked[a.model.id] = l;
                    }
                }
            }
        },
        _unmarkAvailableMagnets: function(t) {
            for(var e, i, n = Object.keys(t.marked), r = 0, o = n.length; r < o; r++){
                e = n[r], i = t.marked[e];
                var a = this.paper.findViewByModel(e);
                if (a) {
                    for(var s = 0, l = i.length; s < l; s++)a.unhighlight(i[s], {
                        magnetAvailability: !0
                    });
                    a.unhighlight(null, {
                        elementAvailability: !0
                    });
                }
            }
            t.marked = null;
        },
        startArrowheadMove: function(t, e) {
            e || (e = {});
            var i = {
                action: "arrowhead-move",
                arrowhead: t,
                whenNotAllowed: e.whenNotAllowed || "revert",
                initialMagnet: this[t + "Magnet"] || (this[t + "View"] ? this[t + "View"].el : null),
                initialEnd: lo(this.model.get(t)),
                validateConnectionArgs: this._createValidateConnectionArgs(t)
            };
            return this._beforeArrowheadMove(i), !0 !== e.ignoreBackwardsCompatibility && (this._dragData = i), i;
        },
        onRemove: function() {
            Ua.prototype.onRemove.apply(this, arguments), this.unmountLabels();
        }
    }, {
        Flags: Js
    });
    Object.defineProperty(_s.prototype, "sourceBBox", {
        enumerable: !0,
        get: function() {
            var t = this.sourceView;
            if (!t) {
                var e = this.model.source();
                return new In(e.x, e.y);
            }
            var i = this.sourceMagnet;
            return t.isNodeConnection(i) ? new In(this.sourceAnchor) : t.getNodeBBox(i || t.el);
        }
    }), Object.defineProperty(_s.prototype, "targetBBox", {
        enumerable: !0,
        get: function() {
            var t = this.targetView;
            if (!t) {
                var e = this.model.target();
                return new In(e.x, e.y);
            }
            var i = this.targetMagnet;
            return t.isNodeConnection(i) ? new In(this.targetAnchor) : t.getNodeBBox(i || t.el);
        }
    });
    var Qs = Ya.extend({
        tagName: "path",
        className: "highlight-stroke",
        attributes: {
            "pointer-events": "none",
            "vector-effect": "non-scaling-stroke",
            fill: "none"
        },
        options: {
            padding: 3,
            rx: 0,
            ry: 0,
            useFirstSubpath: !1,
            attrs: {
                "stroke-width": 3,
                stroke: "#FEB663"
            }
        },
        getPathData: function(e, i) {
            var n, r = this.options, t = r.useFirstSubpath;
            try {
                var o = wr(i);
                if (n = o.convertToPathData().trim(), "PATH" === o.tagName() && t) {
                    var a = n.search(/.M/i) + 1;
                    0 < a && (n = n.substr(0, a));
                }
            } catch (t1) {
                var s = e.getNodeBoundingRect(i);
                n = wr.rectToPath(io({}, r, s.toJSON()));
            }
            return n;
        },
        highlightConnection: function(t) {
            this.vel.attr("d", t.getSerializedConnection());
        },
        highlightNode: function(t, e) {
            var i = this.vel, n = this.options, r = n.padding, o = n.layer, a = t.getNodeMatrix(e);
            if (r) {
                o || e !== t.el || i.remove();
                var s = t.getNodeBoundingRect(e), l = s.x + s.width / 2, c = s.y + s.height / 2;
                s = wr.transformRect(s, a);
                var u = Math.max(s.width, 1), h = Math.max(s.height, 1), g = (u + r) / u, d = (h + r) / h, f = wr.createSVGMatrix({
                    a: g,
                    b: 0,
                    c: 0,
                    d: d,
                    e: l - g * l,
                    f: c - d * c
                });
                a = a.multiply(f);
            }
            i.attr({
                d: this.getPathData(t, e),
                transform: wr.matrixToTransformString(a)
            });
        },
        highlight: function(t, e) {
            var i = this.vel, n = this.options;
            i.attr(n.attrs), t.isNodeConnection(e) ? this.highlightConnection(t) : this.highlightNode(t, e);
        }
    });
    var Ks = Ya.extend({
        tagName: "rect",
        className: "highlight-mask",
        attributes: {
            "pointer-events": "none"
        },
        options: {
            padding: 3,
            maskClip: 20,
            deep: !1,
            attrs: {
                stroke: "#FEB663",
                "stroke-width": 3,
                "stroke-linecap": "butt",
                "stroke-linejoin": "miter"
            }
        },
        VISIBLE: "white",
        INVISIBLE: "black",
        MASK_ROOT_ATTRIBUTE_BLACKLIST: [
            "marker-start",
            "marker-end",
            "marker-mid",
            "transform",
            "stroke-dasharray"
        ],
        MASK_CHILD_ATTRIBUTE_BLACKLIST: [
            "stroke",
            "fill",
            "stroke-width",
            "stroke-opacity",
            "stroke-dasharray",
            "fill-opacity",
            "marker-start",
            "marker-end",
            "marker-mid"
        ],
        MASK_REPLACE_TAGS: [
            "FOREIGNOBJECT",
            "IMAGE",
            "USE",
            "TEXT",
            "TSPAN",
            "TEXTPATH"
        ],
        MASK_REMOVE_TAGS: [
            "TEXT",
            "TSPAN",
            "TEXTPATH"
        ],
        transformMaskChild: function(t, e) {
            var i = this.MASK_CHILD_ATTRIBUTE_BLACKLIST, n = this.MASK_REPLACE_TAGS, r = this.MASK_REMOVE_TAGS, o = e.tagName();
            if (!wr.isSVGGraphicsElement(e) || r.includes(o)) return e.remove(), !1;
            if (n.includes(o)) {
                var a = t.vel.findOne("#" + e.id);
                if (a) {
                    var s = a.node, l = t.getNodeBoundingRect(s);
                    t.model.isElement() && (l = wr.transformRect(l, t.getNodeMatrix(s)));
                    var c = wr("rect", l.toJSON()), u = l.center(), h = u.x, g = u.y, d = a.rotate(), f = d.angle, p = d.cx;
                    void 0 === p && (p = h);
                    var m = d.cy;
                    void 0 === m && (m = g), f && c.rotate(f, p, m), e.parent().append(c);
                }
                return e.remove(), !1;
            }
            return i.forEach(function(t) {
                "fill" === t && "none" === e.attr("fill") || e.removeAttr(t);
            }), !0;
        },
        transformMaskRoot: function(t, e) {
            this.MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(function(t) {
                e.removeAttr(t);
            });
        },
        getMaskShape: function(e, t) {
            var i, n = this, r = this.options, o = this.MASK_REPLACE_TAGS, a = r.deep, s = t.tagName();
            if ("G" === s) {
                if (!a) return null;
                (function(t, e) {
                    for(var i = t.children(); 0 < i.length;){
                        var n = i.shift();
                        e(n) && i.push.apply(i, n.children());
                    }
                })(i = t.clone(), function(t) {
                    return n.transformMaskChild(e, t);
                });
            } else {
                if (o.includes(s)) return null;
                i = t.clone();
            }
            return this.transformMaskRoot(e, i), i;
        },
        getMaskId: function() {
            return "highlight-mask-" + this.cid;
        },
        getMask: function(t, e) {
            var i = this.VISIBLE, n = this.INVISIBLE, r = this.options, o = r.padding, a = r.attrs, s = "stroke-width" in a ? a["stroke-width"] : 1, l = "none" !== e.attr("fill"), c = parseFloat(e.attr("stroke-width"));
            isNaN(c) && (c = 1);
            var u = c + 2 * o, h = u + 2 * s, g = this.getMaskShape(t, e);
            if (!g) {
                var d = t.getNodeBoundingRect(e.node);
                d.inflate(d.width ? 0 : .5, d.height ? 0 : .5), g = wr("rect", d.toJSON());
            }
            return g.attr(a), wr("mask", {
                id: this.getMaskId()
            }).append([
                g.clone().attr({
                    fill: l ? i : "none",
                    stroke: i,
                    "stroke-width": h
                }),
                g.clone().attr({
                    fill: l ? n : "none",
                    stroke: n,
                    "stroke-width": u
                })
            ]);
        },
        removeMask: function(t) {
            var e = t.svg.getElementById(this.getMaskId());
            e && t.defs.removeChild(e);
        },
        addMask: function(t, e) {
            t.defs.appendChild(e.node);
        },
        highlight: function(t, e) {
            var i = this.options, n = this.vel, r = i.padding, o = i.attrs, a = i.maskClip;
            void 0 === a && (a = 20);
            var s = i.layer, l = "stroke" in o ? o.stroke : "#000000";
            s || e !== t.el || n.remove();
            var c = t.getNodeBoundingRect(e).inflate(r + a), u = this.getMask(t, wr(e));
            this.addMask(t.paper, u), n.attr(c.toJSON()), n.attr({
                transform: wr.matrixToTransformString(t.getNodeMatrix(e)),
                mask: "url(#" + u.id + ")",
                fill: l
            });
        },
        unhighlight: function(t) {
            this.removeMask(t.paper);
        }
    }), qs = Ya.extend({
        UPDATABLE: !1,
        MOUNTABLE: !1,
        opacityClassName: Nr("highlight-opacity"),
        highlight: function(t, e) {
            wr(e).addClass(this.opacityClassName);
        },
        unhighlight: function(t, e) {
            wr(e).removeClass(this.opacityClassName);
        }
    }), $s = Nr("highlighted"), tl = {
        stroke: Qs,
        mask: Ks,
        opacity: qs,
        addClass: Ya.extend({
            UPDATABLE: !1,
            MOUNTABLE: !1,
            options: {
                className: $s
            },
            highlight: function(t, e) {
                wr(e).addClass(this.options.className);
            },
            unhighlight: function(t, e) {
                wr(e).removeClass(this.options.className);
            }
        }, {
            className: $s
        })
    };
    function el(a) {
        return function(t, e, i, n) {
            if (i instanceof Element) {
                var r, o = this.paper.findView(i);
                if (o) {
                    if (o.isNodeConnection(i)) r = il(o, "fixedAt" in n ? n.fixedAt : "50%");
                    else r = o.getNodeBBox(i).center();
                } else r = new qi;
                return a.call(this, t, e, r, n);
            }
            return a.apply(this, arguments);
        };
    }
    function il(t, e) {
        var i = parseFloat(e);
        return Er(e) ? t.getPointAtRatio(i / 100) : t.getPointAtLength(i);
    }
    var nl = el(function(t, e, i, n) {
        var r = t.getConnection(), o = t.getConnectionSubdivisions(), a = new nn(i.clone().offset(0, 1e6), i.clone().offset(0, -1000000)), s = new nn(i.clone().offset(1e6, 0), i.clone().offset(-1000000, 0)), l = a.intersect(r, {
            segmentSubdivisions: o
        }), c = s.intersect(r, {
            segmentSubdivisions: o
        }), u = [];
        return l && Array.prototype.push.apply(u, l), c && Array.prototype.push.apply(u, c), 0 < u.length ? i.chooseClosest(u) : "fallbackAt" in n ? il(t, n.fallbackAt) : rl(t, e, i, n);
    }), rl = el(function(t, e, i, n) {
        var r = t.getClosestPoint(i);
        return r || new qi;
    }), ol = {
        resolveRef: el,
        connectionRatio: function(t, e, i, n) {
            var r = "ratio" in n ? n.ratio : .5;
            return t.getPointAtRatio(r);
        },
        connectionLength: function(t, e, i, n) {
            var r = "length" in n ? n.length : 20;
            return t.getPointAtLength(r);
        },
        connectionPerpendicular: nl,
        connectionClosest: rl
    };
    function al(t, e, i) {
        if (fo(i)) {
            var n = i.x, r = i.y;
            if (isFinite(r)) {
                var o = new nn(e, t).parallel(r);
                e = o.start, t = o.end;
            }
            i = n;
        }
        if (!isFinite(i)) return t;
        var a = t.distance(e);
        return 0 === i && 0 < a ? t : t.move(e, -Math.min(i, a - 1));
    }
    function sl(t) {
        var e = t.getAttribute("stroke-width");
        return null === e ? 0 : parseFloat(e) || 0;
    }
    function ll(t, e, i, n) {
        var r = e.getNodeBBox(i);
        n.stroke && r.inflate(sl(i) / 2);
        var o = t.intersect(r);
        return al(o ? t.start.chooseClosest(o) : t.end, t.start, n.offset);
    }
    var cl = "segmentSubdivisons", ul = "shapeBBox";
    var hl = {
        anchor: function(t, e, i, n) {
            var r = n.offset, o = n.alignOffset, a = n.align;
            return a && function(t, e, i) {
                var n, r, o, a;
                void 0 === i && (i = 0);
                var s = t.start, l = t.end;
                switch(e){
                    case "left":
                        n = "x", r = l, o = s, a = -1;
                        break;
                    case "right":
                        n = "x", r = s, o = l, a = 1;
                        break;
                    case "top":
                        n = "y", r = l, o = s, a = -1;
                        break;
                    case "bottom":
                        n = "y", r = s, o = l, a = 1;
                        break;
                    default:
                        return;
                }
                s[n] < l[n] ? r[n] = o[n] : o[n] = r[n], isFinite(i) && (r[n] += a * i, o[n] += a * i);
            }(t, a, o), al(t.end, t.start, r);
        },
        bbox: ll,
        rectangle: function(t, e, i, n) {
            var r = e.model.angle();
            if (0 === r) return ll(t, e, i, n);
            var o = e.getNodeUnrotatedBBox(i);
            n.stroke && o.inflate(sl(i) / 2);
            var a = o.center(), s = t.clone().rotate(a, r), l = s.setLength(1e6).intersect(o);
            return al(l ? s.start.chooseClosest(l).rotate(a, -r) : t.end, t.start, n.offset);
        },
        boundary: function(t, e, i, n) {
            var r, o, a = n.selector, s = t.end;
            if (r = "string" == typeof a ? e.findBySelector(a)[0] : Array.isArray(a) ? kr(i, a) : function(t) {
                if (!t) return null;
                var e = t;
                do {
                    var i = e.tagName;
                    if ("string" != typeof i) return null;
                    if ("G" === (i = i.toUpperCase())) e = e.firstElementChild;
                    else {
                        if ("TITLE" !== i) break;
                        e = e.nextElementSibling;
                    }
                }while (e);
                return e;
            }(i), !wr.isSVGGraphicsElement(r)) {
                if (r === i || !wr.isSVGGraphicsElement(i)) return s;
                r = i;
            }
            var l, c = e.getNodeShape(r), u = e.getNodeMatrix(r), h = e.getRootTranslateMatrix(), g = e.getRootRotateMatrix(), d = h.multiply(g).multiply(u), f = d.inverse(), p = wr.transformLine(t, f), m = p.start.clone(), I = e.getNodeData(r);
            if (!1 === n.insideout && (I[ul] || (I[ul] = c.bbox()), I[ul].containsPoint(m))) return s;
            if (c instanceof Tn) {
                var v = n.precision || 2;
                I[cl] || (I[cl] = c.getSegmentSubdivisions({
                    precision: v
                })), l = {
                    precision: v,
                    segmentSubdivisions: I[cl]
                };
            }
            !0 === n.extrapolate && p.setLength(1e6), (o = p.intersect(c, l)) ? wr.isArray(o) && (o = m.chooseClosest(o)) : !0 === n.sticky && (o = c instanceof In ? c.pointNearestToPoint(m) : c instanceof ln ? c.intersectionWithLineFromCenterToPoint(m) : c.closestPoint(m, l));
            var A = o ? wr.transformPoint(o, d) : s, C = n.offset || 0;
            return n.stroke && (C += sl(r) / 2), al(A, t.start, C);
        }
    };
    function gl(h) {
        return function(t, e, i, n) {
            var r = !!n.rotate, o = r ? t.getNodeUnrotatedBBox(e) : t.getNodeBBox(e), a = o[h](), s = n.dx;
            if (s) {
                var l = Er(s);
                s = parseFloat(s), isFinite(s) && (l && (s /= 100, s *= o.width), a.x += s);
            }
            var c = n.dy;
            if (c) {
                var u = Er(c);
                c = parseFloat(c), isFinite(c) && (u && (c /= 100, c *= o.height), a.y += c);
            }
            return r ? a.rotate(t.model.getBBox().center(), -t.model.angle()) : a;
        };
    }
    var dl = {
        center: gl("center"),
        top: gl("topMiddle"),
        bottom: gl("bottomMiddle"),
        left: gl("leftMiddle"),
        right: gl("rightMiddle"),
        topLeft: gl("origin"),
        topRight: gl("topRight"),
        bottomLeft: gl("bottomLeft"),
        bottomRight: gl("corner"),
        perpendicular: el(function(t, e, i, n) {
            var r = t.model.angle(), o = t.getNodeBBox(e), a = o.center(), s = o.origin(), l = o.corner(), c = n.padding;
            if (isFinite(c) || (c = 0), s.y + c <= i.y && i.y <= l.y - c) {
                var u = i.y - a.y;
                a.x += 0 === r || 180 === r ? 0 : 1 * u / Math.tan(Pi(r)), a.y += u;
            } else if (s.x + c <= i.x && i.x <= l.x - c) {
                var h = i.x - a.x;
                a.y += 90 === r || 270 === r ? 0 : h * Math.tan(Pi(r)), a.x += h;
            }
            return a;
        }),
        midSide: el(function(t, e, i, n) {
            var r, o, a, s = !!n.rotate;
            s ? (r = t.getNodeUnrotatedBBox(e), a = t.model.getBBox().center(), o = t.model.angle()) : r = t.getNodeBBox(e);
            var l, c = n.padding;
            switch(isFinite(c) && r.inflate(c), s && i.rotate(a, o), r.sideNearestToPoint(i)){
                case "left":
                    l = r.leftMiddle();
                    break;
                case "right":
                    l = r.rightMiddle();
                    break;
                case "top":
                    l = r.topMiddle();
                    break;
                case "bottom":
                    l = r.bottomMiddle();
            }
            return s ? l.rotate(a, -o) : l;
        }),
        modelCenter: function(t, e, i, n, r) {
            return t.model.getPointFromConnectedLink(this.model, r).offset(n.dx, n.dy);
        }
    }, fl = {
        NONE: "sorting-none",
        APPROX: "sorting-approximate",
        EXACT: "sorting-exact"
    }, pl = 9007199254740991, ml = Ua.Highlighting, Il = {};
    Il[ml.DEFAULT] = {
        name: "stroke",
        options: {
            padding: 3
        }
    }, Il[ml.MAGNET_AVAILABILITY] = {
        name: "addClass",
        options: {
            className: "available-magnet"
        }
    }, Il[ml.ELEMENT_AVAILABILITY] = {
        name: "addClass",
        options: {
            className: "available-cell"
        }
    };
    var vl = [
        {
            name: Oa.BACK
        },
        {
            name: Oa.CELLS
        },
        {
            name: Oa.LABELS
        },
        {
            name: Oa.FRONT
        },
        {
            name: Oa.TOOLS
        }
    ], Al = Za.extend({
        className: "paper",
        options: {
            width: 800,
            height: 600,
            origin: {
                x: 0,
                y: 0
            },
            gridSize: 1,
            drawGrid: !1,
            background: !1,
            perpendicularLinks: !1,
            elementView: Va,
            linkView: _s,
            snapLabels: !1,
            snapLinks: !1,
            labelsLayer: !1,
            multiLinks: !0,
            guard: function(t, e) {
                return !1;
            },
            highlighting: Il,
            preventContextMenu: !0,
            preventDefaultBlankAction: !0,
            restrictTranslate: !1,
            markAvailable: !1,
            defaultLink: new Sa,
            defaultConnector: {
                name: "normal"
            },
            defaultRouter: {
                name: "normal"
            },
            defaultAnchor: {
                name: "center"
            },
            defaultLinkAnchor: {
                name: "connectionRatio"
            },
            defaultConnectionPoint: {
                name: "bbox"
            },
            connectionStrategy: null,
            validateMagnet: function(t, e, i) {
                return "passive" !== e.getAttribute("magnet");
            },
            validateConnection: function(t, e, i, n, r, o) {
                return ("target" === r ? i : t) instanceof Va;
            },
            embeddingMode: !1,
            validateEmbedding: function(t, e) {
                return !0;
            },
            validateUnembedding: function(t) {
                return !0;
            },
            findParentBy: "bbox",
            frontParentOnly: !0,
            interactive: {
                labelMove: !1
            },
            linkPinning: !0,
            allowLink: null,
            clickThreshold: 0,
            moveThreshold: 0,
            magnetThreshold: 0,
            sorting: fl.EXACT,
            frozen: !1,
            onViewUpdate: function(t, e, i, n, r) {
                e & (t.FLAG_INSERT | t.FLAG_REMOVE) || n.mounting || n.isolate || r.requestConnectedLinksUpdate(t, i, n);
            },
            onViewPostponed: function(t, e, i) {
                return i.forcePostponedViewUpdate(t, e);
            },
            beforeRender: null,
            afterRender: null,
            viewport: null,
            cellViewNamespace: null,
            routerNamespace: null,
            connectorNamespace: null,
            highlighterNamespace: tl,
            anchorNamespace: dl,
            linkAnchorNamespace: ol,
            connectionPointNamespace: hl
        },
        events: {
            dblclick: "pointerdblclick",
            contextmenu: "contextmenu",
            mousedown: "pointerdown",
            touchstart: "pointerdown",
            mouseover: "mouseover",
            mouseout: "mouseout",
            mouseenter: "mouseenter",
            mouseleave: "mouseleave",
            wheel: "mousewheel",
            "mouseenter .joint-cell": "mouseenter",
            "mouseleave .joint-cell": "mouseleave",
            "mouseenter .joint-tools": "mouseenter",
            "mouseleave .joint-tools": "mouseleave",
            "mousedown .joint-cell [event]": "onevent",
            "touchstart .joint-cell [event]": "onevent",
            "mousedown .joint-cell [magnet]": "onmagnet",
            "touchstart .joint-cell [magnet]": "onmagnet",
            "dblclick .joint-cell [magnet]": "magnetpointerdblclick",
            "contextmenu .joint-cell [magnet]": "magnetcontextmenu",
            "mousedown .joint-link .label": "onlabel",
            "touchstart .joint-link .label": "onlabel",
            "dragstart .joint-cell image": "onImageDragStart"
        },
        documentEvents: {
            mousemove: "pointermove",
            touchmove: "pointermove",
            mouseup: "pointerup",
            touchend: "pointerup",
            touchcancel: "pointerup"
        },
        svg: null,
        viewport: null,
        defs: null,
        tools: null,
        $background: null,
        layers: null,
        $grid: null,
        $document: null,
        _viewportMatrix: null,
        _viewportTransformString: null,
        _updates: null,
        _layers: null,
        SORT_DELAYING_BATCHES: [
            "add",
            "to-front",
            "to-back"
        ],
        UPDATE_DELAYING_BATCHES: [
            "translate"
        ],
        MIN_SCALE: 1e-6,
        init: function() {
            var t = this.options, e = this.el;
            t.cellViewNamespace || (t.cellViewNamespace = "undefined" != typeof joint && No(joint, "shapes") ? joint.shapes : null);
            var i = this.model = t.model || new Pa;
            this._layers = {}, this.setGrid(t.drawGrid), this.cloneOptions(), this.render(), this._setDimensions(), this.startListening(), this._views = {}, this.$document = S(e.ownerDocument), this.resetViews(i.attributes.cells.models), !this.isFrozen() && this.isAsync() && this.updateViewsAsync();
        },
        _resetUpdates: function() {
            return this._updates = {
                id: null,
                priorities: [
                    {},
                    {},
                    {}
                ],
                unmountedCids: [],
                mountedCids: [],
                unmounted: {},
                mounted: {},
                count: 0,
                keyFrozen: !1,
                freezeKey: null,
                sort: !1
            };
        },
        startListening: function() {
            var t = this.model;
            this.listenTo(t, "add", this.onCellAdded).listenTo(t, "remove", this.onCellRemoved).listenTo(t, "change", this.onCellChange).listenTo(t, "reset", this.onGraphReset).listenTo(t, "sort", this.onGraphSort).listenTo(t, "batch:stop", this.onGraphBatchStop), this.on("cell:highlight", this.onCellHighlight).on("cell:unhighlight", this.onCellUnhighlight).on("scale translate", this.update);
        },
        onCellAdded: function(t, e, i) {
            var n = i.position;
            this.isAsync() || !Zo(n) ? this.renderView(t, i) : (i.maxPosition === n && this.freeze({
                key: "addCells"
            }), this.renderView(t, i), 0 === n && this.unfreeze({
                key: "addCells"
            }));
        },
        onCellRemoved: function(t, e, i) {
            var n = this.findViewByModel(t);
            n && this.requestViewUpdate(n, n.FLAG_REMOVE, n.UPDATE_PRIORITY, i);
        },
        onCellChange: function(t, e) {
            if (t !== this.model.attributes.cells && t.hasChanged("z") && this.options.sorting === fl.APPROX) {
                var i = this.findViewByModel(t);
                i && this.requestViewUpdate(i, i.FLAG_INSERT, i.UPDATE_PRIORITY, e);
            }
        },
        onGraphReset: function(t, e) {
            this.resetLayers(), this.resetViews(t.models, e);
        },
        onGraphSort: function() {
            this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES) || this.sortViews();
        },
        onGraphBatchStop: function(t) {
            if (!this.isFrozen()) {
                var e = t && t.batchName, i = this.model;
                if (!this.isAsync()) {
                    var n = this.UPDATE_DELAYING_BATCHES;
                    n.includes(e) && !i.hasActiveBatch(n) && this.updateViews(t);
                }
                var r = this.SORT_DELAYING_BATCHES;
                r.includes(e) && !i.hasActiveBatch(r) && this.sortViews();
            }
        },
        cloneOptions: function() {
            var t = this.options, e = t.defaultConnector, i = t.defaultRouter, n = t.defaultConnectionPoint, r = t.defaultAnchor, o = t.defaultLinkAnchor, a = t.origin, s = t.highlighting, l = t.cellViewNamespace, c = t.interactive;
            !l && "undefined" != typeof joint && No(joint, "shapes") && (t.cellViewNamespace = joint.shapes), go(e) || (t.defaultConnector = co(e)), go(i) || (t.defaultRouter = co(i)), go(n) || (t.defaultConnectionPoint = co(n)), go(r) || (t.defaultAnchor = co(r)), go(o) || (t.defaultLinkAnchor = co(o)), fo(c) && (t.interactive = io({}, c)), fo(s) && (t.highlighting = ro({}, s, Il)), t.origin = io({}, a);
        },
        children: function() {
            var t = wr.namespace;
            return [
                {
                    namespaceURI: t.xhtml,
                    tagName: "div",
                    className: Nr("paper-background"),
                    selector: "background"
                },
                {
                    namespaceURI: t.xhtml,
                    tagName: "div",
                    className: Nr("paper-grid"),
                    selector: "grid"
                },
                {
                    namespaceURI: t.svg,
                    tagName: "svg",
                    attributes: {
                        width: "100%",
                        height: "100%",
                        "xmlns:xlink": t.xlink
                    },
                    selector: "svg",
                    children: [
                        {
                            tagName: "defs",
                            selector: "defs"
                        },
                        {
                            tagName: "g",
                            className: Nr("layers"),
                            selector: "layers"
                        }
                    ]
                }
            ];
        },
        hasLayerView: function(t) {
            return t in this._layers;
        },
        getLayerView: function(t) {
            var e = this._layers;
            if (t in e) return e[t];
            throw new Error('dia.Paper: Unknown layer "' + t + '"');
        },
        getLayerNode: function(t) {
            return this.getLayerView(t).el;
        },
        render: function() {
            this.renderChildren();
            var t = this.childNodes, e = this.options, i = t.svg, n = t.defs, r = t.layers, o = t.background, a = t.grid;
            return this.svg = i, this.defs = n, this.layers = r, this.$background = S(o), this.$grid = S(a), this.renderLayers(), wr.ensureId(i), e.background && this.drawBackground(e.background), e.drawGrid && this.drawGrid(), this;
        },
        renderLayers: function(t) {
            var n = this;
            void 0 === t && (t = vl), this.removeLayers(), t.forEach(function(t) {
                var e = t.name, i = (t.sorted, new Ea({
                    name: e
                }));
                n.layers.appendChild(i.el), n._layers[e] = i;
            });
            var e = this.getLayerView(Oa.CELLS), i = this.getLayerView(Oa.TOOLS), r = this.getLayerView(Oa.LABELS);
            this.tools = i.el, this.cells = this.viewport = e.el, e.vel.addClass(Nr("viewport")), r.vel.addClass(Nr("viewport"));
        },
        removeLayers: function() {
            var e = this._layers;
            Object.keys(e, function(t) {
                e[t].remove(), delete e[t];
            });
        },
        resetLayers: function() {
            var e = this._layers;
            Object.keys(e, function(t) {
                e[t].removePivots();
            });
        },
        update: function() {
            return this.options.drawGrid && this.drawGrid(), this._background && this.updateBackgroundImage(this._background), this;
        },
        matrix: function(t) {
            var e = this.layers;
            if (void 0 === t) {
                var i = e.getAttribute("transform");
                return (this._viewportTransformString || null) === i ? t = this._viewportMatrix : (t = e.getCTM(), this._viewportMatrix = t, this._viewportTransformString = i), wr.createSVGMatrix(t);
            }
            t = wr.createSVGMatrix(t);
            var n = wr.matrixToTransformString(t);
            return e.setAttribute("transform", n), this._viewportMatrix = t, this._viewportTransformString = e.getAttribute("transform"), this;
        },
        clientMatrix: function() {
            return wr.createSVGMatrix(this.cells.getScreenCTM());
        },
        requestConnectedLinksUpdate: function(t, e, i) {
            if (t instanceof Ua) for(var n = t.model, r = this.model.getConnectedLinks(n), o = 0, a = r.length; o < a; o++){
                var s = r[o], l = this.findViewByModel(s);
                if (l) {
                    var c = [
                        "UPDATE"
                    ];
                    s.getTargetCell() === n && c.push("TARGET"), s.getSourceCell() === n && c.push("SOURCE");
                    var u = Math.max(e + 1, l.UPDATE_PRIORITY);
                    this.scheduleViewUpdate(l, l.getFlag(c), u, i);
                }
            }
        },
        forcePostponedViewUpdate: function(t, e) {
            if (!(t && t instanceof Ua)) return !1;
            var i = t.model;
            if (i.isElement()) return !1;
            if (0 == (e & t.getFlag([
                "SOURCE",
                "TARGET"
            ]))) {
                var n = 0, r = this.findViewByModel(i.getSourceCell());
                r && !this.isViewMounted(r) && (n = this.dumpView(r), t.updateEndMagnet("source"));
                var o = 0, a = this.findViewByModel(i.getTargetCell());
                if (a && !this.isViewMounted(a) && (o = this.dumpView(a), t.updateEndMagnet("target")), 0 === n && 0 === o) return !this.dumpView(t);
            }
            return !1;
        },
        requestViewUpdate: function(t, e, i, n) {
            n || (n = {}), this.scheduleViewUpdate(t, e, i, n);
            var r = this.isAsync();
            if (!(this.isFrozen() || r && !1 !== n.async || this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES))) {
                var o = this.updateViews(n);
                r && this.notifyAfterRender(o, n);
            }
        },
        scheduleViewUpdate: function(t, e, i, n) {
            var r = this._updates, o = this.options, a = t.FLAG_REMOVE, s = t.FLAG_INSERT, l = t.UPDATE_PRIORITY, c = t.cid, u = r.priorities[i];
            if (u || (u = r.priorities[i] = {}), l < i) for(var h = i - 1; l <= h; h--){
                var g = r.priorities[h];
                g && c in g && (u[c] |= g[c], delete g[c]);
            }
            var d = u[c] || 0;
            if ((d & e) !== e) {
                d || r.count++, e & a && d & s ? u[c] ^= s : e & s && d & a && (u[c] ^= a), u[c] |= e;
                var f = o.onViewUpdate;
                "function" == typeof f && f.call(this, t, e, i, n || {}, this);
            }
        },
        dumpViewUpdate: function(t) {
            if (!t) return 0;
            var e = this._updates, i = t.cid, n = e.priorities[t.UPDATE_PRIORITY], r = this.registerMountedView(t) | n[i];
            return delete n[i], r;
        },
        dumpView: function(t, e) {
            var i = this.dumpViewUpdate(t);
            return i ? this.updateView(t, i, e) : 0;
        },
        updateView: function(t, e, i) {
            if (!t) return 0;
            var n = t.FLAG_REMOVE, r = t.FLAG_INSERT, o = t.model;
            if (t instanceof Ua) {
                if (e & n) return this.removeView(o), 0;
                e & r && (this.insertView(t), e ^= r);
            }
            return e ? t.confirmUpdate(e, i || {}) : 0;
        },
        requireView: function(t, e) {
            var i = this.findViewByModel(t);
            return i ? (this.dumpView(i, e), i) : null;
        },
        registerUnmountedView: function(t) {
            var e = t.cid, i = this._updates;
            if (e in i.unmounted) return 0;
            var n = i.unmounted[e] |= t.FLAG_INSERT;
            return i.unmountedCids.push(e), delete i.mounted[e], n;
        },
        registerMountedView: function(t) {
            var e = t.cid, i = this._updates;
            if (e in i.mounted) return 0;
            i.mounted[e] = !0, i.mountedCids.push(e);
            var n = i.unmounted[e] || 0;
            return delete i.unmounted[e], n;
        },
        isViewMounted: function(t) {
            return !!t && t.cid in this._updates.mounted;
        },
        dumpViews: function(t) {
            var e = no({}, t, {
                viewport: null
            });
            this.checkViewport(e), this.updateViews(e);
        },
        updateViews: function(t) {
            var e;
            this.notifyBeforeRender(t);
            for(var i = 0, n = 0, r = pl; n++, i += (e = this.updateViewsBatch(t)).updated, r = Math.min(e.priority, r), !e.empty;);
            var o = {
                updated: i,
                batches: n,
                priority: r
            };
            return this.notifyAfterRender(o, t), o;
        },
        hasScheduledUpdates: function() {
            for(var t = this._updates.priorities, e = Object.keys(t), i = e.length; 0 < i && i--;)for(var n in t[e[i]])return !0;
            return !1;
        },
        updateViewsAsync: function(t, e) {
            t || (t = {}), e || (e = {
                processed: 0,
                priority: pl
            });
            var i = this._updates, n = i.id;
            if (n) {
                Or(n), 0 === e.processed && this.hasScheduledUpdates() && this.notifyBeforeRender(t);
                var r = this.updateViewsBatch(t), o = no({}, t, {
                    mountBatchSize: 1e3 - r.mounted,
                    unmountBatchSize: 1e3 - r.unmounted
                }), a = this.checkViewport(o), s = a.unmounted, l = a.mounted, c = e.processed, u = i.count;
                0 < r.updated && (c += r.updated + r.unmounted, r.processed = c, e.priority = Math.min(r.priority, e.priority), r.empty && 0 === l ? (r.unmounted += s, r.mounted += l, r.priority = e.priority, this.notifyAfterRender(r, t), e.processed = 0, e.priority = pl, i.count = 0) : e.processed = c);
                var h = t.progress;
                if (u && "function" == typeof h && h.call(this, r.empty, c, u, r, this), i.id !== n) return;
            }
            i.id = Br(this.updateViewsAsync, this, t, e);
        },
        notifyBeforeRender: function(t) {
            void 0 === t && (t = {});
            var e = t.beforeRender;
            "function" != typeof e && "function" != typeof (e = this.options.beforeRender) || e.call(this, t, this);
        },
        notifyAfterRender: function(t, e) {
            void 0 === e && (e = {});
            var i = e.afterRender;
            "function" != typeof i && (i = this.options.afterRender), "function" == typeof i && i.call(this, t, e, this), this.trigger("render:done", t, e);
        },
        updateViewsBatch: function(t) {
            t || (t = {});
            var e = t.batchSize || 1 / 0, i = this._updates, n = 0, r = 0, o = 0, a = 0, s = pl, l = !0, c = this.options, u = i.priorities, h = "viewport" in t ? t.viewport : c.viewport;
            "function" != typeof h && (h = null);
            var g = c.onViewPostponed;
            "function" != typeof g && (g = null);
            var d = Object.keys(u);
            t: for(var f = 0, p = d.length; f < p; f++){
                var m = +d[f], I = u[m];
                for(var v in I){
                    if (e <= n) {
                        l = !1;
                        break t;
                    }
                    var A = ja[v];
                    if (A) {
                        var C = I[v];
                        if (0 == (C & A.FLAG_REMOVE)) {
                            var y = v in i.unmounted;
                            if (A.DETACHABLE && h && !h.call(this, A, !y, this)) {
                                y || (this.registerUnmountedView(A), A.unmount()), i.unmounted[v] |= C, delete I[v], o++;
                                continue;
                            }
                            y && (C |= A.FLAG_INSERT, a++), C |= this.registerMountedView(A);
                        }
                        var w = this.updateView(A, C, t);
                        0 < w && (I[v] = w, !g || !g.call(this, A, w, this) || I[v]) ? (r++, l = !1) : (m < s && (s = m), n++, delete I[v]);
                    } else delete I[v];
                }
            }
            return {
                priority: s,
                updated: n,
                postponed: r,
                unmounted: o,
                mounted: a,
                empty: l
            };
        },
        getUnmountedViews: function() {
            for(var t = this._updates, e = Object.keys(t.unmounted), i = e.length, n = new Array(i), r = 0; r < i; r++)n[r] = ja[e[r]];
            return n;
        },
        getMountedViews: function() {
            for(var t = this._updates, e = Object.keys(t.mounted), i = e.length, n = new Array(i), r = 0; r < i; r++)n[r] = ja[e[r]];
            return n;
        },
        checkUnmountedViews: function(t, e) {
            e || (e = {});
            var i = 0;
            "function" != typeof t && (t = null);
            for(var n = ("mountBatchSize" in e) ? e.mountBatchSize : 1 / 0, r = this._updates, o = r.unmountedCids, a = r.unmounted, s = 0, l = Math.min(o.length, n); s < l; s++){
                var c = o[s];
                if (c in a) {
                    var u = ja[c];
                    if (u) {
                        if (u.DETACHABLE && t && !t.call(this, u, !1, this)) o.push(c);
                        else {
                            i++;
                            var h = this.registerMountedView(u);
                            h && this.scheduleViewUpdate(u, h, u.UPDATE_PRIORITY, {
                                mounting: !0
                            });
                        }
                    }
                }
            }
            return o.splice(0, s), i;
        },
        checkMountedViews: function(t, e) {
            e || (e = {});
            var i = 0;
            if ("function" != typeof t) return i;
            for(var n = ("unmountBatchSize" in e) ? e.unmountBatchSize : 1 / 0, r = this._updates, o = r.mountedCids, a = r.mounted, s = 0, l = Math.min(o.length, n); s < l; s++){
                var c = o[s];
                if (c in a) {
                    var u = ja[c];
                    if (u) {
                        if (u.DETACHABLE && !t.call(this, u, !0, this)) i++, this.registerUnmountedView(u) && u.unmount();
                        else o.push(c);
                    }
                }
            }
            return o.splice(0, s), i;
        },
        checkViewport: function(t) {
            var e = no({}, t, {
                mountBatchSize: 1 / 0,
                unmountBatchSize: 1 / 0
            }), i = "viewport" in e ? e.viewport : this.options.viewport, n = this.checkMountedViews(i, e);
            if (0 < n) {
                var r = this._updates.unmountedCids;
                e.mountBatchSize = Math.min(r.length - n, e.mountBatchSize);
            }
            return {
                mounted: this.checkUnmountedViews(i, e),
                unmounted: n
            };
        },
        freeze: function(t) {
            t || (t = {});
            var e = this._updates, i = t.key, n = this.options.frozen, r = e.freezeKey;
            if (i && i !== r) {
                if (n && r) return;
                e.freezeKey = i, e.keyFrozen = n;
            }
            this.options.frozen = !0;
            var o = e.id;
            e.id = null, this.isAsync() && o && Or(o);
        },
        unfreeze: function(t) {
            t || (t = {});
            var e = this._updates, i = t.key, n = e.freezeKey;
            i && n && i !== n || (e.freezeKey = null, i && i === n && e.keyFrozen || (this.isAsync() ? (this.freeze(), this.updateViewsAsync(t)) : this.updateViews(t), this.options.frozen = e.keyFrozen = !1, e.sort && (this.sortViews(), e.sort = !1)));
        },
        isAsync: function() {
            return !!this.options.async;
        },
        isFrozen: function() {
            return !!this.options.frozen;
        },
        isExactSorting: function() {
            return this.options.sorting === fl.EXACT;
        },
        onRemove: function() {
            this.freeze(), this.removeLayers(), this.removeViews();
        },
        getComputedSize: function() {
            var t = this.options, e = t.width, i = t.height;
            return Zo(e) || (e = this.el.clientWidth), Zo(i) || (i = this.el.clientHeight), {
                width: e,
                height: i
            };
        },
        setDimensions: function(t, e) {
            var i = this.options, n = i.width, r = i.height, o = void 0 === t ? n : t, a = void 0 === e ? r : e;
            if (n !== o || r !== a) {
                i.width = o, i.height = a, this._setDimensions();
                var s = this.getComputedSize();
                this.trigger("resize", s.width, s.height);
            }
        },
        _setDimensions: function() {
            var t = this.options, e = t.width, i = t.height;
            Zo(e) && (e = Math.round(e)), Zo(i) && (i = Math.round(i)), this.$el.css({
                width: null === e ? "" : e,
                height: null === i ? "" : i
            });
        },
        setOrigin: function(t, e) {
            return this.translate(t || 0, e || 0);
        },
        fitToContent: function(t, e, i, n) {
            n = jo(t) ? t : io({
                gridWidth: t,
                gridHeight: e,
                padding: i
            }, n);
            var r = this.getFitToContentArea(n), o = r.x, a = r.y, s = r.width, l = r.height, c = this.scale(), u = c.sx, h = c.sy;
            return this.setOrigin(-o * u, -a * h), this.setDimensions(s * u, l * h), new In(o, a, s, l);
        },
        getFitToContentArea: function(t) {
            void 0 === t && (t = {});
            var e = t.gridWidth || 1, i = t.gridHeight || 1, n = Xr(t.padding || 0), r = Math.max(t.minWidth || 0, e), o = Math.max(t.minHeight || 0, i), a = t.maxWidth || Number.MAX_VALUE, s = t.maxHeight || Number.MAX_VALUE, l = t.allowNewOrigin, c = "contentArea" in t ? new In(t.contentArea) : this.getContentArea(t), u = this.scale(), h = u.sx, g = u.sy;
            c.x *= h, c.y *= g, c.width *= h, c.height *= g;
            var d = Math.ceil((c.width + c.x) / e), f = Math.ceil((c.height + c.y) / i);
            t.allowNegativeBottomRight || (d = Math.max(d, 1), f = Math.max(f, 1)), d *= e, f *= i;
            var p = 0;
            ("negative" === l && c.x < 0 || "positive" === l && 0 <= c.x || "any" === l) && (p = Math.ceil(-c.x / e) * e, d += p += n.left);
            var m = 0;
            return ("negative" === l && c.y < 0 || "positive" === l && 0 <= c.y || "any" === l) && (m = Math.ceil(-c.y / i) * i, f += m += n.top), d += n.right, f += n.bottom, d = Math.max(d, r), f = Math.max(f, o), d = Math.min(d, a), f = Math.min(f, s), new In(-p / h, -m / g, d / h, f / g);
        },
        scaleContentToFit: function(t) {
            var e, i;
            if (t || (t = {}), "contentArea" in t) {
                var n = t.contentArea;
                e = this.localToPaperRect(n), i = new qi(n);
            } else e = this.getContentBBox(t), i = this.paperToLocalPoint(e);
            if (e.width && e.height) {
                no(t, {
                    padding: 0,
                    preserveAspectRatio: !0,
                    scaleGrid: null,
                    minScale: 0,
                    maxScale: Number.MAX_VALUE
                });
                var r, o = Xr(t.padding), a = t.minScaleX || t.minScale, s = t.maxScaleX || t.maxScale, l = t.minScaleY || t.minScale, c = t.maxScaleY || t.maxScale;
                if (t.fittingBBox) r = t.fittingBBox;
                else {
                    var u = this.translate(), h = this.getComputedSize();
                    r = {
                        x: u.tx,
                        y: u.ty,
                        width: h.width,
                        height: h.height
                    };
                }
                r = new In(r).moveAndExpand({
                    x: o.left,
                    y: o.top,
                    width: -o.left - o.right,
                    height: -o.top - o.bottom
                });
                var g = this.scale(), d = r.width / e.width * g.sx, f = r.height / e.height * g.sy;
                if (t.preserveAspectRatio && (d = f = Math.min(d, f)), t.scaleGrid) {
                    var p = t.scaleGrid;
                    d = p * Math.floor(d / p), f = p * Math.floor(f / p);
                }
                d = Math.min(s, Math.max(a, d)), f = Math.min(c, Math.max(l, f));
                var m = this.options.origin, I = r.x - i.x * d - m.x, v = r.y - i.y * f - m.y;
                this.scale(d, f), this.translate(I, v);
            }
        },
        getContentArea: function(t) {
            return t && t.useModelGeometry ? this.model.getBBox() || new In : wr(this.cells).getBBox();
        },
        getContentBBox: function(t) {
            return this.localToPaperRect(this.getContentArea(t));
        },
        getArea: function() {
            return this.paperToLocalRect(this.getComputedSize());
        },
        getRestrictedArea: function() {
            for(var t = [], e = arguments.length; e--;)t[e] = arguments[e];
            var i = this.options.restrictTranslate;
            return go(i) ? i.apply(this, t) : !0 === i ? this.getArea() : i ? new In(i) : null;
        },
        createViewForModel: function(t) {
            var e, i, n = this.options, r = n.cellViewNamespace, o = t.get("type") + "View", a = kr(r, o, ".");
            return i = t.isLink() ? (e = n.linkView, _s) : (e = n.elementView, Va), new (e.prototype instanceof s.View ? a || e : e.call(this, t) || a || i)({
                model: t,
                interactive: n.interactive,
                labelsLayer: !0 === n.labelsLayer ? Oa.LABELS : n.labelsLayer
            });
        },
        removeView: function(t) {
            var e = t.id, i = this._views, n = this._updates, r = i[e];
            if (r) {
                var o = r.cid, a = n.mounted, s = n.unmounted;
                r.remove(), delete i[e], delete a[o], delete s[o];
            }
            return r;
        },
        renderView: function(t, e) {
            var i, n, r = t.id, o = this._views, a = !0;
            return r in o && ((i = o[r]).model === t ? (n = i.FLAG_INSERT, a = !1) : this.removeView(t)), a && (n = ((i = o[r] = this.createViewForModel(t)).paper = this).registerUnmountedView(i) | i.getFlag(xo(i, "initFlag"))), this.requestViewUpdate(i, n, i.UPDATE_PRIORITY, e), i;
        },
        onImageDragStart: function() {
            return !1;
        },
        resetViews: function(t, e) {
            e || (e = {}), t || (t = []), this._resetUpdates(), this.removeViews(), this.freeze({
                key: "reset"
            });
            for(var i = 0, n = t.length; i < n; i++)this.renderView(t[i], e);
            this.unfreeze({
                key: "reset"
            }), this.sortViews();
        },
        removeViews: function() {
            oo(this._views, "remove"), this._views = {};
        },
        sortViews: function() {
            this.isExactSorting() && (this.isFrozen() ? this._updates.sort = !0 : this.sortViewsExact());
        },
        sortViewsExact: function() {
            var t = S(this.cells).children("[model-id]"), a = this.model.get("cells");
            Vr(t, function(t, e) {
                var i = a.get(t.getAttribute("model-id")), n = a.get(e.getAttribute("model-id")), r = i.attributes.z || 0, o = n.attributes.z || 0;
                return r === o ? 0 : r < o ? -1 : 1;
            });
        },
        insertView: function(t) {
            var e = this.getLayerView(Oa.CELLS), i = t.el, n = t.model;
            switch(this.options.sorting){
                case fl.APPROX:
                    e.insertSortedNode(i, n.get("z"));
                    break;
                case fl.EXACT:
                default:
                    e.insertNode(i);
            }
            t.onMount();
        },
        scale: function(t, e, i, n) {
            if (void 0 === t) return wr.matrixToScale(this.matrix());
            void 0 === e && (e = t), void 0 === i && (n = i = 0);
            var r = this.translate();
            if (i || n || r.tx || r.ty) {
                var o = r.tx - i * (t - 1), a = r.ty - n * (e - 1);
                this.translate(o, a);
            }
            t = Math.max(t || 0, this.MIN_SCALE), e = Math.max(e || 0, this.MIN_SCALE);
            var s = this.matrix();
            return s.a = t, s.d = e, this.matrix(s), this.trigger("scale", t, e, i, n), this;
        },
        rotate: function(t, e, i) {
            if (void 0 === t) return wr.matrixToRotate(this.matrix());
            if (void 0 === e) {
                var n = this.cells.getBBox();
                e = n.width / 2, i = n.height / 2;
            }
            var r = this.matrix().translate(e, i).rotate(t).translate(-e, -i);
            return this.matrix(r), this;
        },
        translate: function(t, e) {
            if (void 0 === t) return wr.matrixToTranslate(this.matrix());
            var i = this.options, n = i.origin, r = i.drawGrid;
            t || (t = 0), e || (e = 0);
            var o = this.matrix();
            if (o.e === t && o.f === e) return this;
            o.e = t, o.f = e, this.matrix(o);
            var a = this.translate(), s = a.tx, l = a.ty;
            return n.x = s, n.y = l, this.trigger("translate", s, l), r && this.drawGrid(), this;
        },
        findView: function(t) {
            var e = Go(t) ? this.cells.querySelector(t) : t instanceof S ? t[0] : t, i = this.findAttribute("model-id", e);
            if (i) return this._views[i];
        },
        findViewByModel: function(t) {
            var e = Go(t) || Zo(t) ? t : t && t.id;
            return this._views[e];
        },
        findViewsFromPoint: function(e) {
            return e = new qi(e), this.model.getElements().map(this.findViewByModel, this).filter(function(t) {
                return t && t.vel.getBBox({
                    target: this.cells
                }).containsPoint(e);
            }, this);
        },
        findViewsInArea: function(e, t) {
            t = no(t || {}, {
                strict: !1
            }), e = new In(e);
            var i = this.model.getElements().map(this.findViewByModel, this), n = t.strict ? "containsRect" : "intersect";
            return i.filter(function(t) {
                return t && e[n](t.vel.getBBox({
                    target: this.cells
                }));
            }, this);
        },
        removeTools: function() {
            return this.dispatchToolsEvent("remove"), this;
        },
        hideTools: function() {
            return this.dispatchToolsEvent("hide"), this;
        },
        showTools: function() {
            return this.dispatchToolsEvent("show"), this;
        },
        dispatchToolsEvent: function(t) {
            for(var e, i = [], n = arguments.length - 1; 0 < n--;)i[n] = arguments[n + 1];
            "string" == typeof t && (e = this).trigger.apply(e, [
                "tools:event",
                t
            ].concat(i));
        },
        getModelById: function(t) {
            return this.model.getCell(t);
        },
        snapToGrid: function(t, e) {
            return this.clientToLocalPoint(t, e).snapToGrid(this.options.gridSize);
        },
        localToPaperPoint: function(t, e) {
            var i = new qi(t, e);
            return wr.transformPoint(i, this.matrix());
        },
        localToPaperRect: function(t, e, i, n) {
            var r = new In(t, e, i, n);
            return wr.transformRect(r, this.matrix());
        },
        paperToLocalPoint: function(t, e) {
            var i = new qi(t, e);
            return wr.transformPoint(i, this.matrix().inverse());
        },
        paperToLocalRect: function(t, e, i, n) {
            var r = new In(t, e, i, n);
            return wr.transformRect(r, this.matrix().inverse());
        },
        localToClientPoint: function(t, e) {
            var i = new qi(t, e);
            return wr.transformPoint(i, this.clientMatrix());
        },
        localToClientRect: function(t, e, i, n) {
            var r = new In(t, e, i, n);
            return wr.transformRect(r, this.clientMatrix());
        },
        clientToLocalPoint: function(t, e) {
            var i = new qi(t, e);
            return wr.transformPoint(i, this.clientMatrix().inverse());
        },
        clientToLocalRect: function(t, e, i, n) {
            var r = new In(t, e, i, n);
            return wr.transformRect(r, this.clientMatrix().inverse());
        },
        localToPagePoint: function(t, e) {
            return this.localToPaperPoint(t, e).offset(this.pageOffset());
        },
        localToPageRect: function(t, e, i, n) {
            return this.localToPaperRect(t, e, i, n).offset(this.pageOffset());
        },
        pageToLocalPoint: function(t, e) {
            var i = new qi(t, e).difference(this.pageOffset());
            return this.paperToLocalPoint(i);
        },
        pageToLocalRect: function(t, e, i, n) {
            var r = this.pageOffset(), o = new In(t, e, i, n);
            return o.x -= r.x, o.y -= r.y, this.paperToLocalRect(o);
        },
        clientOffset: function() {
            var t = this.svg.getBoundingClientRect();
            return new qi(t.left, t.top);
        },
        pageOffset: function() {
            return this.clientOffset().offset(window.scrollX, window.scrollY);
        },
        linkAllowed: function(t) {
            if (!(t instanceof _s)) throw new Error("Must provide a linkView.");
            var e = t.model, i = this.options, n = this.model, r = n.constructor.validations;
            return !(!i.multiLinks && !r.multiLinks.call(this, n, e)) && !(!i.linkPinning && !r.linkPinning.call(this, n, e)) && !("function" == typeof i.allowLink && !i.allowLink.call(this, t, this));
        },
        getDefaultLink: function(t, e) {
            return go(this.options.defaultLink) ? this.options.defaultLink.call(this, t, e) : this.options.defaultLink.clone();
        },
        resolveHighlighter: function(t) {
            void 0 === t && (t = {});
            var e = t.highlighter, i = t.type, n = this.options, r = n.highlighting, o = n.highlighterNamespace;
            if (void 0 === e) {
                if (!r) return !1;
                if (i && !1 === (e = r[i])) return !1;
                e || (e = r.default);
            }
            if (!e) return !1;
            Go(e) && (e = {
                name: e
            });
            var a = e.name, s = o[a];
            if (!s) throw new Error('Unknown highlighter ("' + a + '")');
            if ("function" != typeof s.highlight) throw new Error('Highlighter ("' + a + '") is missing required highlight() method');
            if ("function" != typeof s.unhighlight) throw new Error('Highlighter ("' + a + '") is missing required unhighlight() method');
            return {
                highlighter: s,
                options: e.options || {},
                name: a
            };
        },
        onCellHighlight: function(t, e, i) {
            var n = this.resolveHighlighter(i);
            if (n) {
                var r = n.highlighter, o = n.options;
                r.highlight(t, e, o);
            }
        },
        onCellUnhighlight: function(t, e, i) {
            var n = this.resolveHighlighter(i);
            if (n) {
                var r = n.highlighter, o = n.options;
                r.unhighlight(t, e, o);
            }
        },
        pointerdblclick: function(t) {
            t.preventDefault(), t = Gr(t);
            var e = this.findView(t.target);
            if (!this.guard(t, e)) {
                var i = this.snapToGrid(t.clientX, t.clientY);
                e ? e.pointerdblclick(t, i.x, i.y) : this.trigger("blank:pointerdblclick", t, i.x, i.y);
            }
        },
        pointerclick: function(t) {
            if (this.eventData(t).mousemoved <= this.options.clickThreshold) {
                t = Gr(t);
                var e = this.findView(t.target);
                if (this.guard(t, e)) return;
                var i = this.snapToGrid(t.clientX, t.clientY);
                e ? e.pointerclick(t, i.x, i.y) : this.trigger("blank:pointerclick", t, i.x, i.y);
            }
        },
        contextmenu: function(t) {
            this.options.preventContextMenu && t.preventDefault(), t = Gr(t);
            var e = this.findView(t.target);
            if (!this.guard(t, e)) {
                var i = this.snapToGrid(t.clientX, t.clientY);
                e ? e.contextmenu(t, i.x, i.y) : this.trigger("blank:contextmenu", t, i.x, i.y);
            }
        },
        pointerdown: function(t) {
            t = Gr(t);
            var e = this.findView(t.target);
            if (!this.guard(t, e)) {
                var i = this.snapToGrid(t.clientX, t.clientY);
                e ? (t.preventDefault(), e.pointerdown(t, i.x, i.y)) : (this.options.preventDefaultBlankAction && t.preventDefault(), this.trigger("blank:pointerdown", t, i.x, i.y)), this.delegateDragEvents(e, t.data);
            }
        },
        pointermove: function(t) {
            var e = this.eventData(t);
            if (e.mousemoved || (e.mousemoved = 0), !(++e.mousemoved <= this.options.moveThreshold)) {
                t = Gr(t);
                var i = this.snapToGrid(t.clientX, t.clientY), n = e.sourceView;
                n ? n.pointermove(t, i.x, i.y) : this.trigger("blank:pointermove", t, i.x, i.y), this.eventData(t, e);
            }
        },
        pointerup: function(t) {
            this.undelegateDocumentEvents();
            var e = Gr(t), i = this.snapToGrid(e.clientX, e.clientY), n = this.eventData(t).sourceView;
            n ? n.pointerup(e, i.x, i.y) : this.trigger("blank:pointerup", e, i.x, i.y), e.isPropagationStopped() || this.pointerclick(S.Event(t, {
                type: "click",
                data: t.data
            })), t.stopImmediatePropagation(), this.delegateEvents();
        },
        mouseover: function(t) {
            t = Gr(t);
            var e = this.findView(t.target);
            if (!this.guard(t, e)) {
                if (e) e.mouseover(t);
                else {
                    if (this.el === t.target) return;
                    this.trigger("blank:mouseover", t);
                }
            }
        },
        mouseout: function(t) {
            t = Gr(t);
            var e = this.findView(t.target);
            if (!this.guard(t, e)) {
                if (e) e.mouseout(t);
                else {
                    if (this.el === t.target) return;
                    this.trigger("blank:mouseout", t);
                }
            }
        },
        mouseenter: function(t) {
            var e = (t = Gr(t)).target, i = t.relatedTarget, n = t.currentTarget, r = this.findView(e);
            if (!this.guard(t, r)) {
                var o = this.findView(i);
                if (r) {
                    if (o === r) return;
                    if (r.mouseenter(t), this.el.contains(i)) return;
                }
                o || n === this.el && this.trigger("paper:mouseenter", t);
            }
        },
        mouseleave: function(t) {
            var e = (t = Gr(t)).target, i = t.relatedTarget, n = t.currentTarget, r = this.findView(e);
            if (!this.guard(t, r)) {
                var o = this.findView(i);
                if (r) {
                    if (o === r) return;
                    if (r.mouseleave(t), this.el.contains(i)) return;
                }
                o || n === this.el && this.trigger("paper:mouseleave", t);
            }
        },
        mousewheel: function(t) {
            t = Gr(t);
            var e = this.findView(t.target);
            if (!this.guard(t, e)) {
                var i = t.originalEvent, n = this.snapToGrid(i.clientX, i.clientY), r = Math.max(-1, Math.min(1, i.wheelDelta));
                e ? e.mousewheel(t, n.x, n.y, r) : this.trigger("blank:mousewheel", t, n.x, n.y, r);
            }
        },
        onevent: function(t) {
            var e = t.currentTarget, i = e.getAttribute("event");
            if (i) {
                var n = this.findView(e);
                if (n) {
                    if (t = Gr(t), this.guard(t, n)) return;
                    var r = this.snapToGrid(t.clientX, t.clientY);
                    n.onevent(t, i, r.x, r.y);
                }
            }
        },
        magnetEvent: function(t, e) {
            var i = t.currentTarget;
            if (i.getAttribute("magnet")) {
                var n = this.findView(i);
                if (n) {
                    if (t = Gr(t), this.guard(t, n)) return;
                    var r = this.snapToGrid(t.clientX, t.clientY);
                    e.call(this, n, t, i, r.x, r.y);
                }
            }
        },
        onmagnet: function(t) {
            this.magnetEvent(t, function(t, e, i, n, r) {
                t.onmagnet(e, n, r);
            });
        },
        magnetpointerdblclick: function(t) {
            this.magnetEvent(t, function(t, e, i, n, r) {
                t.magnetpointerdblclick(e, i, n, r);
            });
        },
        magnetcontextmenu: function(t) {
            this.options.preventContextMenu && t.preventDefault(), this.magnetEvent(t, function(t, e, i, n, r) {
                t.magnetcontextmenu(e, i, n, r);
            });
        },
        onlabel: function(t) {
            var e = t.currentTarget, i = this.findView(e);
            if (i) {
                if (t = Gr(t), this.guard(t, i)) return;
                var n = this.snapToGrid(t.clientX, t.clientY);
                i.onlabel(t, n.x, n.y);
            }
        },
        getPointerArgs: function(t) {
            var e = Gr(t), i = this.snapToGrid(e.clientX, e.clientY);
            return [
                e,
                i.x,
                i.y
            ];
        },
        delegateDragEvents: function(t, e) {
            e || (e = {}), this.eventData({
                data: e
            }, {
                sourceView: t || null,
                mousemoved: 0
            }), this.delegateDocumentEvents(null, e), this.undelegateEvents();
        },
        guard: function(t, e) {
            return "mousedown" === t.type && 2 === t.button || !(!this.options.guard || !this.options.guard(t, e)) || (t.data && void 0 !== t.data.guarded ? t.data.guarded : !(e && e.model && e.model instanceof ga) && this.svg !== t.target && this.el !== t.target && !S.contains(this.svg, t.target));
        },
        setGridSize: function(t) {
            return this.options.gridSize = t, this.options.drawGrid && this.drawGrid(), this;
        },
        clearGrid: function() {
            return this.$grid && this.$grid.css("backgroundImage", "none"), this;
        },
        _getGridRefs: function() {
            return this._gridCache || (this._gridCache = {
                root: wr("svg", {
                    width: "100%",
                    height: "100%"
                }, wr("defs")),
                patterns: {},
                add: function(t, e) {
                    wr(this.root.node.childNodes[0]).append(e), this.patterns[t] = e, this.root.append(wr("rect", {
                        width: "100%",
                        height: "100%",
                        fill: "url(#" + t + ")"
                    }));
                },
                get: function(t) {
                    return this.patterns[t];
                },
                exist: function(t) {
                    return void 0 !== this.patterns[t];
                }
            }), this._gridCache;
        },
        setGrid: function(t) {
            return this.clearGrid(), this._gridCache = null, this._gridSettings = [], (Array.isArray(t) ? t : [
                t || {}
            ]).forEach(function(t) {
                this._gridSettings.push.apply(this._gridSettings, this._resolveDrawGridOption(t));
            }, this), this;
        },
        _resolveDrawGridOption: function(t) {
            var e = this.constructor.gridPatterns;
            if (Go(t) && Array.isArray(e[t])) return e[t].map(function(t) {
                return io({}, t);
            });
            var i = t || {
                args: [
                    {}
                ]
            }, n = Array.isArray(i), r = i.name;
            if (n || r || i.markup || (r = "dot"), r && Array.isArray(e[r])) {
                var o = e[r].map(function(t) {
                    return io({}, t);
                }), a = Array.isArray(i.args) ? i.args : [
                    i.args || {}
                ];
                no(a[0], Mo(t, "args"));
                for(var s = 0; s < a.length; s++)o[s] && io(o[s], a[s]);
                return o;
            }
            return n ? i : [
                i
            ];
        },
        drawGrid: function(t) {
            var s = this.options.gridSize;
            if (s <= 1) return this.clearGrid();
            var l = Array.isArray(t) ? t : [
                t
            ], c = this.matrix(), u = this._getGridRefs();
            this._gridSettings.forEach(function(t, e) {
                var i = "pattern_" + e, n = zo(t, l[e], {
                    sx: c.a || 1,
                    sy: c.d || 1,
                    ox: c.e || 0,
                    oy: c.f || 0
                });
                n.width = s * (c.a || 1) * (n.scaleFactor || 1), n.height = s * (c.d || 1) * (n.scaleFactor || 1), u.exist(i) || u.add(i, wr("pattern", {
                    id: i,
                    patternUnits: "userSpaceOnUse"
                }, wr(n.markup)));
                var r = u.get(i);
                go(n.update) && n.update(r.node.childNodes[0], n);
                var o = n.ox % n.width;
                o < 0 && (o += n.width);
                var a = n.oy % n.height;
                a < 0 && (a += n.height), r.attr({
                    x: o,
                    y: a,
                    width: n.width,
                    height: n.height
                });
            });
            var e = (new XMLSerializer).serializeToString(u.root.node);
            return e = "url(data:image/svg+xml;base64," + btoa(e) + ")", this.$grid.css("backgroundImage", e), this;
        },
        updateBackgroundImage: function(t) {
            var e = (t = t || {}).position || "center", i = t.size || "auto auto", n = this.scale(), r = this.translate();
            jo(e) && (e = r.tx + n.sx * (e.x || 0) + "px " + (r.ty + n.sy * (e.y || 0)) + "px");
            jo(i) && (i = (i = new In(i).scale(n.sx, n.sy)).width + "px " + i.height + "px"), this.$background.css({
                backgroundSize: i,
                backgroundPosition: e
            });
        },
        drawBackgroundImage: function(t, e) {
            if (t instanceof HTMLImageElement) {
                if (this._background && this._background.id === e.id) {
                    var i, n = (e = e || {}).size, r = e.repeat || "no-repeat", o = e.opacity || 1, a = Math.abs(e.quality) || 1, s = this.constructor.backgroundPatterns[To(r)];
                    if (go(s)) {
                        t.width *= a, t.height *= a;
                        var l = s(t, e);
                        if (!(l instanceof HTMLCanvasElement)) throw new Error("dia.Paper: background pattern must return an HTML Canvas instance");
                        i = l.toDataURL("image/png"), r = "repeat", jo(n) ? (n.width *= l.width / t.width, n.height *= l.height / t.height) : void 0 === n && (e.size = {
                            width: l.width / a,
                            height: l.height / a
                        });
                    } else i = t.src, void 0 === n && (e.size = {
                        width: t.width,
                        height: t.height
                    });
                    this.$background.css({
                        opacity: o,
                        backgroundRepeat: r,
                        backgroundImage: "url(" + i + ")"
                    }), this.updateBackgroundImage(e);
                }
            } else this.$background.css("backgroundImage", "");
        },
        updateBackgroundColor: function(t) {
            this.$el.css("backgroundColor", t || "");
        },
        drawBackground: function(t) {
            if (t = t || {}, this.updateBackgroundColor(t.color), t.image) {
                t = this._background = co(t), jr(t);
                var e = document.createElement("img");
                e.onload = this.drawBackgroundImage.bind(this, e, t), e.src = t.image;
            } else this.drawBackgroundImage(null), this._background = null;
            return this;
        },
        setInteractivity: function(t) {
            this.options.interactive = t, oo(this._views, "setInteractivity", t);
        },
        isDefined: function(t) {
            return !!this.svg.getElementById(t);
        },
        defineFilter: function(t) {
            if (!jo(t)) throw new TypeError("dia.Paper: defineFilter() requires 1. argument to be an object.");
            var e = t.id, i = t.name;
            if (e || (e = i + this.svg.id + Sr(JSON.stringify(t))), !this.isDefined(e)) {
                var n = _r, r = n[i] && n[i](t.args || {});
                if (!r) throw new Error("Non-existing filter " + i);
                var o = io({
                    filterUnits: "objectBoundingBox",
                    x: -1,
                    y: -1,
                    width: 3,
                    height: 3
                }, t.attrs, {
                    id: e
                });
                wr(r, o).appendTo(this.defs);
            }
            return e;
        },
        defineGradient: function(t) {
            if (!jo(t)) throw new TypeError("dia.Paper: defineGradient() requires 1. argument to be an object.");
            var e = this.svg, i = this.defs, n = t.type, r = t.id;
            void 0 === r && (r = n + e.id + Sr(JSON.stringify(t)));
            var o = t.stops, a = t.attrs;
            if (void 0 === a && (a = {}), this.isDefined(r)) return r;
            var s = po(o).map(function(t) {
                var e = t.offset, i = t.color, n = t.opacity;
                return wr("stop").attr({
                    offset: e,
                    "stop-color": i,
                    "stop-opacity": Number.isFinite(n) ? n : 1
                });
            }), l = wr(n, a, s);
            return l.id = r, l.appendTo(i), r;
        },
        definePattern: function(t) {
            if (!jo(t)) throw new TypeError("dia.Paper: definePattern() requires 1. argument to be an object.");
            var e = this.svg, i = this.defs, n = t.id;
            void 0 === n && (n = e.id + Sr(JSON.stringify(t)));
            var r = t.markup, o = t.attrs;
            if (void 0 === o && (o = {}), !r) throw new TypeError("dia.Paper: definePattern() requires markup.");
            if (this.isDefined(n)) return n;
            var a = wr("pattern", {
                patternUnits: "userSpaceOnUse"
            });
            if (a.id = n, a.attr(o), "string" == typeof r) a.append(wr(r));
            else {
                var s = Mr(r).fragment;
                a.append(s);
            }
            return a.appendTo(i), n;
        },
        defineMarker: function(t) {
            if (!jo(t)) throw new TypeError("dia.Paper: defineMarker() requires 1. argument to be an object.");
            var e = this.svg, i = this.defs, n = t.id;
            void 0 === n && (n = e.id + Sr(JSON.stringify(t)));
            var r = t.markup, o = t.attrs;
            void 0 === o && (o = {});
            var a = t.markerUnits;
            if (void 0 === a && (a = "userSpaceOnUse"), this.isDefined(n)) return n;
            var s = wr("marker", {
                orient: "auto",
                overflow: "visible",
                markerUnits: a
            });
            if (s.id = n, s.attr(o), r) {
                if ("string" == typeof r) s.append(wr(r));
                else {
                    var l = Mr(r).fragment;
                    s.append(l);
                }
            } else {
                var c = t.type;
                void 0 === c && (c = "path");
                var u = wr(c, Mo(t, "type", "id", "markup", "attrs", "markerUnits"));
                s.append(u);
            }
            return s.appendTo(i), n;
        }
    }, {
        sorting: fl,
        Layers: Oa,
        backgroundPatterns: {
            flipXy: function(t) {
                var e = document.createElement("canvas"), i = t.width, n = t.height;
                e.width = 2 * i, e.height = 2 * n;
                var r = e.getContext("2d");
                return r.drawImage(t, 0, 0, i, n), r.setTransform(-1, 0, 0, -1, e.width, e.height), r.drawImage(t, 0, 0, i, n), r.setTransform(-1, 0, 0, 1, e.width, 0), r.drawImage(t, 0, 0, i, n), r.setTransform(1, 0, 0, -1, 0, e.height), r.drawImage(t, 0, 0, i, n), e;
            },
            flipX: function(t) {
                var e = document.createElement("canvas"), i = t.width, n = t.height;
                e.width = 2 * i, e.height = n;
                var r = e.getContext("2d");
                return r.drawImage(t, 0, 0, i, n), r.translate(2 * i, 0), r.scale(-1, 1), r.drawImage(t, 0, 0, i, n), e;
            },
            flipY: function(t) {
                var e = document.createElement("canvas"), i = t.width, n = t.height;
                e.width = i, e.height = 2 * n;
                var r = e.getContext("2d");
                return r.drawImage(t, 0, 0, i, n), r.translate(0, 2 * n), r.scale(1, -1), r.drawImage(t, 0, 0, i, n), e;
            },
            watermark: function(t, e) {
                e = e || {};
                var i = t.width, n = t.height, r = document.createElement("canvas");
                r.width = 3 * i, r.height = 3 * n;
                for(var o = r.getContext("2d"), a = Zo(e.watermarkAngle) ? -e.watermarkAngle : -20, s = Pi(a), l = r.width / 4, c = r.height / 4, u = 0; u < 4; u++)for(var h = 0; h < 4; h++)0 < (u + h) % 2 && (o.setTransform(1, 0, 0, 1, (2 * u - 1) * l, (2 * h - 1) * c), o.rotate(s), o.drawImage(t, -i / 2, -n / 2, i, n));
                return r;
            }
        },
        gridPatterns: {
            dot: [
                {
                    color: "#AAAAAA",
                    thickness: 1,
                    markup: "rect",
                    update: function(t, e) {
                        wr(t).attr({
                            width: e.thickness * e.sx,
                            height: e.thickness * e.sy,
                            fill: e.color
                        });
                    }
                }
            ],
            fixedDot: [
                {
                    color: "#AAAAAA",
                    thickness: 1,
                    markup: "rect",
                    update: function(t, e) {
                        var i = e.sx <= 1 ? e.thickness * e.sx : e.thickness;
                        wr(t).attr({
                            width: i,
                            height: i,
                            fill: e.color
                        });
                    }
                }
            ],
            mesh: [
                {
                    color: "#AAAAAA",
                    thickness: 1,
                    markup: "path",
                    update: function(t, e) {
                        var i, n = e.width, r = e.height, o = e.thickness;
                        i = 0 <= n - o && 0 <= r - o ? [
                            "M",
                            n,
                            0,
                            "H0 M0 0 V0",
                            r
                        ].join(" ") : "M 0 0 0 0", wr(t).attr({
                            d: i,
                            stroke: e.color,
                            "stroke-width": e.thickness
                        });
                    }
                }
            ],
            doubleMesh: [
                {
                    color: "#AAAAAA",
                    thickness: 1,
                    markup: "path",
                    update: function(t, e) {
                        var i, n = e.width, r = e.height, o = e.thickness;
                        i = 0 <= n - o && 0 <= r - o ? [
                            "M",
                            n,
                            0,
                            "H0 M0 0 V0",
                            r
                        ].join(" ") : "M 0 0 0 0", wr(t).attr({
                            d: i,
                            stroke: e.color,
                            "stroke-width": e.thickness
                        });
                    }
                },
                {
                    color: "#000000",
                    thickness: 3,
                    scaleFactor: 4,
                    markup: "path",
                    update: function(t, e) {
                        var i, n = e.width, r = e.height, o = e.thickness;
                        i = 0 <= n - o && 0 <= r - o ? [
                            "M",
                            n,
                            0,
                            "H0 M0 0 V0",
                            r
                        ].join(" ") : "M 0 0 0 0", wr(t).attr({
                            d: i,
                            stroke: e.color,
                            "stroke-width": e.thickness
                        });
                    }
                }
            ]
        }
    }), Cl = Za.extend({
        name: null,
        tagName: "g",
        className: "tool",
        svgElement: !0,
        _visible: !0,
        init: function() {
            var t = this.name;
            t && this.vel.attr("data-tool-name", t);
        },
        configure: function(t, e) {
            return this.relatedView = t, this.paper = t.paper, this.parentView = e, this.simulateRelatedView(this.el), this.delegateEvents(), this;
        },
        simulateRelatedView: function(t) {
            t && t.setAttribute("model-id", this.relatedView.model.id);
        },
        getName: function() {
            return this.name;
        },
        show: function() {
            this.el.style.display = "", this._visible = !0;
        },
        hide: function() {
            this.el.style.display = "none", this._visible = !1;
        },
        isVisible: function() {
            return !!this._visible;
        },
        focus: function() {
            var t = this.options.focusOpacity;
            isFinite(t) && (this.el.style.opacity = t), this.parentView.focusTool(this);
        },
        blur: function() {
            this.el.style.opacity = "", this.parentView.blurTool(this);
        },
        update: function() {},
        guard: function(t) {
            var e = this.paper, i = this.relatedView;
            return !e || !i || e.guard(t, i);
        }
    }), yl = Za.extend({
        tagName: "g",
        className: "tools",
        svgElement: !0,
        tools: null,
        isRendered: !1,
        options: {
            tools: null,
            relatedView: null,
            name: null
        },
        configure: function(t) {
            var e = (t = io(this.options, t)).tools;
            if (!Array.isArray(e)) return this;
            var i = t.relatedView;
            if (!(i instanceof Ua)) return this;
            for(var n = this.tools = [], r = 0, o = e.length; r < o; r++){
                var a = e[r];
                a instanceof Cl && (a.configure(i, this), this.vel.append(a.el), n.push(a));
            }
            return this.isRendered = !1, i.requestUpdate(i.getFlag("TOOLS")), this;
        },
        getName: function() {
            return this.options.name;
        },
        update: function(t) {
            t || (t = {});
            var e = this.tools;
            if (!e) return this;
            for(var i = this.isRendered, n = 0, r = e.length; n < r; n++){
                var o = e[n];
                i ? t.tool !== o.cid && o.isVisible() && o.update() : o.render();
            }
            return i || (this.mount(), this.blurTool(), this.isRendered = !0), this;
        },
        focusTool: function(t) {
            var e = this.tools;
            if (!e) return this;
            for(var i = 0, n = e.length; i < n; i++){
                var r = e[i];
                t === r ? r.show() : r.hide();
            }
            return this;
        },
        blurTool: function(t) {
            var e = this.tools;
            if (!e) return this;
            for(var i = 0, n = e.length; i < n; i++){
                var r = e[i];
                r === t || r.isVisible() || (r.show(), r.update());
            }
            return this;
        },
        hide: function() {
            return this.focusTool(null);
        },
        show: function() {
            return this.blurTool(null);
        },
        onRemove: function() {
            var t = this.tools;
            if (!t) return this;
            for(var e = 0, i = t.length; e < i; e++)t[e].remove();
            this.tools = null;
        },
        mount: function() {
            var t = this.options, e = this.el, i = t.relatedView, n = t.layer;
            void 0 === n && (n = Oa.TOOLS);
            var r = t.z;
            return i && (n ? i.paper.getLayerView(n).insertSortedNode(e, r) : i.el.appendChild(e)), this;
        }
    }), wl = {
        Graph: Pa,
        attributes: ha,
        LayersNames: Oa,
        PaperLayer: Ea,
        Cell: ga,
        CellView: Ua,
        Element: La,
        ElementView: Va,
        Link: Sa,
        LinkView: _s,
        Paper: Al,
        ToolView: Cl,
        ToolsView: yl,
        HighlighterView: Ya
    }, bl = {
        exportElement: function(t) {
            return t.size();
        },
        exportLink: function(t) {
            var e = t.get("labelSize") || {};
            return {
                minLen: t.get("minLen") || 1,
                weight: t.get("weight") || 1,
                labelpos: t.get("labelPosition") || "c",
                labeloffset: t.get("labelOffset") || 0,
                width: e.width || 0,
                height: e.height || 0
            };
        },
        importElement: function(t, e, i) {
            var n = this.getCell(e), r = i.node(e);
            t.setPosition ? t.setPosition(n, r) : n.set("position", {
                x: r.x - r.width / 2,
                y: r.y - r.height / 2
            });
        },
        importLink: function(t, e, i) {
            var n = this.getCell(e.name), r = i.edge(e), o = r.points || [], a = new wn(o);
            if (t.setVertices || t.setLinkVertices) {
                if (go(t.setVertices)) t.setVertices(n, o);
                else {
                    a.simplify({
                        threshold: .001
                    });
                    var s = a.points.map(function(t) {
                        return t.toJSON();
                    }), l = s.length;
                    n.set("vertices", s.slice(1, l - 1));
                }
            }
            if (t.setLabels && "x" in r && "y" in r) {
                var c = {
                    x: r.x,
                    y: r.y
                };
                if (go(t.setLabels)) t.setLabels(n, c, o);
                else {
                    var u = a.closestPointLength(c), h = a.pointAtLength(u), g = u / a.length(), d = new qi(c).difference(h).toJSON();
                    n.label(0, {
                        position: {
                            distance: g,
                            offset: d
                        }
                    });
                }
            }
        },
        layout: function(t, e) {
            var i;
            i = t instanceof Pa ? t : (new Pa).resetCells(t, {
                dry: !0,
                sort: !1
            });
            var n = (e = no(e || {}, {
                resizeClusters: (t = null, true),
                clusterPadding: 10,
                exportElement: this.exportElement,
                exportLink: this.exportLink
            })).dagre || ("undefined" != typeof dagre ? dagre : void 0);
            if (void 0 === n) throw new Error('The the "dagre" utility is a mandatory dependency.');
            var r = bl.toGraphLib(i, {
                graphlib: e.graphlib,
                directed: !0,
                multigraph: !0,
                compound: !0,
                setNodeLabel: e.exportElement,
                setEdgeLabel: e.exportLink,
                setEdgeName: function(t) {
                    return t.id;
                }
            }), o = {}, a = e.marginX || 0, s = e.marginY || 0;
            if (e.rankDir && (o.rankdir = e.rankDir), e.align && (o.align = e.align), e.nodeSep && (o.nodesep = e.nodeSep), e.edgeSep && (o.edgesep = e.edgeSep), e.rankSep && (o.ranksep = e.rankSep), e.ranker && (o.ranker = e.ranker), a && (o.marginx = a), s && (o.marginy = s), r.setGraph(o), n.layout(r, {
                debugTiming: !!e.debugTiming
            }), i.startBatch("layout"), bl.fromGraphLib(r, {
                importNode: this.importElement.bind(i, e),
                importEdge: this.importLink.bind(i, e)
            }), e.resizeClusters) {
                var l = r.nodes().filter(function(t) {
                    return 0 < r.children(t).length;
                }).map(i.getCell.bind(i)).sort(function(t, e) {
                    return e.getAncestors().length - t.getAncestors().length;
                });
                oo(l, "fitEmbeds", {
                    padding: e.clusterPadding
                });
            }
            i.stopBatch("layout");
            var c = r.graph();
            return new In(a, s, Math.abs(c.width - 2 * a), Math.abs(c.height - 2 * s));
        },
        fromGraphLib: function(e, i) {
            var n = (i = i || {}).importNode || Bo, r = i.importEdge || Bo, o = this instanceof Pa ? this : new Pa;
            return e.nodes().forEach(function(t) {
                n.call(o, t, e, o, i);
            }), e.edges().forEach(function(t) {
                r.call(o, t, e, o, i);
            }), o;
        },
        toGraphLib: function(t, e) {
            var i = (e = e || {}).graphlib || ("undefined" != typeof graphlib ? graphlib : void 0);
            if (void 0 === i) throw new Error('The the "graphlib" utility is a mandatory dependency.');
            for(var n = So(e, "directed", "compound", "multigraph"), r = new i.Graph(n), o = e.setNodeLabel || Bo, a = e.setEdgeLabel || Bo, s = e.setEdgeName || Bo, l = t.get("cells"), c = 0, u = l.length; c < u; c++){
                var h = l.at(c);
                if (h.isLink()) {
                    var g = h.get("source"), d = h.get("target");
                    if (!g.id || !d.id) break;
                    r.setEdge(g.id, d.id, a(h), s(h));
                } else if (r.setNode(h.id, o(h)), r.isCompound() && h.has("parent")) {
                    var f = h.get("parent");
                    l.has(f) && r.setParent(h.id, f);
                }
            }
            return r;
        }
    };
    Pa.prototype.toGraphLib = function(t) {
        return bl.toGraphLib(this, t);
    }, Pa.prototype.fromGraphLib = function(t, e) {
        return bl.fromGraphLib.call(this, t, e);
    };
    var Nl = {
        _results: {},
        _tests: {
            svgforeignobject: function() {
                return !!document.createElementNS && /SVGForeignObject/.test(({}).toString.call(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")));
            }
        },
        addTest: function(t, e) {
            return this._tests[t] = e;
        },
        test: function(t) {
            var e = this._tests[t];
            if (!e) throw new Error('Test not defined ("' + t + '"). Use `joint.env.addTest(name, fn) to add a new test.`');
            var i = this._results[t];
            if (void 0 !== i) return i;
            try {
                i = e();
            } catch (t1) {
                i = !1;
            }
            return this._results[t] = i;
        }
    }, xl = La.define("basic.Generic", {
        attrs: {
            ".": {
                fill: "#ffffff",
                stroke: "none"
            }
        }
    }), Ml = xl.define("basic.Rect", {
        attrs: {
            rect: {
                fill: "#ffffff",
                stroke: "#000000",
                width: 100,
                height: 60
            },
            text: {
                fill: "#000000",
                text: "",
                "font-size": 14,
                "ref-x": .5,
                "ref-y": .5,
                "text-anchor": "middle",
                "y-alignment": "middle",
                "font-family": "Arial, helvetica, sans-serif"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><rect/></g><text/></g>'
    }), Sl = Va.extend({
        presentationAttributes: Va.addPresentationAttributes({
            attrs: [
                "SCALE"
            ]
        }),
        confirmUpdate: function() {
            var t = Va.prototype.confirmUpdate.apply(this, arguments);
            return this.hasFlag(t, "SCALE") && (this.resize(), t = this.removeFlag(t, "SCALE")), t;
        }
    }), kl = xl.define("basic.Text", {
        attrs: {
            text: {
                "font-size": 18,
                fill: "#000000"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><text/></g></g>'
    }), Dl = xl.define("basic.Circle", {
        size: {
            width: 60,
            height: 60
        },
        attrs: {
            circle: {
                fill: "#ffffff",
                stroke: "#000000",
                r: 30,
                cx: 30,
                cy: 30
            },
            text: {
                "font-size": 14,
                text: "",
                "text-anchor": "middle",
                "ref-x": .5,
                "ref-y": .5,
                "y-alignment": "middle",
                fill: "#000000",
                "font-family": "Arial, helvetica, sans-serif"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><circle/></g><text/></g>'
    }), Tl = xl.define("basic.Ellipse", {
        size: {
            width: 60,
            height: 40
        },
        attrs: {
            ellipse: {
                fill: "#ffffff",
                stroke: "#000000",
                rx: 30,
                ry: 20,
                cx: 30,
                cy: 20
            },
            text: {
                "font-size": 14,
                text: "",
                "text-anchor": "middle",
                "ref-x": .5,
                "ref-y": .5,
                "y-alignment": "middle",
                fill: "#000000",
                "font-family": "Arial, helvetica, sans-serif"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><ellipse/></g><text/></g>'
    }), Ll = xl.define("basic.Polygon", {
        size: {
            width: 60,
            height: 40
        },
        attrs: {
            polygon: {
                fill: "#ffffff",
                stroke: "#000000"
            },
            text: {
                "font-size": 14,
                text: "",
                "text-anchor": "middle",
                "ref-x": .5,
                "ref-dy": 20,
                "y-alignment": "middle",
                fill: "#000000",
                "font-family": "Arial, helvetica, sans-serif"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><polygon/></g><text/></g>'
    }), zl = xl.define("basic.Polyline", {
        size: {
            width: 60,
            height: 40
        },
        attrs: {
            polyline: {
                fill: "#ffffff",
                stroke: "#000000"
            },
            text: {
                "font-size": 14,
                text: "",
                "text-anchor": "middle",
                "ref-x": .5,
                "ref-dy": 20,
                "y-alignment": "middle",
                fill: "#000000",
                "font-family": "Arial, helvetica, sans-serif"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><polyline/></g><text/></g>'
    }), Pl = xl.define("basic.Image", {
        attrs: {
            text: {
                "font-size": 14,
                text: "",
                "text-anchor": "middle",
                "ref-x": .5,
                "ref-dy": 20,
                "y-alignment": "middle",
                fill: "#000000",
                "font-family": "Arial, helvetica, sans-serif"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><image/></g><text/></g>'
    }), jl = xl.define("basic.Path", {
        size: {
            width: 60,
            height: 60
        },
        attrs: {
            path: {
                fill: "#ffffff",
                stroke: "#000000"
            },
            text: {
                "font-size": 14,
                text: "",
                "text-anchor": "middle",
                ref: "path",
                "ref-x": .5,
                "ref-dy": 10,
                fill: "#000000",
                "font-family": "Arial, helvetica, sans-serif"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><path/></g><text/></g>'
    }), Zl = jl.define("basic.Rhombus", {
        attrs: {
            path: {
                d: "M 30 0 L 60 30 30 60 0 30 z"
            },
            text: {
                "ref-y": .5,
                "ref-dy": null,
                "y-alignment": "middle"
            }
        }
    }), Gl = Nl.test("svgforeignobject"), Bl = xl.define("basic.TextBlock", {
        attrs: {
            rect: {
                fill: "#ffffff",
                stroke: "#000000",
                width: 80,
                height: 100
            },
            text: {
                fill: "#000000",
                "font-size": 14,
                "font-family": "Arial, helvetica, sans-serif"
            },
            ".content": {
                text: "",
                "ref-x": .5,
                "ref-y": .5,
                "y-alignment": "middle",
                "x-alignment": "middle"
            }
        },
        content: ""
    }, {
        markup: [
            '<g class="rotatable">',
            '<g class="scalable"><rect/></g>',
            Gl ? '<foreignObject class="fobj"><body xmlns="http://www.w3.org/1999/xhtml"><div class="content"/></body></foreignObject>' : '<text class="content"/>',
            "</g>"
        ].join(""),
        initialize: function() {
            this.listenTo(this, "change:size", this.updateSize), this.listenTo(this, "change:content", this.updateContent), this.updateSize(this, this.get("size")), this.updateContent(this, this.get("content")), xl.prototype.initialize.apply(this, arguments);
        },
        updateSize: function(t, e) {
            this.attr({
                ".fobj": io({}, e),
                div: {
                    style: io({}, e)
                }
            });
        },
        updateContent: function(t, e) {
            Gl ? this.attr({
                ".content": {
                    html: Wr(e)
                }
            }) : this.attr({
                ".content": {
                    text: e
                }
            });
        },
        setForeignObjectSize: function() {
            this.updateSize.apply(this, arguments);
        },
        setDivContent: function() {
            this.updateContent.apply(this, arguments);
        }
    }), Ol = Va.extend({
        presentationAttributes: Gl ? Va.prototype.presentationAttributes : Va.addPresentationAttributes({
            content: [
                "CONTENT"
            ],
            size: [
                "CONTENT"
            ]
        }),
        initFlag: [
            "RENDER",
            "CONTENT"
        ],
        confirmUpdate: function() {
            var t = Va.prototype.confirmUpdate.apply(this, arguments);
            return this.hasFlag(t, "CONTENT") && (this.updateContent(this.model), t = this.removeFlag(t, "CONTENT")), t;
        },
        update: function(t, e) {
            var i = this.model;
            if (Gl) Va.prototype.update.call(this, i, e);
            else {
                var n = Mo(e || i.get("attrs"), ".content");
                Va.prototype.update.call(this, i, n), e && !No(e, ".content") || this.updateContent(i, e);
            }
        },
        updateContent: function(t, e) {
            var i = zo({}, (e || t.get("attrs"))[".content"]);
            i = Mo(i, "text");
            var n = Yr(t.get("content"), t.get("size"), i, {
                svgDocument: this.paper.svg
            }), r = Tr({}, ".content", i, "/");
            r[".content"].text = n, Va.prototype.update.call(this, t, r);
        }
    }), El = {
        Generic: xl,
        Rect: Ml,
        TextView: Sl,
        Text: kl,
        Circle: Dl,
        Ellipse: Tl,
        Polygon: Ll,
        Polyline: zl,
        Image: Pl,
        Path: jl,
        Rhombus: Zl,
        TextBlock: Bl,
        TextBlockView: Ol
    }, Rl = La.define("standard.Rectangle", {
        attrs: {
            body: {
                refWidth: "100%",
                refHeight: "100%",
                strokeWidth: 2,
                stroke: "#000000",
                fill: "#FFFFFF"
            },
            label: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "50%",
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "rect",
                selector: "body"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Yl = La.define("standard.Circle", {
        attrs: {
            body: {
                refCx: "50%",
                refCy: "50%",
                refR: "50%",
                strokeWidth: 2,
                stroke: "#333333",
                fill: "#FFFFFF"
            },
            label: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "50%",
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "circle",
                selector: "body"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Wl = La.define("standard.Ellipse", {
        attrs: {
            body: {
                refCx: "50%",
                refCy: "50%",
                refRx: "50%",
                refRy: "50%",
                strokeWidth: 2,
                stroke: "#333333",
                fill: "#FFFFFF"
            },
            label: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "50%",
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "ellipse",
                selector: "body"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Ul = La.define("standard.Path", {
        attrs: {
            body: {
                refD: "M 0 0 L 10 0 10 10 0 10 Z",
                strokeWidth: 2,
                stroke: "#333333",
                fill: "#FFFFFF"
            },
            label: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "50%",
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "path",
                selector: "body"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Fl = La.define("standard.Polygon", {
        attrs: {
            body: {
                refPoints: "0 0 10 0 10 10 0 10",
                strokeWidth: 2,
                stroke: "#333333",
                fill: "#FFFFFF"
            },
            label: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "50%",
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "polygon",
                selector: "body"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Vl = La.define("standard.Polyline", {
        attrs: {
            body: {
                refPoints: "0 0 10 0 10 10 0 10 0 0",
                strokeWidth: 2,
                stroke: "#333333",
                fill: "#FFFFFF"
            },
            label: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "50%",
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "polyline",
                selector: "body"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Xl = La.define("standard.Image", {
        attrs: {
            image: {
                refWidth: "100%",
                refHeight: "100%"
            },
            label: {
                textVerticalAnchor: "top",
                textAnchor: "middle",
                refX: "50%",
                refY: "100%",
                refY2: 10,
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "image",
                selector: "image"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Hl = La.define("standard.BorderedImage", {
        attrs: {
            border: {
                refWidth: "100%",
                refHeight: "100%",
                stroke: "#333333",
                strokeWidth: 2
            },
            background: {
                refWidth: -1,
                refHeight: -1,
                x: .5,
                y: .5,
                fill: "#FFFFFF"
            },
            image: {
                refWidth: -1,
                refHeight: -1,
                x: .5,
                y: .5
            },
            label: {
                textVerticalAnchor: "top",
                textAnchor: "middle",
                refX: "50%",
                refY: "100%",
                refY2: 10,
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "rect",
                selector: "background",
                attributes: {
                    stroke: "none"
                }
            },
            {
                tagName: "image",
                selector: "image"
            },
            {
                tagName: "rect",
                selector: "border",
                attributes: {
                    fill: "none"
                }
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Jl = La.define("standard.EmbeddedImage", {
        attrs: {
            body: {
                refWidth: "100%",
                refHeight: "100%",
                stroke: "#333333",
                fill: "#FFFFFF",
                strokeWidth: 2
            },
            image: {
                refWidth: "30%",
                refHeight: -20,
                x: 10,
                y: 10,
                preserveAspectRatio: "xMidYMin"
            },
            label: {
                textVerticalAnchor: "top",
                textAnchor: "left",
                refX: "30%",
                refX2: 20,
                refY: 10,
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "rect",
                selector: "body"
            },
            {
                tagName: "image",
                selector: "image"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), _l = La.define("standard.InscribedImage", {
        attrs: {
            border: {
                refRx: "50%",
                refRy: "50%",
                refCx: "50%",
                refCy: "50%",
                stroke: "#333333",
                strokeWidth: 2
            },
            background: {
                refRx: "50%",
                refRy: "50%",
                refCx: "50%",
                refCy: "50%",
                fill: "#FFFFFF"
            },
            image: {
                refWidth: "68%",
                refHeight: "68%",
                refX: "16%",
                refY: "16%",
                preserveAspectRatio: "xMidYMid"
            },
            label: {
                textVerticalAnchor: "top",
                textAnchor: "middle",
                refX: "50%",
                refY: "100%",
                refY2: 10,
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "ellipse",
                selector: "background"
            },
            {
                tagName: "image",
                selector: "image"
            },
            {
                tagName: "ellipse",
                selector: "border",
                attributes: {
                    fill: "none"
                }
            },
            {
                tagName: "text",
                selector: "label"
            }
        ]
    }), Ql = La.define("standard.HeaderedRectangle", {
        attrs: {
            body: {
                refWidth: "100%",
                refHeight: "100%",
                strokeWidth: 2,
                stroke: "#000000",
                fill: "#FFFFFF"
            },
            header: {
                refWidth: "100%",
                height: 30,
                strokeWidth: 2,
                stroke: "#000000",
                fill: "#FFFFFF"
            },
            headerText: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: 15,
                fontSize: 16,
                fill: "#333333"
            },
            bodyText: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "50%",
                refY2: 15,
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "rect",
                selector: "body"
            },
            {
                tagName: "rect",
                selector: "header"
            },
            {
                tagName: "text",
                selector: "headerText"
            },
            {
                tagName: "text",
                selector: "bodyText"
            }
        ]
    }), Kl = La.define("standard.Cylinder", {
        attrs: {
            body: {
                lateralArea: 10,
                fill: "#FFFFFF",
                stroke: "#333333",
                strokeWidth: 2
            },
            top: {
                refCx: "50%",
                cy: 10,
                refRx: "50%",
                ry: 10,
                fill: "#FFFFFF",
                stroke: "#333333",
                strokeWidth: 2
            },
            label: {
                textVerticalAnchor: "middle",
                textAnchor: "middle",
                refX: "50%",
                refY: "100%",
                refY2: 15,
                fontSize: 14,
                fill: "#333333"
            }
        }
    }, {
        markup: [
            {
                tagName: "path",
                selector: "body"
            },
            {
                tagName: "ellipse",
                selector: "top"
            },
            {
                tagName: "text",
                selector: "label"
            }
        ],
        topRy: function(t, e) {
            if (void 0 === t) return this.attr("body/lateralArea");
            var i = {
                lateralArea: t
            }, n = Er(t) ? {
                refCy: t,
                refRy: t,
                cy: null,
                ry: null
            } : {
                refCy: null,
                refRy: null,
                cy: t,
                ry: t
            };
            return this.attr({
                body: i,
                top: n
            }, e);
        }
    }, {
        attributes: {
            lateralArea: {
                set: function(t, e) {
                    var i = Er(t);
                    i && (t = parseFloat(t) / 100);
                    var n = e.x, r = e.y, o = e.width, a = e.height, s = o / 2, l = i ? a * t : t, c = wr.KAPPA, u = c * s, h = c * (i ? a * t : t), g = n + o / 2, d = n + o, f = r + l, p = f - l, m = r + a - l, I = r + a;
                    return {
                        d: [
                            "M",
                            n,
                            f,
                            "L",
                            n,
                            m,
                            "C",
                            n,
                            m + h,
                            g - u,
                            I,
                            g,
                            I,
                            "C",
                            g + u,
                            I,
                            d,
                            m + h,
                            d,
                            m,
                            "L",
                            d,
                            f,
                            "C",
                            d,
                            f - h,
                            g + u,
                            p,
                            g,
                            p,
                            "C",
                            g - u,
                            p,
                            n,
                            f - h,
                            n,
                            f,
                            "Z"
                        ].join(" ")
                    };
                }
            }
        }
    }), ql = Nl.test("svgforeignobject") ? {
        tagName: "foreignObject",
        selector: "foreignObject",
        attributes: {
            overflow: "hidden"
        },
        children: [
            {
                tagName: "div",
                namespaceURI: "http://www.w3.org/1999/xhtml",
                selector: "label",
                style: {
                    width: "100%",
                    height: "100%",
                    position: "static",
                    backgroundColor: "transparent",
                    textAlign: "center",
                    margin: 0,
                    padding: "0px 5px",
                    boxSizing: "border-box",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center"
                }
            }
        ]
    } : {
        tagName: "text",
        selector: "label",
        attributes: {
            "text-anchor": "middle"
        }
    }, $l = {
        Rectangle: Rl,
        Circle: Yl,
        Ellipse: Wl,
        Path: Ul,
        Polygon: Fl,
        Polyline: Vl,
        Image: Xl,
        BorderedImage: Hl,
        EmbeddedImage: Jl,
        InscribedImage: _l,
        HeaderedRectangle: Ql,
        Cylinder: Kl,
        TextBlock: La.define("standard.TextBlock", {
            attrs: {
                body: {
                    refWidth: "100%",
                    refHeight: "100%",
                    stroke: "#333333",
                    fill: "#ffffff",
                    strokeWidth: 2
                },
                foreignObject: {
                    refWidth: "100%",
                    refHeight: "100%"
                },
                label: {
                    style: {
                        fontSize: 14
                    }
                }
            }
        }, {
            markup: [
                {
                    tagName: "rect",
                    selector: "body"
                },
                ql
            ]
        }, {
            attributes: {
                text: {
                    set: function(t, e, i, n) {
                        if (!(i instanceof HTMLElement)) {
                            var r = n.style || {}, o = {
                                text: t,
                                width: -5,
                                height: "100%"
                            }, a = io({
                                textVerticalAnchor: "middle"
                            }, r);
                            return ha.textWrap.set.call(this, o, e, i, a), {
                                fill: r.color || null
                            };
                        }
                        i.textContent = t;
                    },
                    position: function(t, e, i) {
                        if (i instanceof SVGElement) return e.center();
                    }
                }
            }
        }),
        Link: Sa.define("standard.Link", {
            attrs: {
                line: {
                    connection: !0,
                    stroke: "#333333",
                    strokeWidth: 2,
                    strokeLinejoin: "round",
                    targetMarker: {
                        type: "path",
                        d: "M 10 -5 0 0 10 5 z"
                    }
                },
                wrapper: {
                    connection: !0,
                    strokeWidth: 10,
                    strokeLinejoin: "round"
                }
            }
        }, {
            markup: [
                {
                    tagName: "path",
                    selector: "wrapper",
                    attributes: {
                        fill: "none",
                        cursor: "pointer",
                        stroke: "transparent",
                        "stroke-linecap": "round"
                    }
                },
                {
                    tagName: "path",
                    selector: "line",
                    attributes: {
                        fill: "none",
                        "pointer-events": "none"
                    }
                }
            ]
        }),
        DoubleLink: Sa.define("standard.DoubleLink", {
            attrs: {
                line: {
                    connection: !0,
                    stroke: "#DDDDDD",
                    strokeWidth: 4,
                    strokeLinejoin: "round",
                    targetMarker: {
                        type: "path",
                        stroke: "#000000",
                        d: "M 10 -3 10 -10 -2 0 10 10 10 3"
                    }
                },
                outline: {
                    connection: !0,
                    stroke: "#000000",
                    strokeWidth: 6,
                    strokeLinejoin: "round"
                }
            }
        }, {
            markup: [
                {
                    tagName: "path",
                    selector: "outline",
                    attributes: {
                        fill: "none"
                    }
                },
                {
                    tagName: "path",
                    selector: "line",
                    attributes: {
                        fill: "none"
                    }
                }
            ]
        }),
        ShadowLink: Sa.define("standard.ShadowLink", {
            attrs: {
                line: {
                    connection: !0,
                    stroke: "#FF0000",
                    strokeWidth: 20,
                    strokeLinejoin: "round",
                    targetMarker: {
                        type: "path",
                        stroke: "none",
                        d: "M 0 -10 -10 0 0 10 z"
                    },
                    sourceMarker: {
                        type: "path",
                        stroke: "none",
                        d: "M -10 -10 0 0 -10 10 0 10 0 -10 z"
                    }
                },
                shadow: {
                    connection: !0,
                    refX: 3,
                    refY: 6,
                    stroke: "#000000",
                    strokeOpacity: .2,
                    strokeWidth: 20,
                    strokeLinejoin: "round",
                    targetMarker: {
                        type: "path",
                        d: "M 0 -10 -10 0 0 10 z",
                        stroke: "none"
                    },
                    sourceMarker: {
                        type: "path",
                        stroke: "none",
                        d: "M -10 -10 0 0 -10 10 0 10 0 -10 z"
                    }
                }
            }
        }, {
            markup: [
                {
                    tagName: "path",
                    selector: "shadow",
                    attributes: {
                        fill: "none"
                    }
                },
                {
                    tagName: "path",
                    selector: "line",
                    attributes: {
                        fill: "none"
                    }
                }
            ]
        })
    }, tc = xl.define("devs.Model", {
        inPorts: [],
        outPorts: [],
        size: {
            width: 80,
            height: 80
        },
        attrs: {
            ".": {
                magnet: !1
            },
            ".label": {
                text: "Model",
                "ref-x": .5,
                "ref-y": 10,
                "font-size": 18,
                "text-anchor": "middle",
                fill: "#000"
            },
            ".body": {
                "ref-width": "100%",
                "ref-height": "100%",
                stroke: "#000"
            }
        },
        ports: {
            groups: {
                in: {
                    position: {
                        name: "left"
                    },
                    attrs: {
                        ".port-label": {
                            fill: "#000"
                        },
                        ".port-body": {
                            fill: "#fff",
                            stroke: "#000",
                            r: 10,
                            magnet: !0
                        }
                    },
                    label: {
                        position: {
                            name: "left",
                            args: {
                                y: 10
                            }
                        }
                    }
                },
                out: {
                    position: {
                        name: "right"
                    },
                    attrs: {
                        ".port-label": {
                            fill: "#000"
                        },
                        ".port-body": {
                            fill: "#fff",
                            stroke: "#000",
                            r: 10,
                            magnet: !0
                        }
                    },
                    label: {
                        position: {
                            name: "right",
                            args: {
                                y: 10
                            }
                        }
                    }
                }
            }
        }
    }, {
        markup: '<g class="rotatable"><rect class="body"/><text class="label"/></g>',
        portMarkup: '<circle class="port-body"/>',
        portLabelMarkup: '<text class="port-label"/>',
        initialize: function() {
            xl.prototype.initialize.apply(this, arguments), this.on("change:inPorts change:outPorts", this.updatePortItems, this), this.updatePortItems();
        },
        updatePortItems: function(t, e, i) {
            var n = so(this.get("inPorts")), r = yo(so(this.get("outPorts")), n), o = this.createPortItems("in", n), a = this.createPortItems("out", r);
            this.prop("ports/items", o.concat(a), io({
                rewrite: !0
            }, i));
        },
        createPortItem: function(t, e) {
            return {
                id: e,
                group: t,
                attrs: {
                    ".port-label": {
                        text: e
                    }
                }
            };
        },
        createPortItems: function(t, e) {
            return po(e).map(this.createPortItem.bind(this, t));
        },
        _addGroupPort: function(t, e, i) {
            var n = this.get(e);
            return this.set(e, Array.isArray(n) ? n.concat(t) : [
                t
            ], i);
        },
        addOutPort: function(t, e) {
            return this._addGroupPort(t, "outPorts", e);
        },
        addInPort: function(t, e) {
            return this._addGroupPort(t, "inPorts", e);
        },
        _removeGroupPort: function(t, e, i) {
            return this.set(e, Co(this.get(e), t), i);
        },
        removeOutPort: function(t, e) {
            return this._removeGroupPort(t, "outPorts", e);
        },
        removeInPort: function(t, e) {
            return this._removeGroupPort(t, "inPorts", e);
        },
        _changeGroup: function(t, e, i) {
            return this.prop("ports/groups/" + t, jo(e) ? e : {}, i);
        },
        changeInGroup: function(t, e) {
            return this._changeGroup("in", t, e);
        },
        changeOutGroup: function(t, e) {
            return this._changeGroup("out", t, e);
        }
    }), ec = tc.define("devs.Atomic", {
        size: {
            width: 80,
            height: 80
        },
        attrs: {
            ".label": {
                text: "Atomic"
            }
        }
    }), ic = tc.define("devs.Coupled", {
        size: {
            width: 200,
            height: 300
        },
        attrs: {
            ".label": {
                text: "Coupled"
            }
        }
    }), nc = {
        Model: tc,
        Atomic: ec,
        Coupled: ic,
        Link: Sa.define("devs.Link", {
            attrs: {
                ".connection": {
                    "stroke-width": 2
                }
            }
        })
    }, rc = xl.define("logic.Gate", {
        size: {
            width: 80,
            height: 40
        },
        attrs: {
            ".": {
                magnet: !1
            },
            ".body": {
                width: 100,
                height: 50
            },
            circle: {
                r: 7,
                stroke: "black",
                fill: "transparent",
                "stroke-width": 2
            }
        }
    }, {
        operation: function() {
            return !0;
        }
    }), oc = rc.define("logic.IO", {
        size: {
            width: 60,
            height: 30
        },
        attrs: {
            ".body": {
                fill: "white",
                stroke: "black",
                "stroke-width": 2
            },
            ".wire": {
                ref: ".body",
                "ref-y": .5,
                stroke: "black"
            },
            text: {
                fill: "black",
                ref: ".body",
                "ref-x": .5,
                "ref-y": .5,
                "y-alignment": "middle",
                "text-anchor": "middle",
                "font-weight": "bold",
                "font-variant": "small-caps",
                "text-transform": "capitalize",
                "font-size": "14px"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><rect class="body"/></g><path class="wire"/><circle/><text/></g>'
    }), ac = oc.define("logic.Input", {
        attrs: {
            ".wire": {
                "ref-dx": 0,
                d: "M 0 0 L 23 0"
            },
            circle: {
                ref: ".body",
                "ref-dx": 30,
                "ref-y": .5,
                magnet: !0,
                class: "output",
                port: "out"
            },
            text: {
                text: "input"
            }
        }
    }), sc = oc.define("logic.Output", {
        attrs: {
            ".wire": {
                "ref-x": 0,
                d: "M 0 0 L -23 0"
            },
            circle: {
                ref: ".body",
                "ref-x": -30,
                "ref-y": .5,
                magnet: "passive",
                class: "input",
                port: "in"
            },
            text: {
                text: "output"
            }
        }
    }), lc = rc.define("logic.Gate11", {
        attrs: {
            ".input": {
                ref: ".body",
                "ref-x": -2,
                "ref-y": .5,
                magnet: "passive",
                port: "in"
            },
            ".output": {
                ref: ".body",
                "ref-dx": 2,
                "ref-y": .5,
                magnet: !0,
                port: "out"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input"/><circle class="output"/></g>'
    }), cc = rc.define("logic.Gate21", {
        attrs: {
            ".input1": {
                ref: ".body",
                "ref-x": -2,
                "ref-y": .3,
                magnet: "passive",
                port: "in1"
            },
            ".input2": {
                ref: ".body",
                "ref-x": -2,
                "ref-y": .7,
                magnet: "passive",
                port: "in2"
            },
            ".output": {
                ref: ".body",
                "ref-dx": 2,
                "ref-y": .5,
                magnet: !0,
                port: "out"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><image class="body"/></g><circle class="input input1"/><circle  class="input input2"/><circle class="output"/></g>'
    }), uc = lc.define("logic.Repeater", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzIuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICA8L2c+Cjwvc3ZnPgo="
            }
        }
    }, {
        operation: function(t) {
            return t;
        }
    }), hc = lc.define("logic.Not", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PVCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjgiCiAgICAgaW5rc2NhcGU6Y3g9Ijg0LjY4NTM1MiIKICAgICBpbmtzY2FwZTpjeT0iMTUuMjg4NjI4IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzkuMTU2OTEsMjUgTCA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAyOS4wNDM0NzgsMjUgTCA1LjA0MzQ3ODEsMjUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgZD0iTSAyOC45Njg3NSwyLjU5Mzc1IEwgMjguOTY4NzUsNSBMIDI4Ljk2ODc1LDQ1IEwgMjguOTY4NzUsNDcuNDA2MjUgTCAzMS4xMjUsNDYuMzQzNzUgTCA3Mi4xNTYyNSwyNi4zNDM3NSBMIDcyLjE1NjI1LDIzLjY1NjI1IEwgMzEuMTI1LDMuNjU2MjUgTCAyOC45Njg3NSwyLjU5Mzc1IHogTSAzMS45Njg3NSw3LjQwNjI1IEwgNjguMDkzNzUsMjUgTCAzMS45Njg3NSw0Mi41OTM3NSBMIDMxLjk2ODc1LDcuNDA2MjUgeiIKICAgICAgIGlkPSJwYXRoMjYzOCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2NjY2NjY2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDI2NzEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzYiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA4MCwyNSBBIDQsNCAwIDEgMSA3MiwyNSBBIDQsNCAwIDEgMSA4MCwyNSB6IgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEsMCkiIC8+CiAgPC9nPgo8L3N2Zz4K"
            }
        }
    }, {
        operation: function(t) {
            return !t;
        }
    }), gc = cc.define("logic.Or", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik9SIEFOU0kuc3ZnIgogICBpbmtzY2FwZTpvdXRwdXRfZXh0ZW5zaW9uPSJvcmcuaW5rc2NhcGUub3V0cHV0LnN2Zy5pbmtzY2FwZSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczQiPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTAgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjcxNCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iMSA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMC41IDogMC4zMzMzMzMzMyA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODA2IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyODE5IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjM3Mi4wNDcyNCA6IDM1MC43ODczOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI3NDQuMDk0NDggOiA1MjYuMTgxMDkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzc3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49Ijc1IDogNDAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTUwIDogNjAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDYwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTMyNzUiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNTAgOiAzMy4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iMTAwIDogNTAgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDUwIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTU1MzMiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzIgOiAyMS4zMzMzMzMgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNjQgOiAzMiA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMzIgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjU1NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDE2LjY2NjY2NyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDI1IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAyNSA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iNCIKICAgICBpbmtzY2FwZTpjeD0iMTEzLjAwMDM5IgogICAgIGlua3NjYXBlOmN5PSIxMi44OTM3MzEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImcyNTYwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpncmlkLWJib3g9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1wb2ludHM9InRydWUiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAwMDAiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxMzk5IgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg3NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMzciCiAgICAgaW5rc2NhcGU6d2luZG93LXk9Ii00IgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNzAsMjUgYyAyMCwwIDI1LDAgMjUsMCIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMSwxNSA1LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzIsMzUgNSwzNSIKICAgICAgIGlkPSJwYXRoMzk0NCIgLz4KICAgIDxnCiAgICAgICBpZD0iZzI1NjAiCiAgICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI2LjUsLTM5LjUpIj4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo="
            }
        }
    }, {
        operation: function(t, e) {
            return t || e;
        }
    }), dc = cc.define("logic.And", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IkFORCBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI4IgogICAgIGlua3NjYXBlOmN4PSI1Ni42OTgzNDgiCiAgICAgaW5rc2NhcGU6Y3k9IjI1LjMyNjg5OSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZvbnQtc2l6ZTptZWRpdW07Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7Zm9udC1zdHJldGNoOm5vcm1hbDt0ZXh0LWluZGVudDowO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7ZGlyZWN0aW9uOmx0cjtibG9jay1wcm9ncmVzc2lvbjp0Yjt3cml0aW5nLW1vZGU6bHItdGI7dGV4dC1hbmNob3I6c3RhcnQ7ZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozO21hcmtlcjpub25lO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGU7Zm9udC1mYW1pbHk6Qml0c3RyZWFtIFZlcmEgU2FuczstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkJpdHN0cmVhbSBWZXJhIFNhbnMiCiAgICAgICBkPSJNIDMwLDUgTCAzMCw2LjQyODU3MTQgTCAzMCw0My41NzE0MjkgTCAzMCw0NSBMIDMxLjQyODU3MSw0NSBMIDUwLjQ3NjE5LDQ1IEMgNjEuNzQ0MDk4LDQ1IDcwLjQ3NjE5LDM1Ljk5OTk1NSA3MC40NzYxOSwyNSBDIDcwLjQ3NjE5LDE0LjAwMDA0NSA2MS43NDQwOTksNS4wMDAwMDAyIDUwLjQ3NjE5LDUgQyA1MC40NzYxOSw1IDUwLjQ3NjE5LDUgMzEuNDI4NTcxLDUgTCAzMCw1IHogTSAzMi44NTcxNDMsNy44NTcxNDI5IEMgNDAuODM0MjY0LDcuODU3MTQyOSA0NS45MTgzNjgsNy44NTcxNDI5IDQ4LjA5NTIzOCw3Ljg1NzE0MjkgQyA0OS4yODU3MTQsNy44NTcxNDI5IDQ5Ljg4MDk1Miw3Ljg1NzE0MjkgNTAuMTc4NTcxLDcuODU3MTQyOSBDIDUwLjMyNzM4MSw3Ljg1NzE0MjkgNTAuNDA5MjI3LDcuODU3MTQyOSA1MC40NDY0MjksNy44NTcxNDI5IEMgNTAuNDY1MDI5LDcuODU3MTQyOSA1MC40NzE1NDMsNy44NTcxNDI5IDUwLjQ3NjE5LDcuODU3MTQyOSBDIDYwLjIzNjg1Myw3Ljg1NzE0MyA2Ny4xNDI4NTcsMTUuNDk3MDk4IDY3LjE0Mjg1NywyNSBDIDY3LjE0Mjg1NywzNC41MDI5MDIgNTkuNzYwNjYyLDQyLjE0Mjg1NyA1MCw0Mi4xNDI4NTcgTCAzMi44NTcxNDMsNDIuMTQyODU3IEwgMzIuODU3MTQzLDcuODU3MTQyOSB6IgogICAgICAgaWQ9InBhdGgyODg0IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjY2NzY2NjY3Nzc3NzY2NjIiAvPgogIDwvZz4KPC9zdmc+Cg=="
            }
        }
    }, {
        operation: function(t, e) {
            return t && e;
        }
    }), fc = cc.define("logic.Nor", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5PUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjEiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjY3NzY0NCIKICAgICBpbmtzY2FwZTpjeT0iMjIuMTAyMzQ0IgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjM3IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItNCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc5LDI1IEMgOTksMjUgOTUsMjUgOTUsMjUiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEsMTUgNSwxNSIKICAgICAgIGlkPSJwYXRoMzA2MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjk5OTk5OTg4O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMyLDM1IDUsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46bWl0ZXI7bWFya2VyOm5vbmU7c3Ryb2tlLW9wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgICAgICBpZD0icGF0aDI2MDQiCiAgICAgICAgIHNvZGlwb2RpOmN4PSI3NSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjI1IgogICAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgICAgc29kaXBvZGk6cnk9IjQiCiAgICAgICAgIGQ9Ik0gNzksMjUgQSA0LDQgMCAxIDEgNzEsMjUgQSA0LDQgMCAxIDEgNzksMjUgeiIKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2LjUsMzkuNSkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K"
            }
        }
    }, {
        operation: function(t, e) {
            return !(t || e);
        }
    }), pc = cc.define("logic.Nand", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9Ik5BTkQgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaWQ9ImJhc2UiCiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6em9vbT0iMTYiCiAgICAgaW5rc2NhcGU6Y3g9Ijc4LjI4MzMwNyIKICAgICBpbmtzY2FwZTpjeT0iMTYuNDQyODQzIgogICAgIGlua3NjYXBlOmRvY3VtZW50LXVuaXRzPSJweCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgc2hvd2dyaWQ9InRydWUiCiAgICAgaW5rc2NhcGU6Z3JpZC1iYm94PSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtcG9pbnRzPSJ0cnVlIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTM5OSIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4NzQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjMzIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIwIgogICAgIGlua3NjYXBlOnNuYXAtYmJveD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgaWQ9IkdyaWRGcm9tUHJlMDQ2U2V0dGluZ3MiCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBvcmlnaW54PSIwcHgiCiAgICAgICBvcmlnaW55PSIwcHgiCiAgICAgICBzcGFjaW5neD0iMXB4IgogICAgICAgc3BhY2luZ3k9IjFweCIKICAgICAgIGNvbG9yPSIjMDAwMGZmIgogICAgICAgZW1wY29sb3I9IiMwMDAwZmYiCiAgICAgICBvcGFjaXR5PSIwLjIiCiAgICAgICBlbXBvcGFjaXR5PSIwLjQiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNyI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gNzksMjUgQyA5MS44LDI1IDk1LDI1IDk1LDI1IgogICAgICAgaWQ9InBhdGgzMDU5IgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDMxLDE1IDUsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMiwzNSA1LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmb250LXNpemU6bWVkaXVtO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lO2RpcmVjdGlvbjpsdHI7YmxvY2stcHJvZ3Jlc3Npb246dGI7d3JpdGluZy1tb2RlOmxyLXRiO3RleHQtYW5jaG9yOnN0YXJ0O2ZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MzttYXJrZXI6bm9uZTt2aXNpYmlsaXR5OnZpc2libGU7ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTtlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlO2ZvbnQtZmFtaWx5OkJpdHN0cmVhbSBWZXJhIFNhbnM7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpCaXRzdHJlYW0gVmVyYSBTYW5zIgogICAgICAgZD0iTSAzMCw1IEwgMzAsNi40Mjg1NzE0IEwgMzAsNDMuNTcxNDI5IEwgMzAsNDUgTCAzMS40Mjg1NzEsNDUgTCA1MC40NzYxOSw0NSBDIDYxLjc0NDA5OCw0NSA3MC40NzYxOSwzNS45OTk5NTUgNzAuNDc2MTksMjUgQyA3MC40NzYxOSwxNC4wMDAwNDUgNjEuNzQ0MDk5LDUuMDAwMDAwMiA1MC40NzYxOSw1IEMgNTAuNDc2MTksNSA1MC40NzYxOSw1IDMxLjQyODU3MSw1IEwgMzAsNSB6IE0gMzIuODU3MTQzLDcuODU3MTQyOSBDIDQwLjgzNDI2NCw3Ljg1NzE0MjkgNDUuOTE4MzY4LDcuODU3MTQyOSA0OC4wOTUyMzgsNy44NTcxNDI5IEMgNDkuMjg1NzE0LDcuODU3MTQyOSA0OS44ODA5NTIsNy44NTcxNDI5IDUwLjE3ODU3MSw3Ljg1NzE0MjkgQyA1MC4zMjczODEsNy44NTcxNDI5IDUwLjQwOTIyNyw3Ljg1NzE0MjkgNTAuNDQ2NDI5LDcuODU3MTQyOSBDIDUwLjQ2NTAyOSw3Ljg1NzE0MjkgNTAuNDcxNTQzLDcuODU3MTQyOSA1MC40NzYxOSw3Ljg1NzE0MjkgQyA2MC4yMzY4NTMsNy44NTcxNDMgNjcuMTQyODU3LDE1LjQ5NzA5OCA2Ny4xNDI4NTcsMjUgQyA2Ny4xNDI4NTcsMzQuNTAyOTAyIDU5Ljc2MDY2Miw0Mi4xNDI4NTcgNTAsNDIuMTQyODU3IEwgMzIuODU3MTQzLDQyLjE0Mjg1NyBMIDMyLjg1NzE0Myw3Ljg1NzE0MjkgeiIKICAgICAgIGlkPSJwYXRoMjg4NCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY2Njc2NjY2Nzc3Nzc2NjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDQwMDgiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg=="
            }
        }
    }, {
        operation: function(t, e) {
            return !(t && e);
        }
    }), mc = cc.define("logic.Xor", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhPUiBBTlNJLnN2ZyIKICAgaW5rc2NhcGU6b3V0cHV0X2V4dGVuc2lvbj0ib3JnLmlua3NjYXBlLm91dHB1dC5zdmcuaW5rc2NhcGUiPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0Ij4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSI1MCA6IDE1IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIyNSA6IDEwIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3MTQiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEgOiAwLjUgOiAxIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjAuNSA6IDAuMzMzMzMzMzMgOiAxIgogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgwNiIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjgxOSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzNzIuMDQ3MjQgOiAzNTAuNzg3MzkgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNzQ0LjA5NDQ4IDogNTI2LjE4MTA5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MjYuMTgxMDkgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMjc3NyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI3NSA6IDQwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjE1MCA6IDYwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA2MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUzMjc1IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjUwIDogMzMuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjEwMCA6IDUwIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiA1MCA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmU1NTMzIgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjMyIDogMjEuMzMzMzMzIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjY0IDogMzIgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDMyIDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI1NTciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxNi42NjY2NjcgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAyNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMjUgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAuMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOnpvb209IjUuNjU2ODU0MiIKICAgICBpbmtzY2FwZTpjeD0iMjUuOTM4MTE2IgogICAgIGlua3NjYXBlOmN5PSIxNy4yMzAwNSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDcwLDI1IGMgMjAsMCAyNSwwIDI1LDAiCiAgICAgICBpZD0icGF0aDMwNTkiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5ODg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzAuMzg1NzE3LDE1IEwgNC45OTk5OTk4LDE1IgogICAgICAgaWQ9InBhdGgzMDYxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuOTk5OTk5NzY7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Ik0gMzEuMzYyMDkxLDM1IEwgNC45OTk5OTk4LDM1IgogICAgICAgaWQ9InBhdGgzOTQ0IiAvPgogICAgPGcKICAgICAgIGlkPSJnMjU2MCIKICAgICAgIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYuNSwtMzkuNSkiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDM1MTYiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi4yNSw4MS41MDAwMDUgQyAtMy44NDczNzQsODQuMTQ0NDA1IC00LjUsODQuNTAwMDA1IC00LjUsODQuNTAwMDA1IEwgLTguMTU2MjUsODQuNTAwMDA1IEwgLTYuMTU2MjUsODIuMDYyNTA1IEMgLTYuMTU2MjUsODIuMDYyNTA1IC0wLjUsNzUuMDYyNDUxIC0wLjUsNjQuNSBDIC0wLjUsNTMuOTM3NTQ5IC02LjE1NjI1LDQ2LjkzNzUgLTYuMTU2MjUsNDYuOTM3NSBMIC04LjE1NjI1LDQ0LjUgTCAtNC41LDQ0LjUgQyAtMy43MTg3NSw0NS40Mzc1IC0zLjA3ODEyNSw0Ni4xNTYyNSAtMi4yODEyNSw0Ny41IEMgLTAuNDA4NTMxLDUwLjU5OTgxNSAyLjUsNTYuNTI2NjQ2IDIuNSw2NC41IEMgMi41LDcyLjQ1MDY1IC0wLjM5NjY5Nyw3OC4zNzk0MjUgLTIuMjUsODEuNTAwMDA1IHoiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NjY3NjY2Njc2MiIC8+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0iTSAtMi40MDYyNSw0NC41IEwgLTAuNDA2MjUsNDYuOTM3NSBDIC0wLjQwNjI1LDQ2LjkzNzUgNS4yNSw1My45Mzc1NDkgNS4yNSw2NC41IEMgNS4yNSw3NS4wNjI0NTEgLTAuNDA2MjUsODIuMDYyNSAtMC40MDYyNSw4Mi4wNjI1IEwgLTIuNDA2MjUsODQuNSBMIDAuNzUsODQuNSBMIDE0Ljc1LDg0LjUgQyAxNy4xNTgwNzYsODQuNTAwMDAxIDIyLjQzOTY5OSw4NC41MjQ1MTQgMjguMzc1LDgyLjA5Mzc1IEMgMzQuMzEwMzAxLDc5LjY2Mjk4NiA0MC45MTE1MzYsNzQuNzUwNDg0IDQ2LjA2MjUsNjUuMjE4NzUgTCA0NC43NSw2NC41IEwgNDYuMDYyNSw2My43ODEyNSBDIDM1Ljc1OTM4Nyw0NC43MTU1OSAxOS41MDY1NzQsNDQuNSAxNC43NSw0NC41IEwgMC43NSw0NC41IEwgLTIuNDA2MjUsNDQuNSB6IE0gMy40Njg3NSw0Ny41IEwgMTQuNzUsNDcuNSBDIDE5LjQzNDE3Myw0Ny41IDMzLjAzNjg1LDQ3LjM2OTc5MyA0Mi43MTg3NSw2NC41IEMgMzcuOTUxOTY0LDcyLjkyOTA3NSAzMi4xOTc0NjksNzcuMTgzOTEgMjcsNzkuMzEyNSBDIDIxLjYzOTMzOSw4MS41MDc5MjQgMTcuMTU4MDc1LDgxLjUwMDAwMSAxNC43NSw4MS41IEwgMy41LDgxLjUgQyA1LjM3MzU4ODQsNzguMzkxNTY2IDguMjUsNzIuNDUwNjUgOC4yNSw2NC41IEMgOC4yNSw1Ni41MjY2NDYgNS4zNDE0Njg2LDUwLjU5OTgxNSAzLjQ2ODc1LDQ3LjUgeiIKICAgICAgICAgaWQ9InBhdGg0OTczIgogICAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjc2NjY2NzY2NjY2NjY2Njc2Njc2MiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K"
            }
        }
    }, {
        operation: function(t, e) {
            return (!t || e) && (t || !e);
        }
    }), Ic = cc.define("logic.Xnor", {
        attrs: {
            image: {
                "xlink:href": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgo8c3ZnCiAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHdpZHRoPSIxMDAiCiAgIGhlaWdodD0iNTAiCiAgIGlkPSJzdmcyIgogICBzb2RpcG9kaTp2ZXJzaW9uPSIwLjMyIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ2IgogICB2ZXJzaW9uPSIxLjAiCiAgIHNvZGlwb2RpOmRvY25hbWU9IlhOT1IgQU5TSS5zdmciCiAgIGlua3NjYXBlOm91dHB1dF9leHRlbnNpb249Im9yZy5pbmtzY2FwZS5vdXRwdXQuc3ZnLmlua3NjYXBlIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzNCI+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogMTUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfej0iNTAgOiAxNSA6IDEiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMjUgOiAxMCA6IDEiCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNzE0IiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDAuNSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxIDogMC41IDogMSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIwLjUgOiAwLjMzMzMzMzMzIDogMSIKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MDYiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI4MTkiCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iMzcyLjA0NzI0IDogMzUwLjc4NzM5IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9Ijc0NC4wOTQ0OCA6IDUyNi4xODEwOSA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTI2LjE4MTA5IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgICA8aW5rc2NhcGU6cGVyc3BlY3RpdmUKICAgICAgIGlkPSJwZXJzcGVjdGl2ZTI3NzciCiAgICAgICBpbmtzY2FwZTpwZXJzcDNkLW9yaWdpbj0iNzUgOiA0MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxNTAgOiA2MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNjAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlMzI3NSIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSI1MCA6IDMzLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSIxMDAgOiA1MCA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF95PSIwIDogMTAwMCA6IDAiCiAgICAgICBpbmtzY2FwZTp2cF94PSIwIDogNTAgOiAxIgogICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6cGVyc3AzZCIgLz4KICAgIDxpbmtzY2FwZTpwZXJzcGVjdGl2ZQogICAgICAgaWQ9InBlcnNwZWN0aXZlNTUzMyIKICAgICAgIGlua3NjYXBlOnBlcnNwM2Qtb3JpZ2luPSIzMiA6IDIxLjMzMzMzMyA6IDEiCiAgICAgICBpbmtzY2FwZTp2cF96PSI2NCA6IDMyIDogMSIKICAgICAgIGlua3NjYXBlOnZwX3k9IjAgOiAxMDAwIDogMCIKICAgICAgIGlua3NjYXBlOnZwX3g9IjAgOiAzMiA6IDEiCiAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpwZXJzcDNkIiAvPgogICAgPGlua3NjYXBlOnBlcnNwZWN0aXZlCiAgICAgICBpZD0icGVyc3BlY3RpdmUyNTU3IgogICAgICAgaW5rc2NhcGU6cGVyc3AzZC1vcmlnaW49IjI1IDogMTYuNjY2NjY3IDogMSIKICAgICAgIGlua3NjYXBlOnZwX3o9IjUwIDogMjUgOiAxIgogICAgICAgaW5rc2NhcGU6dnBfeT0iMCA6IDEwMDAgOiAwIgogICAgICAgaW5rc2NhcGU6dnBfeD0iMCA6IDI1IDogMSIKICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOnBlcnNwM2QiIC8+CiAgPC9kZWZzPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSI0IgogICAgIGlua3NjYXBlOmN4PSI5NS43MjM2NiIKICAgICBpbmtzY2FwZTpjeT0iLTI2Ljc3NTAyMyIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOmdyaWQtYmJveD0idHJ1ZSIKICAgICBpbmtzY2FwZTpncmlkLXBvaW50cz0idHJ1ZSIKICAgICBncmlkdG9sZXJhbmNlPSIxMDAwMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzOTkiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iODc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIzMyIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWJib3g9InRydWUiPgogICAgPGlua3NjYXBlOmdyaWQKICAgICAgIGlkPSJHcmlkRnJvbVByZTA0NlNldHRpbmdzIgogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgb3JpZ2lueD0iMHB4IgogICAgICAgb3JpZ2lueT0iMHB4IgogICAgICAgc3BhY2luZ3g9IjFweCIKICAgICAgIHNwYWNpbmd5PSIxcHgiCiAgICAgICBjb2xvcj0iIzAwMDBmZiIKICAgICAgIGVtcGNvbG9yPSIjMDAwMGZmIgogICAgICAgb3BhY2l0eT0iMC4yIgogICAgICAgZW1wb3BhY2l0eT0iMC40IgogICAgICAgZW1wc3BhY2luZz0iNSIKICAgICAgIHZpc2libGU9InRydWUiCiAgICAgICBlbmFibGVkPSJ0cnVlIiAvPgogIDwvc29kaXBvZGk6bmFtZWR2aWV3PgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjAwMDAwMDI0O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJNIDc4LjMzMzMzMiwyNSBDIDkxLjY2NjY2NiwyNSA5NSwyNSA5NSwyNSIKICAgICAgIGlkPSJwYXRoMzA1OSIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk4ODtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMC4zODU3MTcsMTUgTCA0Ljk5OTk5OTgsMTUiCiAgICAgICBpZD0icGF0aDMwNjEiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS45OTk5OTk3NjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0iTSAzMS4zNjIwOTEsMzUgTCA0Ljk5OTk5OTgsMzUiCiAgICAgICBpZD0icGF0aDM5NDQiIC8+CiAgICA8ZwogICAgICAgaWQ9ImcyNTYwIgogICAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNi41LC0zOS41KSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMzUxNiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjI1LDgxLjUwMDAwNSBDIC0zLjg0NzM3NCw4NC4xNDQ0MDUgLTQuNSw4NC41MDAwMDUgLTQuNSw4NC41MDAwMDUgTCAtOC4xNTYyNSw4NC41MDAwMDUgTCAtNi4xNTYyNSw4Mi4wNjI1MDUgQyAtNi4xNTYyNSw4Mi4wNjI1MDUgLTAuNSw3NS4wNjI0NTEgLTAuNSw2NC41IEMgLTAuNSw1My45Mzc1NDkgLTYuMTU2MjUsNDYuOTM3NSAtNi4xNTYyNSw0Ni45Mzc1IEwgLTguMTU2MjUsNDQuNSBMIC00LjUsNDQuNSBDIC0zLjcxODc1LDQ1LjQzNzUgLTMuMDc4MTI1LDQ2LjE1NjI1IC0yLjI4MTI1LDQ3LjUgQyAtMC40MDg1MzEsNTAuNTk5ODE1IDIuNSw1Ni41MjY2NDYgMi41LDY0LjUgQyAyLjUsNzIuNDUwNjUgLTAuMzk2Njk3LDc4LjM3OTQyNSAtMi4yNSw4MS41MDAwMDUgeiIKICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2Njc2NjY2NzYyIgLz4KICAgICAgPHBhdGgKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIC0yLjQwNjI1LDQ0LjUgTCAtMC40MDYyNSw0Ni45Mzc1IEMgLTAuNDA2MjUsNDYuOTM3NSA1LjI1LDUzLjkzNzU0OSA1LjI1LDY0LjUgQyA1LjI1LDc1LjA2MjQ1MSAtMC40MDYyNSw4Mi4wNjI1IC0wLjQwNjI1LDgyLjA2MjUgTCAtMi40MDYyNSw4NC41IEwgMC43NSw4NC41IEwgMTQuNzUsODQuNSBDIDE3LjE1ODA3Niw4NC41MDAwMDEgMjIuNDM5Njk5LDg0LjUyNDUxNCAyOC4zNzUsODIuMDkzNzUgQyAzNC4zMTAzMDEsNzkuNjYyOTg2IDQwLjkxMTUzNiw3NC43NTA0ODQgNDYuMDYyNSw2NS4yMTg3NSBMIDQ0Ljc1LDY0LjUgTCA0Ni4wNjI1LDYzLjc4MTI1IEMgMzUuNzU5Mzg3LDQ0LjcxNTU5IDE5LjUwNjU3NCw0NC41IDE0Ljc1LDQ0LjUgTCAwLjc1LDQ0LjUgTCAtMi40MDYyNSw0NC41IHogTSAzLjQ2ODc1LDQ3LjUgTCAxNC43NSw0Ny41IEMgMTkuNDM0MTczLDQ3LjUgMzMuMDM2ODUsNDcuMzY5NzkzIDQyLjcxODc1LDY0LjUgQyAzNy45NTE5NjQsNzIuOTI5MDc1IDMyLjE5NzQ2OSw3Ny4xODM5MSAyNyw3OS4zMTI1IEMgMjEuNjM5MzM5LDgxLjUwNzkyNCAxNy4xNTgwNzUsODEuNTAwMDAxIDE0Ljc1LDgxLjUgTCAzLjUsODEuNSBDIDUuMzczNTg4NCw3OC4zOTE1NjYgOC4yNSw3Mi40NTA2NSA4LjI1LDY0LjUgQyA4LjI1LDU2LjUyNjY0NiA1LjM0MTQ2ODYsNTAuNTk5ODE1IDMuNDY4NzUsNDcuNSB6IgogICAgICAgICBpZD0icGF0aDQ5NzMiCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2NzY2NjY3NjY2NjY2NjY2NzY2NzYyIgLz4KICAgIDwvZz4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDozO3N0cm9rZS1saW5lam9pbjptaXRlcjttYXJrZXI6bm9uZTtzdHJva2Utb3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTtkaXNwbGF5OmlubGluZTtvdmVyZmxvdzp2aXNpYmxlO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGUiCiAgICAgICBpZD0icGF0aDM1NTEiCiAgICAgICBzb2RpcG9kaTpjeD0iNzUiCiAgICAgICBzb2RpcG9kaTpjeT0iMjUiCiAgICAgICBzb2RpcG9kaTpyeD0iNCIKICAgICAgIHNvZGlwb2RpOnJ5PSI0IgogICAgICAgZD0iTSA3OSwyNSBBIDQsNCAwIDEgMSA3MSwyNSBBIDQsNCAwIDEgMSA3OSwyNSB6IiAvPgogIDwvZz4KPC9zdmc+Cg=="
            }
        }
    }, {
        operation: function(t, e) {
            return (!t || !e) && (t || e);
        }
    }), vc = {
        Gate: rc,
        IO: oc,
        Input: ac,
        Output: sc,
        Gate11: lc,
        Gate21: cc,
        Repeater: uc,
        Not: hc,
        Or: gc,
        And: dc,
        Nor: fc,
        Nand: pc,
        Xor: mc,
        Xnor: Ic,
        Wire: Sa.define("logic.Wire", {
            attrs: {
                ".connection": {
                    "stroke-width": 2
                },
                ".marker-vertex": {
                    r: 7
                }
            },
            router: {
                name: "orthogonal"
            },
            connector: {
                name: "rounded",
                args: {
                    radius: 10
                }
            }
        }, {
            arrowheadMarkup: [
                '<g class="marker-arrowhead-group marker-arrowhead-group-<%= end %>">',
                '<circle class="marker-arrowhead" end="<%= end %>" r="7"/>',
                "</g>"
            ].join(""),
            vertexMarkup: [
                '<g class="marker-vertex-group" transform="translate(<%= x %>, <%= y %>)">',
                '<circle class="marker-vertex" idx="<%= idx %>" r="10" />',
                '<g class="marker-vertex-remove-group">',
                '<path class="marker-vertex-remove-area" idx="<%= idx %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>',
                '<path class="marker-vertex-remove" idx="<%= idx %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">',
                "<title>Remove vertex.</title>",
                "</path>",
                "</g>",
                "</g>"
            ].join("")
        })
    }, Ac = {
        KingWhite: xl.define("chess.KingWhite", {
            size: {
                width: 42,
                height: 38
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;"><path      d="M 22.5,11.63 L 22.5,6"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path      d="M 20,8 L 25,8"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path      d="M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25"      style="fill:#ffffff; stroke:#000000; stroke-linecap:butt; stroke-linejoin:miter;" />    <path      d="M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z "      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 11.5,30 C 17,27 27,27 32.5,30"      style="fill:none; stroke:#000000;" />    <path      d="M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5"      style="fill:none; stroke:#000000;" />    <path      d="M 11.5,37 C 17,34 27,34 32.5,37"      style="fill:none; stroke:#000000;" />  </g></g></g>'
        }),
        KingBlack: xl.define("chess.KingBlack", {
            size: {
                width: 42,
                height: 38
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path       d="M 22.5,11.63 L 22.5,6"       style="fill:none; stroke:#000000; stroke-linejoin:miter;"       id="path6570" />    <path       d="M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25"       style="fill:#000000;fill-opacity:1; stroke-linecap:butt; stroke-linejoin:miter;" />    <path       d="M 11.5,37 C 17,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 19,16 9.5,13 6.5,19.5 C 3.5,25.5 11.5,29.5 11.5,29.5 L 11.5,37 z "       style="fill:#000000; stroke:#000000;" />    <path       d="M 20,8 L 25,8"       style="fill:none; stroke:#000000; stroke-linejoin:miter;" />    <path       d="M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.51,26.6 L 22.5,24.5 C 20,18 9.906,14 6.997,19.85 C 4.5,25.5 11.85,28.85 11.85,28.85"       style="fill:none; stroke:#ffffff;" />    <path       d="M 11.5,30 C 17,27 27,27 32.5,30 M 11.5,33.5 C 17,30.5 27,30.5 32.5,33.5 M 11.5,37 C 17,34 27,34 32.5,37"       style="fill:none; stroke:#ffffff;" />  </g></g></g>'
        }),
        QueenWhite: xl.define("chess.QueenWhite", {
            size: {
                width: 42,
                height: 38
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(-1,-1)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(15.5,-5.5)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(32,-1)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(7,-4.5)" />    <path      d="M 9 13 A 2 2 0 1 1  5,13 A 2 2 0 1 1  9 13 z"      transform="translate(24,-4)" />    <path      d="M 9,26 C 17.5,24.5 30,24.5 36,26 L 38,14 L 31,25 L 31,11 L 25.5,24.5 L 22.5,9.5 L 19.5,24.5 L 14,10.5 L 14,25 L 7,14 L 9,26 z "      style="stroke-linecap:butt;" />    <path      d="M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z "      style="stroke-linecap:butt;" />    <path      d="M 11.5,30 C 15,29 30,29 33.5,30"      style="fill:none;" />    <path      d="M 12,33.5 C 18,32.5 27,32.5 33,33.5"      style="fill:none;" />  </g></g></g>'
        }),
        QueenBlack: xl.define("chess.QueenBlack", {
            size: {
                width: 42,
                height: 38
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#000000; stroke:none;">      <circle cx="6"    cy="12" r="2.75" />      <circle cx="14"   cy="9"  r="2.75" />      <circle cx="22.5" cy="8"  r="2.75" />      <circle cx="31"   cy="9"  r="2.75" />      <circle cx="39"   cy="12" r="2.75" />    </g>    <path       d="M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z"       style="stroke-linecap:butt; stroke:#000000;" />    <path       d="M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 10.5,36 10.5,36 C 9,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z"       style="stroke-linecap:butt;" />    <path       d="M 11,38.5 A 35,35 1 0 0 34,38.5"       style="fill:none; stroke:#000000; stroke-linecap:butt;" />    <path       d="M 11,29 A 35,35 1 0 1 34,29"       style="fill:none; stroke:#ffffff;" />    <path       d="M 12.5,31.5 L 32.5,31.5"       style="fill:none; stroke:#ffffff;" />    <path       d="M 11.5,34.5 A 35,35 1 0 0 33.5,34.5"       style="fill:none; stroke:#ffffff;" />    <path       d="M 10.5,37.5 A 35,35 1 0 0 34.5,37.5"       style="fill:none; stroke:#ffffff;" />  </g></g></g>'
        }),
        RookWhite: xl.define("chess.RookWhite", {
            size: {
                width: 32,
                height: 34
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z "      style="stroke-linecap:butt;" />    <path      d="M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z "      style="stroke-linecap:butt;" />    <path      d="M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14"      style="stroke-linecap:butt;" />    <path      d="M 34,14 L 31,17 L 14,17 L 11,14" />    <path      d="M 31,17 L 31,29.5 L 14,29.5 L 14,17"      style="stroke-linecap:butt; stroke-linejoin:miter;" />    <path      d="M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5" />    <path      d="M 11,14 L 34,14"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />  </g></g></g>'
        }),
        RookBlack: xl.define("chess.RookBlack", {
            size: {
                width: 32,
                height: 34
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z "      style="stroke-linecap:butt;" />    <path      d="M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z "      style="stroke-linecap:butt;" />    <path      d="M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z "      style="stroke-linecap:butt;" />    <path      d="M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z "      style="stroke-linecap:butt;stroke-linejoin:miter;" />    <path      d="M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z "      style="stroke-linecap:butt;" />    <path      d="M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z "      style="stroke-linecap:butt;" />    <path      d="M 12,35.5 L 33,35.5 L 33,35.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 13,31.5 L 32,31.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 14,29.5 L 31,29.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 14,16.5 L 31,16.5"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />    <path      d="M 11,14 L 34,14"      style="fill:none; stroke:#ffffff; stroke-width:1; stroke-linejoin:miter;" />  </g></g></g>'
        }),
        BishopWhite: xl.define("chess.BishopWhite", {
            size: {
                width: 38,
                height: 38
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#ffffff; stroke:#000000; stroke-linecap:butt;">       <path        d="M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z" />      <path        d="M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" />      <path        d="M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" />    </g>    <path      d="M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18"      style="fill:none; stroke:#000000; stroke-linejoin:miter;" />  </g></g></g>'
        }),
        BishopBlack: xl.define("chess.BishopBlack", {
            size: {
                width: 38,
                height: 38
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-rule:evenodd; fill-opacity:1; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:round; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <g style="fill:#000000; stroke:#000000; stroke-linecap:butt;">       <path        d="M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.646,38.99 6.677,38.97 6,38 C 7.354,36.06 9,36 9,36 z" />      <path        d="M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" />      <path        d="M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" />    </g>    <path       d="M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18"       style="fill:none; stroke:#ffffff; stroke-linejoin:miter;" />  </g></g></g>'
        }),
        KnightWhite: xl.define("chess.KnightWhite", {
            size: {
                width: 38,
                height: 37
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18"      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10"      style="fill:#ffffff; stroke:#000000;" />    <path      d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z"      style="fill:#000000; stroke:#000000;" />    <path      d="M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z"      transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)"      style="fill:#000000; stroke:#000000;" />  </g></g></g>'
        }),
        KnightBlack: xl.define("chess.KnightBlack", {
            size: {
                width: 38,
                height: 37
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><g style="opacity:1; fill:none; fill-opacity:1; fill-rule:evenodd; stroke:#000000; stroke-width:1.5; stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;">    <path      d="M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18"      style="fill:#000000; stroke:#000000;" />    <path      d="M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10"      style="fill:#000000; stroke:#000000;" />    <path      d="M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z"      style="fill:#ffffff; stroke:#ffffff;" />    <path      d="M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z"      transform="matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)"      style="fill:#ffffff; stroke:#ffffff;" />    <path      d="M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z "      style="fill:#ffffff; stroke:none;" />  </g></g></g>'
        }),
        PawnWhite: xl.define("chess.PawnWhite", {
            size: {
                width: 28,
                height: 33
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><path d="M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z "  style="opacity:1; fill:#ffffff; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;" /></g></g>'
        }),
        PawnBlack: xl.define("chess.PawnBlack", {
            size: {
                width: 28,
                height: 33
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><path d="M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.44,24.84 17.91,26.03 C 14.91,27.09 10.5,31.58 10.5,39.5 L 33.5,39.5 C 33.5,31.58 29.09,27.09 26.09,26.03 C 27.56,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 z "  style="opacity:1; fill:#000000; fill-opacity:1; fill-rule:nonzero; stroke:#000000; stroke-width:1.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-dasharray:none; stroke-opacity:1;" /></g></g>'
        })
    }, Cc = La.define("erd.Entity", {
        size: {
            width: 150,
            height: 60
        },
        attrs: {
            ".outer": {
                fill: "#2ECC71",
                stroke: "#27AE60",
                "stroke-width": 2,
                points: "100,0 100,60 0,60 0,0"
            },
            ".inner": {
                fill: "#2ECC71",
                stroke: "#27AE60",
                "stroke-width": 2,
                points: "95,5 95,55 5,55 5,5",
                display: "none"
            },
            text: {
                text: "Entity",
                "font-family": "Arial",
                "font-size": 14,
                "ref-x": .5,
                "ref-y": .5,
                "y-alignment": "middle",
                "text-anchor": "middle"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>'
    }), yc = Cc.define("erd.WeakEntity", {
        attrs: {
            ".inner": {
                display: "auto"
            },
            text: {
                text: "Weak Entity"
            }
        }
    }), wc = La.define("erd.Relationship", {
        size: {
            width: 80,
            height: 80
        },
        attrs: {
            ".outer": {
                fill: "#3498DB",
                stroke: "#2980B9",
                "stroke-width": 2,
                points: "40,0 80,40 40,80 0,40"
            },
            ".inner": {
                fill: "#3498DB",
                stroke: "#2980B9",
                "stroke-width": 2,
                points: "40,5 75,40 40,75 5,40",
                display: "none"
            },
            text: {
                text: "Relationship",
                "font-family": "Arial",
                "font-size": 12,
                "ref-x": .5,
                "ref-y": .5,
                "y-alignment": "middle",
                "text-anchor": "middle"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><polygon class="outer"/><polygon class="inner"/></g><text/></g>'
    }), bc = wc.define("erd.IdentifyingRelationship", {
        attrs: {
            ".inner": {
                display: "auto"
            },
            text: {
                text: "Identifying"
            }
        }
    }), Nc = La.define("erd.Attribute", {
        size: {
            width: 100,
            height: 50
        },
        attrs: {
            ellipse: {
                transform: "translate(50, 25)"
            },
            ".outer": {
                stroke: "#D35400",
                "stroke-width": 2,
                cx: 0,
                cy: 0,
                rx: 50,
                ry: 25,
                fill: "#E67E22"
            },
            ".inner": {
                stroke: "#D35400",
                "stroke-width": 2,
                cx: 0,
                cy: 0,
                rx: 45,
                ry: 20,
                fill: "#E67E22",
                display: "none"
            },
            text: {
                "font-family": "Arial",
                "font-size": 14,
                "ref-x": .5,
                "ref-y": .5,
                "y-alignment": "middle",
                "text-anchor": "middle"
            }
        }
    }, {
        markup: '<g class="rotatable"><g class="scalable"><ellipse class="outer"/><ellipse class="inner"/></g><text/></g>'
    }), xc = Nc.define("erd.Multivalued", {
        attrs: {
            ".inner": {
                display: "block"
            },
            text: {
                text: "multivalued"
            }
        }
    }), Mc = Nc.define("erd.Derived", {
        attrs: {
            ".outer": {
                "stroke-dasharray": "3,5"
            },
            text: {
                text: "derived"
            }
        }
    }), Sc = Nc.define("erd.Key", {
        attrs: {
            ellipse: {
                "stroke-width": 4
            },
            text: {
                text: "key",
                "font-weight": "800",
                "text-decoration": "underline"
            }
        }
    }), kc = Nc.define("erd.Normal", {
        attrs: {
            text: {
                text: "Normal"
            }
        }
    }), Dc = {
        Entity: Cc,
        WeakEntity: yc,
        Relationship: wc,
        IdentifyingRelationship: bc,
        Attribute: Nc,
        Multivalued: xc,
        Derived: Mc,
        Key: Sc,
        Normal: kc,
        ISA: La.define("erd.ISA", {
            type: "erd.ISA",
            size: {
                width: 100,
                height: 50
            },
            attrs: {
                polygon: {
                    points: "0,0 50,50 100,0",
                    fill: "#F1C40F",
                    stroke: "#F39C12",
                    "stroke-width": 2
                },
                text: {
                    text: "ISA",
                    "font-size": 18,
                    "ref-x": .5,
                    "ref-y": .3,
                    "y-alignment": "middle",
                    "text-anchor": "middle"
                }
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><polygon/></g><text/></g>'
        }),
        Line: Sa.define("erd.Line", {}, {
            cardinality: function(t) {
                this.set("labels", [
                    {
                        position: -20,
                        attrs: {
                            text: {
                                dy: -8,
                                text: t
                            }
                        }
                    }
                ]);
            }
        })
    }, Tc = {
        State: Dl.define("fsa.State", {
            attrs: {
                circle: {
                    "stroke-width": 3
                },
                text: {
                    "font-weight": "800"
                }
            }
        }),
        StartState: La.define("fsa.StartState", {
            size: {
                width: 20,
                height: 20
            },
            attrs: {
                circle: {
                    transform: "translate(10, 10)",
                    r: 10,
                    fill: "#000000"
                }
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><circle/></g></g>'
        }),
        EndState: La.define("fsa.EndState", {
            size: {
                width: 20,
                height: 20
            },
            attrs: {
                ".outer": {
                    transform: "translate(10, 10)",
                    r: 10,
                    fill: "#ffffff",
                    stroke: "#000000"
                },
                ".inner": {
                    transform: "translate(10, 10)",
                    r: 6,
                    fill: "#000000"
                }
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>'
        }),
        Arrow: Sa.define("fsa.Arrow", {
            attrs: {
                ".marker-target": {
                    d: "M 10 0 L 0 5 L 10 10 z"
                }
            },
            smooth: !0
        })
    }, Lc = {
        Member: La.define("org.Member", {
            size: {
                width: 180,
                height: 70
            },
            attrs: {
                rect: {
                    width: 170,
                    height: 60
                },
                ".card": {
                    fill: "#FFFFFF",
                    stroke: "#000000",
                    "stroke-width": 2,
                    "pointer-events": "visiblePainted",
                    rx: 10,
                    ry: 10
                },
                image: {
                    width: 48,
                    height: 48,
                    ref: ".card",
                    "ref-x": 10,
                    "ref-y": 5
                },
                ".rank": {
                    "text-decoration": "underline",
                    ref: ".card",
                    "ref-x": .9,
                    "ref-y": .2,
                    "font-family": "Courier New",
                    "font-size": 14,
                    "text-anchor": "end"
                },
                ".name": {
                    "font-weight": "800",
                    ref: ".card",
                    "ref-x": .9,
                    "ref-y": .6,
                    "font-family": "Courier New",
                    "font-size": 14,
                    "text-anchor": "end"
                }
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><rect class="card"/><image/></g><text class="rank"/><text class="name"/></g>'
        }),
        Arrow: Sa.define("org.Arrow", {
            source: {
                selector: ".card"
            },
            target: {
                selector: ".card"
            },
            attrs: {
                ".connection": {
                    stroke: "#585858",
                    "stroke-width": 3
                }
            },
            z: -1
        })
    }, zc = {
        Place: xl.define("pn.Place", {
            size: {
                width: 50,
                height: 50
            },
            attrs: {
                ".root": {
                    r: 25,
                    fill: "#ffffff",
                    stroke: "#000000",
                    transform: "translate(25, 25)"
                },
                ".label": {
                    "text-anchor": "middle",
                    "ref-x": .5,
                    "ref-y": -20,
                    ref: ".root",
                    fill: "#000000",
                    "font-size": 12
                },
                ".tokens > circle": {
                    fill: "#000000",
                    r: 5
                },
                ".tokens.one > circle": {
                    transform: "translate(25, 25)"
                },
                ".tokens.two > circle:nth-child(1)": {
                    transform: "translate(19, 25)"
                },
                ".tokens.two > circle:nth-child(2)": {
                    transform: "translate(31, 25)"
                },
                ".tokens.three > circle:nth-child(1)": {
                    transform: "translate(18, 29)"
                },
                ".tokens.three > circle:nth-child(2)": {
                    transform: "translate(25, 19)"
                },
                ".tokens.three > circle:nth-child(3)": {
                    transform: "translate(32, 29)"
                },
                ".tokens.alot > text": {
                    transform: "translate(25, 18)",
                    "text-anchor": "middle",
                    fill: "#000000"
                }
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><circle class="root"/><g class="tokens" /></g><text class="label"/></g>'
        }),
        PlaceView: Va.extend({
            presentationAttributes: Va.addPresentationAttributes({
                tokens: [
                    "TOKENS"
                ]
            }),
            initFlag: Va.prototype.initFlag.concat([
                "TOKENS"
            ]),
            confirmUpdate: function() {
                for(var t, e = [], i = arguments.length; i--;)e[i] = arguments[i];
                var n = (t = Va.prototype.confirmUpdate).call.apply(t, [
                    this
                ].concat(e));
                return this.hasFlag(n, "TOKENS") && (this.renderTokens(), this.update(), n = this.removeFlag(n, "TOKENS")), n;
            },
            renderTokens: function() {
                var e = this.vel.findOne(".tokens").empty();
                [
                    "one",
                    "two",
                    "three",
                    "alot"
                ].forEach(function(t) {
                    e.removeClass(t);
                });
                var t = this.model.get("tokens");
                if (t) switch(t){
                    case 1:
                        e.addClass("one"), e.append(wr("circle"));
                        break;
                    case 2:
                        e.addClass("two"), e.append([
                            wr("circle"),
                            wr("circle")
                        ]);
                        break;
                    case 3:
                        e.addClass("three"), e.append([
                            wr("circle"),
                            wr("circle"),
                            wr("circle")
                        ]);
                        break;
                    default:
                        e.addClass("alot"), e.append(wr("text").text(t + ""));
                }
            }
        }),
        Transition: xl.define("pn.Transition", {
            size: {
                width: 12,
                height: 50
            },
            attrs: {
                rect: {
                    width: 12,
                    height: 50,
                    fill: "#000000",
                    stroke: "#000000"
                },
                ".label": {
                    "text-anchor": "middle",
                    "ref-x": .5,
                    "ref-y": -20,
                    ref: "rect",
                    fill: "#000000",
                    "font-size": 12
                }
            }
        }, {
            markup: '<g class="rotatable"><g class="scalable"><rect class="root"/></g></g><text class="label"/>'
        }),
        Link: Sa.define("pn.Link", {
            attrs: {
                ".marker-target": {
                    d: "M 10 0 L 0 5 L 10 10 z"
                }
            }
        })
    }, Pc = xl.define("uml.Class", {
        attrs: {
            rect: {
                width: 200
            },
            ".uml-class-name-rect": {
                stroke: "black",
                "stroke-width": 2,
                fill: "#3498db"
            },
            ".uml-class-attrs-rect": {
                stroke: "black",
                "stroke-width": 2,
                fill: "#2980b9"
            },
            ".uml-class-methods-rect": {
                stroke: "black",
                "stroke-width": 2,
                fill: "#2980b9"
            },
            ".uml-class-name-text": {
                ref: ".uml-class-name-rect",
                "ref-y": .5,
                "ref-x": .5,
                "text-anchor": "middle",
                "y-alignment": "middle",
                "font-weight": "bold",
                fill: "black",
                "font-size": 12,
                "font-family": "Times New Roman"
            },
            ".uml-class-attrs-text": {
                ref: ".uml-class-attrs-rect",
                "ref-y": 5,
                "ref-x": 5,
                fill: "black",
                "font-size": 12,
                "font-family": "Times New Roman"
            },
            ".uml-class-methods-text": {
                ref: ".uml-class-methods-rect",
                "ref-y": 5,
                "ref-x": 5,
                fill: "black",
                "font-size": 12,
                "font-family": "Times New Roman"
            }
        },
        name: [],
        attributes: [],
        methods: []
    }, {
        markup: [
            '<g class="rotatable">',
            '<g class="scalable">',
            '<rect class="uml-class-name-rect"/><rect class="uml-class-attrs-rect"/><rect class="uml-class-methods-rect"/>',
            "</g>",
            '<text class="uml-class-name-text"/><text class="uml-class-attrs-text"/><text class="uml-class-methods-text"/>',
            "</g>"
        ].join(""),
        initialize: function() {
            this.on("change:name change:attributes change:methods", function() {
                this.updateRectangles(), this.trigger("uml-update");
            }, this), this.updateRectangles(), xl.prototype.initialize.apply(this, arguments);
        },
        getClassName: function() {
            return this.get("name");
        },
        updateRectangles: function() {
            var n = this.get("attrs"), t = [
                {
                    type: "name",
                    text: this.getClassName()
                },
                {
                    type: "attrs",
                    text: this.get("attributes")
                },
                {
                    type: "methods",
                    text: this.get("methods")
                }
            ], r = 0;
            t.forEach(function(t) {
                var e = Array.isArray(t.text) ? t.text : [
                    t.text
                ], i = 20 * e.length + 20;
                n[".uml-class-" + t.type + "-text"].text = e.join("\n"), n[".uml-class-" + t.type + "-rect"].height = i, n[".uml-class-" + t.type + "-rect"].transform = "translate(0," + r + ")", r += i;
            });
        }
    }), jc = Va.extend({
        initialize: function() {
            Va.prototype.initialize.apply(this, arguments), this.listenTo(this.model, "uml-update", function() {
                this.update(), this.resize();
            });
        }
    }), Zc = Pc.define("uml.Abstract", {
        attrs: {
            ".uml-class-name-rect": {
                fill: "#e74c3c"
            },
            ".uml-class-attrs-rect": {
                fill: "#c0392b"
            },
            ".uml-class-methods-rect": {
                fill: "#c0392b"
            }
        }
    }, {
        getClassName: function() {
            return [
                "<<Abstract>>",
                this.get("name")
            ];
        }
    }), Gc = jc, Bc = Pc.define("uml.Interface", {
        attrs: {
            ".uml-class-name-rect": {
                fill: "#f1c40f"
            },
            ".uml-class-attrs-rect": {
                fill: "#f39c12"
            },
            ".uml-class-methods-rect": {
                fill: "#f39c12"
            }
        }
    }, {
        getClassName: function() {
            return [
                "<<Interface>>",
                this.get("name")
            ];
        }
    }), Oc = {
        basic: El,
        standard: $l,
        devs: nc,
        logic: vc,
        chess: Ac,
        erd: Dc,
        fsa: Tc,
        org: Lc,
        pn: zc,
        uml: {
            Class: Pc,
            ClassView: jc,
            Abstract: Zc,
            AbstractView: Gc,
            Interface: Bc,
            InterfaceView: jc,
            Generalization: Sa.define("uml.Generalization", {
                attrs: {
                    ".marker-target": {
                        d: "M 20 0 L 0 10 L 20 20 z",
                        fill: "white"
                    }
                }
            }),
            Implementation: Sa.define("uml.Implementation", {
                attrs: {
                    ".marker-target": {
                        d: "M 20 0 L 0 10 L 20 20 z",
                        fill: "white"
                    },
                    ".connection": {
                        "stroke-dasharray": "3,3"
                    }
                }
            }),
            Aggregation: Sa.define("uml.Aggregation", {
                attrs: {
                    ".marker-target": {
                        d: "M 40 10 L 20 20 L 0 10 L 20 0 z",
                        fill: "white"
                    }
                }
            }),
            Composition: Sa.define("uml.Composition", {
                attrs: {
                    ".marker-target": {
                        d: "M 40 10 L 20 20 L 0 10 L 20 0 z",
                        fill: "black"
                    }
                }
            }),
            Association: Sa.define("uml.Association"),
            State: xl.define("uml.State", {
                attrs: {
                    ".uml-state-body": {
                        width: 200,
                        height: 200,
                        rx: 10,
                        ry: 10,
                        fill: "#ecf0f1",
                        stroke: "#bdc3c7",
                        "stroke-width": 3
                    },
                    ".uml-state-separator": {
                        stroke: "#bdc3c7",
                        "stroke-width": 2
                    },
                    ".uml-state-name": {
                        ref: ".uml-state-body",
                        "ref-x": .5,
                        "ref-y": 5,
                        "text-anchor": "middle",
                        fill: "#000000",
                        "font-family": "Courier New",
                        "font-size": 14
                    },
                    ".uml-state-events": {
                        ref: ".uml-state-separator",
                        "ref-x": 5,
                        "ref-y": 5,
                        fill: "#000000",
                        "font-family": "Courier New",
                        "font-size": 14
                    }
                },
                name: "State",
                events: []
            }, {
                markup: [
                    '<g class="rotatable">',
                    '<g class="scalable">',
                    '<rect class="uml-state-body"/>',
                    "</g>",
                    '<path class="uml-state-separator"/>',
                    '<text class="uml-state-name"/>',
                    '<text class="uml-state-events"/>',
                    "</g>"
                ].join(""),
                initialize: function() {
                    this.on({
                        "change:name": this.updateName,
                        "change:events": this.updateEvents,
                        "change:size": this.updatePath
                    }, this), this.updateName(), this.updateEvents(), this.updatePath(), xl.prototype.initialize.apply(this, arguments);
                },
                updateName: function() {
                    this.attr(".uml-state-name/text", this.get("name"));
                },
                updateEvents: function() {
                    this.attr(".uml-state-events/text", this.get("events").join("\n"));
                },
                updatePath: function() {
                    var t = "M 0 20 L " + this.get("size").width + " 20";
                    this.attr(".uml-state-separator/d", t, {
                        silent: !0
                    });
                }
            }),
            StartState: Dl.define("uml.StartState", {
                type: "uml.StartState",
                attrs: {
                    circle: {
                        fill: "#34495e",
                        stroke: "#2c3e50",
                        "stroke-width": 2,
                        rx: 1
                    }
                }
            }),
            EndState: xl.define("uml.EndState", {
                size: {
                    width: 20,
                    height: 20
                },
                attrs: {
                    "circle.outer": {
                        transform: "translate(10, 10)",
                        r: 10,
                        fill: "#ffffff",
                        stroke: "#2c3e50"
                    },
                    "circle.inner": {
                        transform: "translate(10, 10)",
                        r: 6,
                        fill: "#34495e"
                    }
                }
            }, {
                markup: '<g class="rotatable"><g class="scalable"><circle class="outer"/><circle class="inner"/></g></g>'
            }),
            Transition: Sa.define("uml.Transition", {
                attrs: {
                    ".marker-target": {
                        d: "M 10 0 L 0 5 L 10 10 z",
                        fill: "#34495e",
                        stroke: "#2c3e50"
                    },
                    ".connection": {
                        stroke: "#2c3e50"
                    }
                }
            })
        }
    };
    function Ec(t, e) {
        if (0 === e) return "0%";
        return Math.round(t / e * 100000) / 1e3 + "%";
    }
    function Rc(r) {
        return function(t, e, i, n) {
            return (e.isNodeConnection(i) ? Wc : Yc)(r, t, e, i, n);
        };
    }
    function Yc(t, e, i, n, r) {
        var o = i.model.angle(), a = i.getNodeUnrotatedBBox(n), s = i.model.getBBox().center();
        r.rotate(s, o);
        var l = r.x - a.x, c = r.y - a.y;
        return t && (l = Ec(l, a.width), c = Ec(c, a.height)), e.anchor = {
            name: "topLeft",
            args: {
                dx: l,
                dy: c,
                rotate: !0
            }
        }, e;
    }
    function Wc(t, e, i, n, r) {
        var o = i.getConnection();
        if (!o) return e;
        var a = o.closestPointLength(r);
        if (t) {
            var s = o.length();
            e.anchor = {
                name: "connectionRatio",
                args: {
                    ratio: a / s
                }
            };
        } else e.anchor = {
            name: "connectionLength",
            args: {
                length: a
            }
        };
        return e;
    }
    var Uc = Bo, Fc = Rc(!1), Vc = Rc(!0), Xc = {
        useDefaults: Uc,
        pinAbsolute: Fc,
        pinRelative: Vc
    };
    function Hc(t, e, i) {
        return Vc.call(this.paper, {}, e, i, t, this.model).anchor;
    }
    function Jc(t, e) {
        var i = t.model;
        return e ? i.getBBox() : i.isLink() ? t.getConnection().bbox() : t.getNodeUnrotatedBBox(t.el);
    }
    var _c = Za.extend({
        tagName: "circle",
        svgElement: !0,
        className: "marker-vertex",
        events: {
            mousedown: "onPointerDown",
            touchstart: "onPointerDown",
            dblclick: "onDoubleClick",
            dbltap: "onDoubleClick"
        },
        documentEvents: {
            mousemove: "onPointerMove",
            touchmove: "onPointerMove",
            mouseup: "onPointerUp",
            touchend: "onPointerUp",
            touchcancel: "onPointerUp"
        },
        attributes: {
            r: 6,
            fill: "#33334F",
            stroke: "#FFFFFF",
            "stroke-width": 2,
            cursor: "move"
        },
        position: function(t, e) {
            this.vel.attr({
                cx: t,
                cy: e
            });
        },
        onPointerDown: function(t) {
            this.options.guard(t) || (t.stopPropagation(), t.preventDefault(), this.options.paper.undelegateEvents(), this.delegateDocumentEvents(null, t.data), this.trigger("will-change", this, t));
        },
        onPointerMove: function(t) {
            this.trigger("changing", this, t);
        },
        onDoubleClick: function(t) {
            this.trigger("remove", this, t);
        },
        onPointerUp: function(t) {
            this.trigger("changed", this, t), this.undelegateDocumentEvents(), this.options.paper.delegateEvents();
        }
    }), Qc = Cl.extend({
        name: "vertices",
        options: {
            handleClass: _c,
            snapRadius: 20,
            redundancyRemoval: !0,
            vertexAdding: !0,
            stopPropagation: !0
        },
        children: [
            {
                tagName: "path",
                selector: "connection",
                className: "joint-vertices-path",
                attributes: {
                    fill: "none",
                    stroke: "transparent",
                    "stroke-width": 10,
                    cursor: "cell"
                }
            }
        ],
        handles: null,
        events: {
            "mousedown .joint-vertices-path": "onPathPointerDown",
            "touchstart .joint-vertices-path": "onPathPointerDown"
        },
        onRender: function() {
            return this.options.vertexAdding && (this.renderChildren(), this.updatePath()), this.resetHandles(), this.renderHandles(), this;
        },
        update: function() {
            return this.relatedView.model.vertices().length === this.handles.length ? this.updateHandles() : (this.resetHandles(), this.renderHandles()), this.options.vertexAdding && this.updatePath(), this;
        },
        resetHandles: function() {
            var t = this.handles;
            if (this.handles = [], this.stopListening(), Array.isArray(t)) for(var e = 0, i = t.length; e < i; e++)t[e].remove();
        },
        renderHandles: function() {
            for(var e = this, t = this.relatedView.model.vertices(), i = 0, n = t.length; i < n; i++){
                var r = t[i], o = new this.options.handleClass({
                    index: i,
                    paper: this.paper,
                    guard: function(t) {
                        return e.guard(t);
                    }
                });
                o.render(), o.position(r.x, r.y), this.simulateRelatedView(o.el), o.vel.appendTo(this.el), this.handles.push(o), this.startHandleListening(o);
            }
        },
        updateHandles: function() {
            for(var t = this.relatedView.model.vertices(), e = 0, i = t.length; e < i; e++){
                var n = t[e], r = this.handles[e];
                if (!r) return;
                r.position(n.x, n.y);
            }
        },
        updatePath: function() {
            var t = this.childNodes.connection;
            t && t.setAttribute("d", this.relatedView.getSerializedConnection());
        },
        startHandleListening: function(t) {
            var e = this.relatedView;
            e.can("vertexMove") && (this.listenTo(t, "will-change", this.onHandleWillChange), this.listenTo(t, "changing", this.onHandleChanging), this.listenTo(t, "changed", this.onHandleChanged)), e.can("vertexRemove") && this.listenTo(t, "remove", this.onHandleRemove);
        },
        getNeighborPoints: function(t) {
            var e = this.relatedView, i = e.model.vertices(), n = 0 < t ? i[t - 1] : e.sourceAnchor, r = t < i.length - 1 ? i[t + 1] : e.targetAnchor;
            return {
                prev: new qi(n),
                next: new qi(r)
            };
        },
        onHandleWillChange: function(t, e) {
            this.focus();
            var i = this.relatedView, n = this.options;
            i.model.startBatch("vertex-move", {
                ui: !0,
                tool: this.cid
            }), n.stopPropagation || i.notifyPointerdown.apply(i, i.paper.getPointerArgs(e));
        },
        onHandleChanging: function(t, e) {
            var i = this.options, n = this.relatedView, r = t.options.index, o = n.paper.getPointerArgs(e), a = o[0], s = o[1], l = o[2], c = {
                x: s,
                y: l
            };
            this.snapVertex(c, r), n.model.vertex(r, c, {
                ui: !0,
                tool: this.cid
            }), t.position(c.x, c.y), i.stopPropagation || n.notifyPointermove(a, s, l);
        },
        onHandleChanged: function(t, e) {
            var i = this.options, n = this.relatedView;
            if (i.vertexAdding && this.updatePath(), i.redundancyRemoval) {
                n.removeRedundantLinearVertices({
                    ui: !0,
                    tool: this.cid
                }) && this.render(), this.blur(), n.model.stopBatch("vertex-move", {
                    ui: !0,
                    tool: this.cid
                }), this.eventData(e).vertexAdded && n.model.stopBatch("vertex-add", {
                    ui: !0,
                    tool: this.cid
                });
                var r = n.paper.getPointerArgs(e), o = r[0], a = r[1], s = r[2];
                i.stopPropagation || n.notifyPointerup(o, a, s), n.checkMouseleave(o);
            }
        },
        snapVertex: function(t, e) {
            var i = this.options.snapRadius;
            if (0 < i) {
                var n = this.getNeighborPoints(e), r = n.prev, o = n.next;
                Math.abs(t.x - r.x) < i ? t.x = r.x : Math.abs(t.x - o.x) < i && (t.x = o.x), Math.abs(t.y - r.y) < i ? t.y = n.prev.y : Math.abs(t.y - o.y) < i && (t.y = o.y);
            }
        },
        onHandleRemove: function(t, e) {
            var i = t.options.index, n = this.relatedView;
            n.model.removeVertex(i, {
                ui: !0
            }), this.options.vertexAdding && this.updatePath(), n.checkMouseleave(Gr(e));
        },
        onPathPointerDown: function(t) {
            if (!this.guard(t)) {
                t.stopPropagation(), t.preventDefault();
                var e = Gr(t), i = this.paper.snapToGrid(e.clientX, e.clientY).toJSON(), n = this.relatedView;
                n.model.startBatch("vertex-add", {
                    ui: !0,
                    tool: this.cid
                });
                var r = n.getVertexIndex(i.x, i.y);
                this.snapVertex(i, r), n.model.insertVertex(r, i, {
                    ui: !0,
                    tool: this.cid
                }), this.update();
                var o = this.handles[r];
                this.eventData(e, {
                    vertexAdded: !0
                }), o.onPointerDown(e);
            }
        },
        onRemove: function() {
            this.resetHandles();
        }
    }, {
        VertexHandle: _c
    }), Kc = Za.extend({
        tagName: "g",
        svgElement: !0,
        className: "marker-segment",
        events: {
            mousedown: "onPointerDown",
            touchstart: "onPointerDown"
        },
        documentEvents: {
            mousemove: "onPointerMove",
            touchmove: "onPointerMove",
            mouseup: "onPointerUp",
            touchend: "onPointerUp",
            touchcancel: "onPointerUp"
        },
        children: [
            {
                tagName: "line",
                selector: "line",
                attributes: {
                    stroke: "#33334F",
                    "stroke-width": 2,
                    fill: "none",
                    "pointer-events": "none"
                }
            },
            {
                tagName: "rect",
                selector: "handle",
                attributes: {
                    width: 20,
                    height: 8,
                    x: -10,
                    y: -4,
                    rx: 4,
                    ry: 4,
                    fill: "#33334F",
                    stroke: "#FFFFFF",
                    "stroke-width": 2
                }
            }
        ],
        onRender: function() {
            this.renderChildren();
        },
        position: function(t, e, i, n) {
            var r = wr.createSVGMatrix().translate(t, e).rotate(i), o = this.childNodes.handle;
            o.setAttribute("transform", wr.matrixToTransformString(r)), o.setAttribute("cursor", i % 180 == 0 ? "row-resize" : "col-resize");
            var a = n.getClosestPoint(new qi(t, e)), s = this.childNodes.line;
            s.setAttribute("x1", t), s.setAttribute("y1", e), s.setAttribute("x2", a.x), s.setAttribute("y2", a.y);
        },
        onPointerDown: function(t) {
            this.options.guard(t) || (this.trigger("change:start", this, t), t.stopPropagation(), t.preventDefault(), this.options.paper.undelegateEvents(), this.delegateDocumentEvents(null, t.data));
        },
        onPointerMove: function(t) {
            this.trigger("changing", this, t);
        },
        onPointerUp: function(t) {
            this.undelegateDocumentEvents(), this.options.paper.delegateEvents(), this.trigger("change:end", this, t);
        },
        show: function() {
            this.el.style.display = "";
        },
        hide: function() {
            this.el.style.display = "none";
        }
    }), qc = Cl.extend({
        name: "segments",
        precision: .5,
        options: {
            handleClass: Kc,
            segmentLengthThreshold: 40,
            redundancyRemoval: !0,
            anchor: Hc,
            snapRadius: 10,
            snapHandle: !0,
            stopPropagation: !0
        },
        handles: null,
        onRender: function() {
            this.resetHandles();
            var t = this.relatedView, e = t.model.vertices();
            e.unshift(t.sourcePoint), e.push(t.targetPoint);
            for(var i = 0, n = e.length; i < n - 1; i++){
                var r = e[i], o = e[i + 1], a = this.renderHandle(r, o);
                this.simulateRelatedView(a.el), this.handles.push(a), a.options.index = i;
            }
            return this;
        },
        renderHandle: function(t, e) {
            var i = this, n = new this.options.handleClass({
                paper: this.paper,
                guard: function(t) {
                    return i.guard(t);
                }
            });
            return n.render(), this.updateHandle(n, t, e), n.vel.appendTo(this.el), this.startHandleListening(n), n;
        },
        update: function() {
            return this.render(), this;
        },
        startHandleListening: function(t) {
            this.listenTo(t, "change:start", this.onHandleChangeStart), this.listenTo(t, "changing", this.onHandleChanging), this.listenTo(t, "change:end", this.onHandleChangeEnd);
        },
        resetHandles: function() {
            var t = this.handles;
            if (this.handles = [], this.stopListening(), Array.isArray(t)) for(var e = 0, i = t.length; e < i; e++)t[e].remove();
        },
        shiftHandleIndexes: function(t) {
            for(var e = this.handles, i = 0, n = e.length; i < n; i++)e[i].options.index += t;
        },
        resetAnchor: function(t, e) {
            var i = this.relatedView.model;
            e ? i.prop([
                t,
                "anchor"
            ], e, {
                rewrite: !0,
                ui: !0,
                tool: this.cid
            }) : i.removeProp([
                t,
                "anchor"
            ], {
                ui: !0,
                tool: this.cid
            });
        },
        snapHandle: function(t, e, i) {
            var n = t.options.index, r = this.relatedView.model.vertices(), o = t.options.axis, a = r[n - 2] || i.sourceAnchor, s = r[n + 1] || i.targetAnchor, l = this.options.snapRadius;
            return Math.abs(e[o] - a[o]) < l ? e[o] = a[o] : Math.abs(e[o] - s[o]) < l && (e[o] = s[o]), e;
        },
        onHandleChanging: function(t, e) {
            var i = this.options, n = this.eventData(e), r = this.relatedView, o = r.paper, a = t.options.index - 1, s = Gr(e), l = o.snapToGrid(s.clientX, s.clientY), c = this.snapHandle(t, l.clone(), n), u = t.options.axis, h = this.options.snapHandle ? 0 : l[u] - c[u], g = r.model, d = co(g.vertices()), f = d[a], p = d[a + 1], m = this.options.anchor;
            "function" != typeof m && (m = null);
            var I = r.sourceView, v = r.sourceBBox, A = !1, C = !1;
            if (f ? 0 === a ? v.containsPoint(f) ? (d.shift(), this.shiftHandleIndexes(-1), A = !0) : (f[u] = c[u], C = !0) : f[u] = c[u] : ((f = r.sourceAnchor.toJSON())[u] = c[u], v.containsPoint(f) ? (f[u] = c[u], A = !0) : (d.unshift(f), this.shiftHandleIndexes(1), C = !0)), m && I) {
                if (A) {
                    var y = n.sourceAnchor.clone();
                    y[u] = c[u];
                    var w = m.call(r, y, I, r.sourceMagnet || I.el, "source", r);
                    this.resetAnchor("source", w);
                }
                C && this.resetAnchor("source", n.sourceAnchorDef);
            }
            var b = r.targetView, N = r.targetBBox, x = !1, M = !1;
            if (p ? a === d.length - 2 ? N.containsPoint(p) ? (d.pop(), x = !0) : (p[u] = c[u], M = !0) : p[u] = c[u] : ((p = r.targetAnchor.toJSON())[u] = c[u], N.containsPoint(p) ? x = !0 : (d.push(p), M = !0)), m && b) {
                if (x) {
                    var S = n.targetAnchor.clone();
                    S[u] = c[u];
                    var k = m.call(r, S, b, r.targetMagnet || b.el, "target", r);
                    this.resetAnchor("target", k);
                }
                M && this.resetAnchor("target", n.targetAnchorDef);
            }
            g.vertices(d, {
                ui: !0,
                tool: this.cid
            }), this.updateHandle(t, f, p, h), i.stopPropagation || r.notifyPointermove(s, l.x, l.y);
        },
        onHandleChangeStart: function(t, e) {
            var i = this.options, n = this.handles, r = this.relatedView, o = r.model, a = r.paper, s = t.options.index;
            if (Array.isArray(n)) {
                for(var l = 0, c = n.length; l < c; l++)l !== s && n[l].hide();
                this.focus(), this.eventData(e, {
                    sourceAnchor: r.sourceAnchor.clone(),
                    targetAnchor: r.targetAnchor.clone(),
                    sourceAnchorDef: lo(o.prop([
                        "source",
                        "anchor"
                    ])),
                    targetAnchorDef: lo(o.prop([
                        "target",
                        "anchor"
                    ]))
                }), o.startBatch("segment-move", {
                    ui: !0,
                    tool: this.cid
                }), i.stopPropagation || r.notifyPointerdown.apply(r, a.getPointerArgs(e));
            }
        },
        onHandleChangeEnd: function(t, e) {
            var i = this.options, n = this.relatedView, r = n.paper, o = n.model;
            i.redundancyRemoval && n.removeRedundantLinearVertices({
                ui: !0,
                tool: this.cid
            });
            var a = Gr(e), s = r.snapToGrid(a.clientX, a.clientY);
            this.render(), this.blur(), o.stopBatch("segment-move", {
                ui: !0,
                tool: this.cid
            }), i.stopPropagation || n.notifyPointerup(a, s.x, s.y), n.checkMouseleave(a);
        },
        updateHandle: function(t, e, i, n) {
            var r = Math.abs(e.x - i.x) < this.precision, o = Math.abs(e.y - i.y) < this.precision;
            if (r || o) {
                var a = new nn(e, i);
                if (a.length() < this.options.segmentLengthThreshold) t.hide();
                else {
                    var s = a.midpoint(), l = r ? "x" : "y";
                    s[l] += n || 0;
                    var c = a.vector().vectorAngle(new qi(1, 0));
                    t.position(s.x, s.y, c, this.relatedView), t.show(), t.options.axis = l;
                }
            } else t.hide();
        },
        onRemove: function() {
            this.resetHandles();
        }
    }, {
        SegmentHandle: Kc
    }), $c = Cl.extend({
        tagName: "path",
        xAxisVector: new qi(1, 0),
        events: {
            mousedown: "onPointerDown",
            touchstart: "onPointerDown"
        },
        documentEvents: {
            mousemove: "onPointerMove",
            touchmove: "onPointerMove",
            mouseup: "onPointerUp",
            touchend: "onPointerUp",
            touchcancel: "onPointerUp"
        },
        onRender: function() {
            this.update();
        },
        update: function() {
            var t, e, i = this.ratio, n = this.relatedView, r = n.getTangentAtRatio(i);
            if (e = r ? (t = r.start, r.vector().vectorAngle(this.xAxisVector) || 0) : (t = n.getPointAtRatio(i), 0), !t) return this;
            var o = wr.createSVGMatrix().translate(t.x, t.y).rotate(e);
            return this.vel.transform(o, {
                absolute: !0
            }), this;
        },
        onPointerDown: function(t) {
            if (!this.guard(t)) {
                t.stopPropagation(), t.preventDefault();
                var e = this.relatedView;
                e.model.startBatch("arrowhead-move", {
                    ui: !0,
                    tool: this.cid
                }), e.can("arrowheadMove") && (e.startArrowheadMove(this.arrowheadType), this.delegateDocumentEvents(), e.paper.undelegateEvents()), this.focus(), this.el.style.pointerEvents = "none";
            }
        },
        onPointerMove: function(t) {
            var e = Gr(t), i = this.paper.snapToGrid(e.clientX, e.clientY);
            this.relatedView.pointermove(e, i.x, i.y);
        },
        onPointerUp: function(t) {
            this.undelegateDocumentEvents();
            var e = this.relatedView, i = e.paper, n = Gr(t), r = i.snapToGrid(n.clientX, n.clientY);
            e.pointerup(n, r.x, r.y), i.delegateEvents(), this.blur(), this.el.style.pointerEvents = "", e.model.stopBatch("arrowhead-move", {
                ui: !0,
                tool: this.cid
            });
        }
    }), tu = $c.extend({
        name: "target-arrowhead",
        ratio: 1,
        arrowheadType: "target",
        attributes: {
            d: "M -10 -8 10 0 -10 8 Z",
            fill: "#33334F",
            stroke: "#FFFFFF",
            "stroke-width": 2,
            cursor: "move",
            class: "target-arrowhead"
        }
    }), eu = $c.extend({
        name: "source-arrowhead",
        ratio: 0,
        arrowheadType: "source",
        attributes: {
            d: "M 10 -8 -10 0 10 8 Z",
            fill: "#33334F",
            stroke: "#FFFFFF",
            "stroke-width": 2,
            cursor: "move",
            class: "source-arrowhead"
        }
    }), iu = Cl.extend({
        name: "button",
        events: {
            mousedown: "onPointerDown",
            touchstart: "onPointerDown"
        },
        options: {
            distance: 0,
            offset: 0,
            rotate: !1
        },
        onRender: function() {
            this.renderChildren(this.options.markup), this.update();
        },
        update: function() {
            return this.position(), this;
        },
        position: function() {
            var t = this.relatedView, e = this.vel, i = t.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();
            e.transform(i, {
                absolute: !0
            });
        },
        getElementMatrix: function() {
            var t = this.relatedView, e = this.options, i = e.x;
            void 0 === i && (i = 0);
            var n = e.y;
            void 0 === n && (n = 0);
            var r = e.offset;
            void 0 === r && (r = {});
            var o = e.useModelGeometry, a = e.rotate, s = Jc(t, o), l = t.model.angle();
            a || (s = s.bbox(l));
            var c = r.x;
            void 0 === c && (c = 0);
            var u = r.y;
            void 0 === u && (u = 0), Er(i) && (i = parseFloat(i) / 100 * s.width), Er(n) && (n = parseFloat(n) / 100 * s.height);
            var h = wr.createSVGMatrix().translate(s.x + s.width / 2, s.y + s.height / 2);
            return a && (h = h.rotate(l)), h = h.translate(i + c - s.width / 2, n + u - s.height / 2);
        },
        getLinkMatrix: function() {
            var t = this.relatedView, e = this.options, i = e.offset;
            void 0 === i && (i = 0);
            var n = e.distance;
            void 0 === n && (n = 0);
            var r, o, a, s = e.rotate;
            a = (r = Er(n) ? t.getTangentAtRatio(parseFloat(n) / 100) : t.getTangentAtLength(n)) ? (o = r.start, r.vector().vectorAngle(new qi(1, 0)) || 0) : (o = t.getConnection().start, 0);
            var l = wr.createSVGMatrix().translate(o.x, o.y).rotate(a).translate(0, i);
            return s || (l = l.rotate(-a)), l;
        },
        onPointerDown: function(t) {
            if (!this.guard(t)) {
                t.stopPropagation(), t.preventDefault();
                var e = this.options.action;
                "function" == typeof e && e.call(this.relatedView, t, this.relatedView, this);
            }
        }
    }), nu = iu.extend({
        children: [
            {
                tagName: "circle",
                selector: "button",
                attributes: {
                    r: 7,
                    fill: "#FF1D00",
                    cursor: "pointer"
                }
            },
            {
                tagName: "path",
                selector: "icon",
                attributes: {
                    d: "M -3 -3 3 3 M -3 3 3 -3",
                    fill: "none",
                    stroke: "#FFFFFF",
                    "stroke-width": 2,
                    "pointer-events": "none"
                }
            }
        ],
        options: {
            distance: 60,
            offset: 0,
            action: function(t, e, i) {
                e.model.remove({
                    ui: !0,
                    tool: i.cid
                });
            }
        }
    }), ru = iu.extend({
        name: "connect",
        documentEvents: {
            mousemove: "drag",
            touchmove: "drag",
            mouseup: "dragend",
            touchend: "dragend",
            touchcancel: "dragend"
        },
        children: [
            {
                tagName: "circle",
                selector: "button",
                attributes: {
                    r: 7,
                    fill: "#333333",
                    cursor: "pointer"
                }
            },
            {
                tagName: "path",
                selector: "icon",
                attributes: {
                    d: "M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z",
                    fill: "#FFFFFF",
                    stroke: "none",
                    "stroke-width": 2,
                    "pointer-events": "none"
                }
            }
        ],
        options: {
            distance: 80,
            offset: 0,
            magnet: function(t) {
                return t.el;
            },
            action: function(t, e, i) {
                return i.dragstart(t);
            }
        },
        getMagnetNode: function() {
            var t, e = this.options, i = this.relatedView, n = e.magnet;
            switch(typeof n){
                case "function":
                    t = n.call(this, i, this);
                    break;
                case "string":
                    t = i.findBySelector(n)[0];
                    break;
                default:
                    t = n;
            }
            if (t || (t = i.el), t instanceof SVGElement) return t;
            throw new Error("Connect: magnet must be an SVGElement");
        },
        dragstart: function(t) {
            var e = this.paper, i = this.relatedView, n = Gr(t), r = e.clientToLocalPoint(n.clientX, n.clientY), o = r.x, a = r.y;
            i.dragLinkStart(n, this.getMagnetNode(), o, a), e.undelegateEvents(), this.delegateDocumentEvents(null, t.data), this.focus();
        },
        drag: function(t) {
            var e = this.paper, i = this.relatedView, n = Gr(t), r = e.snapToGrid(n.clientX, n.clientY), o = r.x, a = r.y;
            i.dragLink(n, o, a);
        },
        dragend: function(t) {
            var e = this.paper, i = this.relatedView, n = Gr(t), r = e.snapToGrid(n.clientX, n.clientY), o = r.x, a = r.y;
            i.dragLinkEnd(n, o, a), this.undelegateDocumentEvents(), e.delegateEvents(), this.blur(), i.checkMouseleave(n);
        }
    }), ou = Cl.extend({
        name: "boundary",
        tagName: "rect",
        options: {
            padding: 10,
            useModelGeometry: !1
        },
        attributes: {
            fill: "none",
            stroke: "#33334F",
            "stroke-width": .5,
            "stroke-dasharray": "5, 5",
            "pointer-events": "none"
        },
        onRender: function() {
            this.update();
        },
        update: function() {
            var t = this.relatedView, e = this.options, i = this.vel, n = e.useModelGeometry, r = e.rotate, o = Xr(e.padding), a = Jc(t, n).moveAndExpand({
                x: -o.left,
                y: -o.top,
                width: o.left + o.right,
                height: o.top + o.bottom
            }), s = t.model;
            if (s.isElement()) {
                var l = s.angle();
                if (l) {
                    if (r) {
                        var c = s.getBBox().center();
                        i.rotate(l, c.x, c.y, {
                            absolute: !0
                        });
                    } else a = a.bbox(l);
                }
            }
            return i.attr(a.toJSON()), this;
        }
    }), au = Cl.extend({
        tagName: "g",
        type: null,
        children: [
            {
                tagName: "circle",
                selector: "anchor",
                attributes: {
                    cursor: "pointer"
                }
            },
            {
                tagName: "rect",
                selector: "area",
                attributes: {
                    "pointer-events": "none",
                    fill: "none",
                    stroke: "#33334F",
                    "stroke-dasharray": "2,4",
                    rx: 5,
                    ry: 5
                }
            }
        ],
        events: {
            mousedown: "onPointerDown",
            touchstart: "onPointerDown",
            dblclick: "onPointerDblClick",
            dbltap: "onPointerDblClick"
        },
        documentEvents: {
            mousemove: "onPointerMove",
            touchmove: "onPointerMove",
            mouseup: "onPointerUp",
            touchend: "onPointerUp",
            touchcancel: "onPointerUp"
        },
        options: {
            snap: function(t, e, i, n, r, o) {
                var a = o.options.snapRadius, s = "source" === n, l = s ? 0 : -1, c = this.model.vertex(l) || this.getEndAnchor(s ? "target" : "source");
                return c && (Math.abs(c.x - t.x) < a && (t.x = c.x), Math.abs(c.y - t.y) < a && (t.y = c.y)), t;
            },
            anchor: Hc,
            resetAnchor: !0,
            customAnchorAttributes: {
                "stroke-width": 4,
                stroke: "#33334F",
                fill: "#FFFFFF",
                r: 5
            },
            defaultAnchorAttributes: {
                "stroke-width": 2,
                stroke: "#FFFFFF",
                fill: "#33334F",
                r: 6
            },
            areaPadding: 6,
            snapRadius: 10,
            restrictArea: !0,
            redundancyRemoval: !0
        },
        onRender: function() {
            this.renderChildren(), this.toggleArea(!1), this.update();
        },
        update: function() {
            var t = this.type;
            return this.relatedView.getEndView(t) ? (this.updateAnchor(), this.updateArea(), this.el.style.display = "") : this.el.style.display = "none", this;
        },
        updateAnchor: function() {
            var t = this.childNodes;
            if (t) {
                var e = t.anchor;
                if (e) {
                    var i = this.relatedView, n = this.type, r = i.getEndAnchor(n), o = this.options, a = i.model.prop([
                        n,
                        "anchor"
                    ]);
                    e.setAttribute("transform", "translate(" + r.x + "," + r.y + ")");
                    var s = a ? o.customAnchorAttributes : o.defaultAnchorAttributes;
                    for(var l in s)e.setAttribute(l, s[l]);
                }
            }
        },
        updateArea: function() {
            var t = this.childNodes;
            if (t) {
                var e = t.area;
                if (e) {
                    var i, n, r, o = this.relatedView, a = this.type, s = o.getEndView(a), l = s.model, c = o.getEndMagnet(a), u = this.options.areaPadding;
                    isFinite(u) || (u = 0), s.isNodeConnection(c) ? (n = 0, r = (i = s.getBBox()).center()) : (i = s.getNodeUnrotatedBBox(c), n = l.angle(), r = i.center(), n && r.rotate(l.getBBox().center(), -n)), i.inflate(u), e.setAttribute("x", -i.width / 2), e.setAttribute("y", -i.height / 2), e.setAttribute("width", i.width), e.setAttribute("height", i.height), e.setAttribute("transform", "translate(" + r.x + "," + r.y + ") rotate(" + n + ")");
                }
            }
        },
        toggleArea: function(t) {
            this.childNodes.area.style.display = t ? "" : "none";
        },
        onPointerDown: function(t) {
            this.guard(t) || (t.stopPropagation(), t.preventDefault(), this.paper.undelegateEvents(), this.delegateDocumentEvents(), this.focus(), this.toggleArea(this.options.restrictArea), this.relatedView.model.startBatch("anchor-move", {
                ui: !0,
                tool: this.cid
            }));
        },
        resetAnchor: function(t) {
            var e = this.type, i = this.relatedView.model;
            t ? i.prop([
                e,
                "anchor"
            ], t, {
                rewrite: !0,
                ui: !0,
                tool: this.cid
            }) : i.removeProp([
                e,
                "anchor"
            ], {
                ui: !0,
                tool: this.cid
            });
        },
        onPointerMove: function(t) {
            var e, i = this.relatedView, n = this.type, r = i.getEndView(n), o = r.model, a = i.getEndMagnet(n), s = Gr(t), l = this.paper.clientToLocalPoint(s.clientX, s.clientY), c = this.options.snap;
            if ("function" == typeof c && (l = c.call(i, l, r, a, n, i, this), l = new qi(l)), this.options.restrictArea) {
                if (r.isNodeConnection(a)) {
                    var u = r.getClosestPoint(l);
                    u && (l = u);
                } else {
                    var h = r.getNodeUnrotatedBBox(a), g = o.angle(), d = o.getBBox().center(), f = l.clone().rotate(d, g);
                    h.containsPoint(f) || (l = h.pointNearestToPoint(f).rotate(d, -g));
                }
            }
            var p = this.options.anchor;
            "function" == typeof p && (e = p.call(i, l, r, a, n, i)), this.resetAnchor(e), this.update();
        },
        onPointerUp: function(t) {
            this.paper.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleArea(!1);
            var e = this.relatedView;
            this.options.redundancyRemoval && e.removeRedundantLinearVertices({
                ui: !0,
                tool: this.cid
            }), e.model.stopBatch("anchor-move", {
                ui: !0,
                tool: this.cid
            });
        },
        onPointerDblClick: function() {
            var t = this.options.resetAnchor;
            !1 !== t && (!0 === t && (t = null), this.resetAnchor(co(t)), this.update());
        }
    }), su = {
        Vertices: Qc,
        Segments: qc,
        SourceArrowhead: eu,
        TargetArrowhead: tu,
        SourceAnchor: au.extend({
            name: "source-anchor",
            type: "source"
        }),
        TargetAnchor: au.extend({
            name: "target-anchor",
            type: "target"
        }),
        Button: iu,
        Remove: nu,
        Connect: ru,
        Boundary: ou
    }, lu = {
        Button: iu,
        Remove: nu,
        Connect: ru,
        Boundary: ou,
        Control: Cl.extend({
            tagName: "g",
            children: [
                {
                    tagName: "circle",
                    selector: "handle",
                    attributes: {
                        cursor: "pointer",
                        "stroke-width": 2,
                        stroke: "#FFFFFF",
                        fill: "#33334F",
                        r: 6
                    }
                },
                {
                    tagName: "rect",
                    selector: "extras",
                    attributes: {
                        "pointer-events": "none",
                        fill: "none",
                        stroke: "#33334F",
                        "stroke-dasharray": "2,4",
                        rx: 5,
                        ry: 5
                    }
                }
            ],
            events: {
                mousedown: "onPointerDown",
                touchstart: "onPointerDown",
                dblclick: "onPointerDblClick",
                dbltap: "onPointerDblClick"
            },
            documentEvents: {
                mousemove: "onPointerMove",
                touchmove: "onPointerMove",
                mouseup: "onPointerUp",
                touchend: "onPointerUp",
                touchcancel: "onPointerUp"
            },
            options: {
                handleAttributes: null,
                selector: "root",
                padding: 6
            },
            getPosition: function() {},
            setPosition: function() {},
            resetPosition: function() {},
            onRender: function() {
                this.renderChildren(), this.toggleExtras(!1), this.update();
            },
            update: function() {
                var t = this.childNodes, e = t.handle, i = t.extras;
                if (!e) throw new Error("Control: markup selector `handle` is required");
                return this.updateHandle(e), i && this.updateExtras(i), this;
            },
            updateHandle: function(t) {
                var e = this.relatedView, i = this.options, n = e.model, r = this.getPosition(e, this), o = n.getAbsolutePointFromRelative(r);
                t.setAttribute("transform", "translate(" + o.x + "," + o.y + ")");
                var a = i.handleAttributes;
                if (a) for(var s in a)t.setAttribute(s, a[s]);
            },
            updateExtras: function(t) {
                var e = this.relatedView, i = this.options, n = this.options.selector;
                if (n) {
                    var r = e.findBySelector(n)[0];
                    if (!r) throw new Error("Control: invalid selector.");
                    var o = i.padding;
                    isFinite(o) || (o = 0);
                    var a = e.getNodeUnrotatedBBox(r), s = e.model, l = s.angle(), c = a.center();
                    l && c.rotate(s.getBBox().center(), -l), a.inflate(o), t.setAttribute("x", -a.width / 2), t.setAttribute("y", -a.height / 2), t.setAttribute("width", a.width), t.setAttribute("height", a.height), t.setAttribute("transform", "translate(" + c.x + "," + c.y + ") rotate(" + l + ")");
                } else this.toggleExtras(!1);
            },
            toggleExtras: function(t) {
                var e = this.childNodes.extras;
                e && (e.style.display = t ? "" : "none");
            },
            onPointerDown: function(t) {
                var e = this.relatedView, i = this.paper;
                this.guard(t) || (t.stopPropagation(), t.preventDefault(), i.undelegateEvents(), this.delegateDocumentEvents(), this.focus(), this.toggleExtras(!0), e.model.startBatch("control-move", {
                    ui: !0,
                    tool: this.cid
                }));
            },
            onPointerMove: function(t) {
                var e = this.relatedView, i = this.paper, n = e.model, r = Gr(t), o = r.clientX, a = r.clientY, s = i.clientToLocalPoint(o, a), l = n.getRelativePointFromAbsolute(s);
                this.setPosition(e, l, this), this.update();
            },
            onPointerUp: function(t) {
                var e = this.relatedView;
                this.paper.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleExtras(!1), e.model.stopBatch("control-move", {
                    ui: !0,
                    tool: this.cid
                });
            },
            onPointerDblClick: function() {
                var t = this.relatedView;
                this.resetPosition(t, this), this.update();
            }
        })
    }, cu = wr, uu = {
        DirectedGraph: bl,
        PortLabel: Ma,
        Port: Ca
    };
    t.V = wr, t.Vectorizer = cu, t.anchors = dl, t.config = br, t.connectionPoints = hl, t.connectionStrategies = Xc, t.connectors = Hs, t.dia = wl, t.elementTools = lu, t.env = Nl, t.format = {}, t.g = yr, t.highlighters = tl, t.layout = uu, t.linkAnchors = ol, t.linkTools = su, t.mvc = Ba, t.routers = Ss, t.setTheme = function(t, e) {
        oo(ja, "setTheme", t, e = e || {}), Za.prototype.defaultTheme = t;
    }, t.shapes = Oc, t.ui = {}, t.util = pa, t.version = "3.5.5", Object.defineProperty(t, "__esModule", {
        value: !0
    });
}), "undefined" != typeof joint) var g = joint.g, V = joint.V, Vectorizer = joint.V;

},{"/js/lib/backbone.js/backbone.min":"iT7LQ","/js/lib/lodash.js/lodash.min":"jqSAO","/js/lib/jquery/jquery.min":"4QkNZ"}],"iT7LQ":[function(require,module,exports) {
var global = arguments[3];
!function(n) {
    var s = "object" == typeof self && self.self === self && self || "object" == typeof global && global.global === global && global;
    if ("function" == typeof define && define.amd) define([
        "underscore",
        "jquery",
        "exports"
    ], function(t, e, i) {
        s.Backbone = n(s, i, t, e);
    });
    else {
        var t, e = require("/js/lib/underscore/underscore-umd-min");
        try {
            t = require("/js/lib/jquery/jquery.min");
        } catch (t1) {}
        n(s, exports, e, t);
    }
}(function(t, h, b, e) {
    var i = t.Backbone, o = Array.prototype.slice;
    h.VERSION = "1.4.1", h.$ = e, h.noConflict = function() {
        return t.Backbone = i, this;
    }, h.emulateHTTP = !1, h.emulateJSON = !1;
    function a(t, e, i, n, s) {
        var r, o = 0;
        if (i && "object" == typeof i) {
            void 0 !== n && "context" in s && void 0 === s.context && (s.context = n);
            for(r = b.keys(i); o < r.length; o++)e = a(t, e, r[o], i[r[o]], s);
        } else if (i && c.test(i)) for(r = i.split(c); o < r.length; o++)e = t(e, r[o], n, s);
        else e = t(e, i, n, s);
        return e;
    }
    var u, n = h.Events = {}, c = /\s+/;
    n.on = function(t, e, i) {
        return this._events = a(s, this._events || {}, t, e, {
            context: i,
            ctx: this,
            listening: u
        }), u && (((this._listeners || (this._listeners = {}))[u.id] = u).interop = !1), this;
    }, n.listenTo = function(t, e, i) {
        if (!t) return this;
        var n = t._listenId || (t._listenId = b.uniqueId("l")), s = this._listeningTo || (this._listeningTo = {}), r = u = s[n];
        r || (this._listenId || (this._listenId = b.uniqueId("l")), r = u = s[n] = new g(this, t));
        t = l(t, e, i, this);
        if (u = void 0, t) throw t;
        return r.interop && r.on(e, i), this;
    };
    var s = function(t, e, i, n) {
        var s, r;
        return i && (s = t[e] || (t[e] = []), r = n.context, e = n.ctx, (n = n.listening) && n.count++, s.push({
            callback: i,
            context: r,
            ctx: r || e,
            listening: n
        })), t;
    }, l = function(t, e, i, n) {
        try {
            t.on(e, i, n);
        } catch (t1) {
            return t1;
        }
    };
    n.off = function(t, e, i) {
        return this._events && (this._events = a(r, this._events, t, e, {
            context: i,
            listeners: this._listeners
        })), this;
    }, n.stopListening = function(t, e, i) {
        var n = this._listeningTo;
        if (!n) return this;
        for(var s = t ? [
            t._listenId
        ] : b.keys(n), r = 0; r < s.length; r++){
            var o = n[s[r]];
            if (!o) break;
            o.obj.off(e, i, this), o.interop && o.off(e, i);
        }
        return b.isEmpty(n) && (this._listeningTo = void 0), this;
    };
    var r = function(t, e, i, n) {
        if (t) {
            var s, r = n.context, o = n.listeners, h = 0;
            if (e || r || i) {
                for(s = e ? [
                    e
                ] : b.keys(t); h < s.length; h++){
                    var a = t[e = s[h]];
                    if (!a) break;
                    for(var u = [], c = 0; c < a.length; c++){
                        var l = a[c];
                        i && i !== l.callback && i !== l.callback._callback || r && r !== l.context ? u.push(l) : (l = l.listening) && l.off(e, i);
                    }
                    u.length ? t[e] = u : delete t[e];
                }
                return t;
            }
            for(s = b.keys(o); h < s.length; h++)o[s[h]].cleanup();
        }
    };
    n.once = function(t, e, i) {
        var n = a(d, {}, t, e, this.off.bind(this));
        return this.on(n, e = "string" == typeof t && null == i ? void 0 : e, i);
    }, n.listenToOnce = function(t, e, i) {
        i = a(d, {}, e, i, this.stopListening.bind(this, t));
        return this.listenTo(t, i);
    };
    var d = function(t, e, i, n) {
        var s;
        return i && ((s = t[e] = b.once(function() {
            n(e, s), i.apply(this, arguments);
        }))._callback = i), t;
    };
    n.trigger = function(t) {
        if (!this._events) return this;
        for(var e = Math.max(0, arguments.length - 1), i = Array(e), n = 0; n < e; n++)i[n] = arguments[n + 1];
        return a(f, this._events, t, void 0, i), this;
    };
    var f = function(t, e, i, n) {
        var s, r;
        return t && (s = t[e], r = t.all, s && r && (r = r.slice()), s && p(s, n), r && p(r, [
            e
        ].concat(n))), t;
    }, p = function(t, e) {
        var i, n = -1, s = t.length, r = e[0], o = e[1], h = e[2];
        switch(e.length){
            case 0:
                for(; ++n < s;)(i = t[n]).callback.call(i.ctx);
                return;
            case 1:
                for(; ++n < s;)(i = t[n]).callback.call(i.ctx, r);
                return;
            case 2:
                for(; ++n < s;)(i = t[n]).callback.call(i.ctx, r, o);
                return;
            case 3:
                for(; ++n < s;)(i = t[n]).callback.call(i.ctx, r, o, h);
                return;
            default:
                for(; ++n < s;)(i = t[n]).callback.apply(i.ctx, e);
                return;
        }
    }, g = function(t, e) {
        this.id = t._listenId, this.listener = t, this.obj = e, this.interop = !0, this.count = 0, this._events = void 0;
    };
    g.prototype.on = n.on, g.prototype.off = function(t, e) {
        e = this.interop ? (this._events = a(r, this._events, t, e, {
            context: void 0,
            listeners: void 0
        }), !this._events) : (this.count--, 0 === this.count);
        e && this.cleanup();
    }, g.prototype.cleanup = function() {
        delete this.listener._listeningTo[this.obj._listenId], this.interop || delete this.obj._listeners[this.id];
    }, n.bind = n.on, n.unbind = n.off, b.extend(h, n);
    var v = h.Model = function(t, e) {
        var i = t || {};
        e = e || {}, this.preinitialize.apply(this, arguments), this.cid = b.uniqueId(this.cidPrefix), this.attributes = {}, e.collection && (this.collection = e.collection), e.parse && (i = this.parse(i, e) || {});
        var n = b.result(this, "defaults"), i = b.defaults(b.extend({}, n, i), n);
        this.set(i, e), this.changed = {}, this.initialize.apply(this, arguments);
    };
    b.extend(v.prototype, n, {
        changed: null,
        validationError: null,
        idAttribute: "id",
        cidPrefix: "c",
        preinitialize: function() {},
        initialize: function() {},
        toJSON: function(t) {
            return b.clone(this.attributes);
        },
        sync: function() {
            return h.sync.apply(this, arguments);
        },
        get: function(t) {
            return this.attributes[t];
        },
        escape: function(t) {
            return b.escape(this.get(t));
        },
        has: function(t) {
            return null != this.get(t);
        },
        matches: function(t) {
            return !!b.iteratee(t, this)(this.attributes);
        },
        set: function(t, e, i) {
            if (null == t) return this;
            var n;
            if ("object" == typeof t ? (n = t, i = e) : (n = {})[t] = e, !this._validate(n, i = i || {})) return !1;
            var s = i.unset, r = i.silent, o = [], h = this._changing;
            this._changing = !0, h || (this._previousAttributes = b.clone(this.attributes), this.changed = {});
            var a, u = this.attributes, c = this.changed, l = this._previousAttributes;
            for(a in n)e = n[a], b.isEqual(u[a], e) || o.push(a), b.isEqual(l[a], e) ? delete c[a] : c[a] = e, s ? delete u[a] : u[a] = e;
            if (this.idAttribute in n && (t = this.id, this.id = this.get(this.idAttribute), this.trigger("changeId", this, t, i)), !r) {
                o.length && (this._pending = i);
                for(var d = 0; d < o.length; d++)this.trigger("change:" + o[d], this, u[o[d]], i);
            }
            if (h) return this;
            if (!r) for(; this._pending;)i = this._pending, this._pending = !1, this.trigger("change", this, i);
            return this._pending = !1, this._changing = !1, this;
        },
        unset: function(t, e) {
            return this.set(t, void 0, b.extend({}, e, {
                unset: !0
            }));
        },
        clear: function(t) {
            var e, i = {};
            for(e in this.attributes)i[e] = void 0;
            return this.set(i, b.extend({}, t, {
                unset: !0
            }));
        },
        hasChanged: function(t) {
            return null == t ? !b.isEmpty(this.changed) : b.has(this.changed, t);
        },
        changedAttributes: function(t) {
            if (!t) return !!this.hasChanged() && b.clone(this.changed);
            var e, i, n = this._changing ? this._previousAttributes : this.attributes, s = {};
            for(i in t){
                var r = t[i];
                b.isEqual(n[i], r) || (s[i] = r, e = !0);
            }
            return !!e && s;
        },
        previous: function(t) {
            return null != t && this._previousAttributes ? this._previousAttributes[t] : null;
        },
        previousAttributes: function() {
            return b.clone(this._previousAttributes);
        },
        fetch: function(i) {
            i = b.extend({
                parse: !0
            }, i);
            var n = this, s = i.success;
            return i.success = function(t) {
                var e = i.parse ? n.parse(t, i) : t;
                if (!n.set(e, i)) return !1;
                s && s.call(i.context, n, t, i), n.trigger("sync", n, t, i);
            }, F(this, i), this.sync("read", this, i);
        },
        save: function(t, e, i) {
            var n;
            null == t || "object" == typeof t ? (n = t, i = e) : (n = {})[t] = e;
            var s = (i = b.extend({
                validate: !0,
                parse: !0
            }, i)).wait;
            if (n && !s) {
                if (!this.set(n, i)) return !1;
            } else if (!this._validate(n, i)) return !1;
            var r = this, o = i.success, h = this.attributes;
            i.success = function(t) {
                r.attributes = h;
                var e = i.parse ? r.parse(t, i) : t;
                if ((e = s ? b.extend({}, n, e) : e) && !r.set(e, i)) return !1;
                o && o.call(i.context, r, t, i), r.trigger("sync", r, t, i);
            }, F(this, i), n && s && (this.attributes = b.extend({}, h, n));
            e = this.isNew() ? "create" : i.patch ? "patch" : "update";
            "patch" != e || i.attrs || (i.attrs = n);
            e = this.sync(e, this, i);
            return this.attributes = h, e;
        },
        destroy: function(e) {
            e = e ? b.clone(e) : {};
            function i() {
                n.stopListening(), n.trigger("destroy", n, n.collection, e);
            }
            var n = this, s = e.success, r = e.wait, t = (e.success = function(t) {
                r && i(), s && s.call(e.context, n, t, e), n.isNew() || n.trigger("sync", n, t, e);
            }, false);
            return this.isNew() ? b.defer(e.success) : (F(this, e), t = this.sync("delete", this, e)), r || i(), t;
        },
        url: function() {
            var t = b.result(this, "urlRoot") || b.result(this.collection, "url") || q();
            if (this.isNew()) return t;
            var e = this.get(this.idAttribute);
            return t.replace(/[^\/]$/, "$&/") + encodeURIComponent(e);
        },
        parse: function(t, e) {
            return t;
        },
        clone: function() {
            return new this.constructor(this.attributes);
        },
        isNew: function() {
            return !this.has(this.idAttribute);
        },
        isValid: function(t) {
            return this._validate({}, b.extend({}, t, {
                validate: !0
            }));
        },
        _validate: function(t, e) {
            if (!e.validate || !this.validate) return !0;
            t = b.extend({}, this.attributes, t);
            t = this.validationError = this.validate(t, e) || null;
            return !t || (this.trigger("invalid", this, t, b.extend(e, {
                validationError: t
            })), !1);
        }
    });
    function x(t, e, i) {
        i = Math.min(Math.max(i, 0), t.length);
        for(var n = Array(t.length - i), s = e.length, r = 0; r < n.length; r++)n[r] = t[r + i];
        for(r = 0; r < s; r++)t[r + i] = e[r];
        for(r = 0; r < n.length; r++)t[r + s + i] = n[r];
    }
    var m = h.Collection = function(t, e) {
        e = e || {}, this.preinitialize.apply(this, arguments), e.model && (this.model = e.model), void 0 !== e.comparator && (this.comparator = e.comparator), this._reset(), this.initialize.apply(this, arguments), t && this.reset(t, b.extend({
            silent: !0
        }, e));
    }, w = {
        add: !0,
        remove: !0,
        merge: !0
    }, _ = {
        add: !0,
        remove: !1
    };
    b.extend(m.prototype, n, {
        model: v,
        preinitialize: function() {},
        initialize: function() {},
        toJSON: function(e) {
            return this.map(function(t) {
                return t.toJSON(e);
            });
        },
        sync: function() {
            return h.sync.apply(this, arguments);
        },
        add: function(t, e) {
            return this.set(t, b.extend({
                merge: !1
            }, e, _));
        },
        remove: function(t, e) {
            e = b.extend({}, e);
            var i = !b.isArray(t);
            t = i ? [
                t
            ] : t.slice();
            t = this._removeModels(t, e);
            return !e.silent && t.length && (e.changes = {
                added: [],
                merged: [],
                removed: t
            }, this.trigger("update", this, e)), i ? t[0] : t;
        },
        set: function(t, e) {
            if (null != t) {
                (e = b.extend({}, w, e)).parse && !this._isModel(t) && (t = this.parse(t, e) || []);
                var i = !b.isArray(t);
                t = i ? [
                    t
                ] : t.slice();
                var n = e.at;
                (n = (n = null != n ? +n : n) > this.length ? this.length : n) < 0 && (n += this.length + 1);
                for(var s = [], r = [], o = [], h = [], a = {}, u = e.add, c = e.merge, l = e.remove, d = !1, f = this.comparator && null == n && !1 !== e.sort, p = b.isString(this.comparator) ? this.comparator : null, g = 0; g < t.length; g++){
                    var v, m = t[g], _ = this.get(m);
                    _ ? (c && m !== _ && (v = this._isModel(m) ? m.attributes : m, e.parse && (v = _.parse(v, e)), _.set(v, e), o.push(_), f && !d && (d = _.hasChanged(p))), a[_.cid] || (a[_.cid] = !0, s.push(_)), t[g] = _) : u && (m = t[g] = this._prepareModel(m, e)) && (r.push(m), this._addReference(m, e), a[m.cid] = !0, s.push(m));
                }
                if (l) {
                    for(g = 0; g < this.length; g++)a[(m = this.models[g]).cid] || h.push(m);
                    h.length && this._removeModels(h, e);
                }
                var y = !1;
                if (s.length && !f && u && l ? (y = this.length !== s.length || b.some(this.models, function(t, e) {
                    return t !== s[e];
                }), this.models.length = 0, x(this.models, s, 0), this.length = this.models.length) : r.length && (f && (d = !0), x(this.models, r, null == n ? this.length : n), this.length = this.models.length), d && this.sort({
                    silent: !0
                }), !e.silent) {
                    for(g = 0; g < r.length; g++)null != n && (e.index = n + g), (m = r[g]).trigger("add", m, this, e);
                    (d || y) && this.trigger("sort", this, e), (r.length || h.length || o.length) && (e.changes = {
                        added: r,
                        removed: h,
                        merged: o
                    }, this.trigger("update", this, e));
                }
                return i ? t[0] : t;
            }
        },
        reset: function(t, e) {
            e = e ? b.clone(e) : {};
            for(var i = 0; i < this.models.length; i++)this._removeReference(this.models[i], e);
            return e.previousModels = this.models, this._reset(), t = this.add(t, b.extend({
                silent: !0
            }, e)), e.silent || this.trigger("reset", this, e), t;
        },
        push: function(t, e) {
            return this.add(t, b.extend({
                at: this.length
            }, e));
        },
        pop: function(t) {
            var e = this.at(this.length - 1);
            return this.remove(e, t);
        },
        unshift: function(t, e) {
            return this.add(t, b.extend({
                at: 0
            }, e));
        },
        shift: function(t) {
            var e = this.at(0);
            return this.remove(e, t);
        },
        slice: function() {
            return o.apply(this.models, arguments);
        },
        get: function(t) {
            if (null != t) return this._byId[t] || this._byId[this.modelId(this._isModel(t) ? t.attributes : t, t.idAttribute)] || t.cid && this._byId[t.cid];
        },
        has: function(t) {
            return null != this.get(t);
        },
        at: function(t) {
            return t < 0 && (t += this.length), this.models[t];
        },
        where: function(t, e) {
            return this[e ? "find" : "filter"](t);
        },
        findWhere: function(t) {
            return this.where(t, !0);
        },
        sort: function(t) {
            var e = this.comparator;
            if (!e) throw new Error("Cannot sort a set without a comparator");
            t = t || {};
            var i = e.length;
            return b.isFunction(e) && (e = e.bind(this)), 1 === i || b.isString(e) ? this.models = this.sortBy(e) : this.models.sort(e), t.silent || this.trigger("sort", this, t), this;
        },
        pluck: function(t) {
            return this.map(t + "");
        },
        fetch: function(i) {
            var n = (i = b.extend({
                parse: !0
            }, i)).success, s = this;
            return i.success = function(t) {
                var e = i.reset ? "reset" : "set";
                s[e](t, i), n && n.call(i.context, s, t, i), s.trigger("sync", s, t, i);
            }, F(this, i), this.sync("read", this, i);
        },
        create: function(t, e) {
            var n = (e = e ? b.clone(e) : {}).wait;
            if (!(t = this._prepareModel(t, e))) return !1;
            n || this.add(t, e);
            var s = this, r = e.success;
            return e.success = function(t, e, i) {
                n && s.add(t, i), r && r.call(i.context, t, e, i);
            }, t.save(null, e), t;
        },
        parse: function(t, e) {
            return t;
        },
        clone: function() {
            return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator
            });
        },
        modelId: function(t, e) {
            return t[e || this.model.prototype.idAttribute || "id"];
        },
        values: function() {
            return new E(this, I);
        },
        keys: function() {
            return new E(this, k);
        },
        entries: function() {
            return new E(this, S);
        },
        _reset: function() {
            this.length = 0, this.models = [], this._byId = {};
        },
        _prepareModel: function(t, e) {
            return this._isModel(t) ? (t.collection || (t.collection = this), t) : (t = ((e = e ? b.clone(e) : {}).collection = this).model.prototype ? new this.model(t, e) : this.model(t, e)).validationError ? (this.trigger("invalid", this, t.validationError, e), !1) : t;
        },
        _removeModels: function(t, e) {
            for(var i = [], n = 0; n < t.length; n++){
                var s, r, o = this.get(t[n]);
                o && (s = this.indexOf(o), this.models.splice(s, 1), this.length--, delete this._byId[o.cid], null != (r = this.modelId(o.attributes, o.idAttribute)) && delete this._byId[r], e.silent || (e.index = s, o.trigger("remove", o, this, e)), i.push(o), this._removeReference(o, e));
            }
            return i;
        },
        _isModel: function(t) {
            return t instanceof v;
        },
        _addReference: function(t, e) {
            this._byId[t.cid] = t;
            var i = this.modelId(t.attributes, t.idAttribute);
            null != i && (this._byId[i] = t), t.on("all", this._onModelEvent, this);
        },
        _removeReference: function(t, e) {
            delete this._byId[t.cid];
            var i = this.modelId(t.attributes, t.idAttribute);
            null != i && delete this._byId[i], this === t.collection && delete t.collection, t.off("all", this._onModelEvent, this);
        },
        _onModelEvent: function(t, e, i, n) {
            if (e) {
                if (("add" === t || "remove" === t) && i !== this) return;
                var s, r;
                "destroy" === t && this.remove(e, n), "changeId" === t && (s = this.modelId(e.previousAttributes(), e.idAttribute), r = this.modelId(e.attributes, e.idAttribute), null != s && delete this._byId[s], null != r && (this._byId[r] = e));
            }
            this.trigger.apply(this, arguments);
        }
    });
    var y = "function" == typeof Symbol && Symbol.iterator;
    y && (m.prototype[y] = m.prototype.values);
    var E = function(t, e) {
        this._collection = t, this._kind = e, this._index = 0;
    }, I = 1, k = 2, S = 3;
    y && (E.prototype[y] = function() {
        return this;
    }), E.prototype.next = function() {
        if (this._collection) {
            if (this._index < this._collection.length) {
                var t, e = this._collection.at(this._index);
                return this._index++, {
                    value: this._kind === I ? e : (t = this._collection.modelId(e.attributes, e.idAttribute), this._kind === k ? t : [
                        t,
                        e
                    ]),
                    done: !1
                };
            }
            this._collection = void 0;
        }
        return {
            value: void 0,
            done: !0
        };
    };
    var e = h.View = function(t) {
        this.cid = b.uniqueId("view"), this.preinitialize.apply(this, arguments), b.extend(this, b.pick(t, T)), this._ensureElement(), this.initialize.apply(this, arguments);
    }, A = /^(\S+)\s*(.*)$/, T = [
        "model",
        "collection",
        "el",
        "id",
        "attributes",
        "className",
        "tagName",
        "events"
    ];
    b.extend(e.prototype, n, {
        tagName: "div",
        $: function(t) {
            return this.$el.find(t);
        },
        preinitialize: function() {},
        initialize: function() {},
        render: function() {
            return this;
        },
        remove: function() {
            return this._removeElement(), this.stopListening(), this;
        },
        _removeElement: function() {
            this.$el.remove();
        },
        setElement: function(t) {
            return this.undelegateEvents(), this._setElement(t), this.delegateEvents(), this;
        },
        _setElement: function(t) {
            this.$el = t instanceof h.$ ? t : h.$(t), this.el = this.$el[0];
        },
        delegateEvents: function(t) {
            if (!(t = t || b.result(this, "events"))) return this;
            for(var e in this.undelegateEvents(), t){
                var i = t[e];
                (i = !b.isFunction(i) ? this[i] : i) && (e = e.match(A), this.delegate(e[1], e[2], i.bind(this)));
            }
            return this;
        },
        delegate: function(t, e, i) {
            return this.$el.on(t + ".delegateEvents" + this.cid, e, i), this;
        },
        undelegateEvents: function() {
            return this.$el && this.$el.off(".delegateEvents" + this.cid), this;
        },
        undelegate: function(t, e, i) {
            return this.$el.off(t + ".delegateEvents" + this.cid, e, i), this;
        },
        _createElement: function(t) {
            return document.createElement(t);
        },
        _ensureElement: function() {
            var t;
            this.el ? this.setElement(b.result(this, "el")) : (t = b.extend({}, b.result(this, "attributes")), this.id && (t.id = b.result(this, "id")), this.className && (t.class = b.result(this, "className")), this.setElement(this._createElement(b.result(this, "tagName"))), this._setAttributes(t));
        },
        _setAttributes: function(t) {
            this.$el.attr(t);
        }
    });
    function P(i, n, t, s) {
        b.each(t, function(t, e) {
            n[e] && (i.prototype[e] = function(n, t, s, r) {
                switch(t){
                    case 1:
                        return function() {
                            return n[s](this[r]);
                        };
                    case 2:
                        return function(t) {
                            return n[s](this[r], t);
                        };
                    case 3:
                        return function(t, e) {
                            return n[s](this[r], H(t, this), e);
                        };
                    case 4:
                        return function(t, e, i) {
                            return n[s](this[r], H(t, this), e, i);
                        };
                    default:
                        return function() {
                            var t = o.call(arguments);
                            return t.unshift(this[r]), n[s].apply(n, t);
                        };
                }
            }(n, t, e, s));
        });
    }
    var H = function(e, t) {
        var i;
        return b.isFunction(e) ? e : b.isObject(e) && !t._isModel(e) ? (i = b.matches(e), function(t) {
            return i(t.attributes);
        }) : b.isString(e) ? function(t) {
            return t.get(e);
        } : e;
    };
    b.each([
        [
            m,
            {
                forEach: 3,
                each: 3,
                map: 3,
                collect: 3,
                reduce: 0,
                foldl: 0,
                inject: 0,
                reduceRight: 0,
                foldr: 0,
                find: 3,
                detect: 3,
                filter: 3,
                select: 3,
                reject: 3,
                every: 3,
                all: 3,
                some: 3,
                any: 3,
                include: 3,
                includes: 3,
                contains: 3,
                invoke: 0,
                max: 3,
                min: 3,
                toArray: 1,
                size: 1,
                first: 3,
                head: 3,
                take: 3,
                initial: 3,
                rest: 3,
                tail: 3,
                drop: 3,
                last: 3,
                without: 0,
                difference: 0,
                indexOf: 3,
                shuffle: 1,
                lastIndexOf: 3,
                isEmpty: 1,
                chain: 1,
                sample: 3,
                partition: 3,
                groupBy: 3,
                countBy: 3,
                sortBy: 3,
                indexBy: 3,
                findIndex: 3,
                findLastIndex: 3
            },
            "models"
        ],
        [
            v,
            {
                keys: 1,
                values: 1,
                pairs: 1,
                invert: 1,
                pick: 0,
                omit: 0,
                chain: 1,
                isEmpty: 1
            },
            "attributes"
        ]
    ], function(t) {
        var i = t[0], e = t[1], n = t[2];
        i.mixin = function(t) {
            var e = b.reduce(b.functions(t), function(t, e) {
                return t[e] = 0, t;
            }, {});
            P(i, t, e, n);
        }, P(i, b, e, n);
    }), h.sync = function(t, e, n) {
        var i = $[t];
        b.defaults(n = n || {}, {
            emulateHTTP: h.emulateHTTP,
            emulateJSON: h.emulateJSON
        });
        var s, r = {
            type: i,
            dataType: "json"
        };
        n.url || (r.url = b.result(e, "url") || q()), null != n.data || !e || "create" !== t && "update" !== t && "patch" !== t || (r.contentType = "application/json", r.data = JSON.stringify(n.attrs || e.toJSON(n))), n.emulateJSON && (r.contentType = "application/x-www-form-urlencoded", r.data = r.data ? {
            model: r.data
        } : {}), !n.emulateHTTP || "PUT" !== i && "DELETE" !== i && "PATCH" !== i || (r.type = "POST", n.emulateJSON && (r.data._method = i), s = n.beforeSend, n.beforeSend = function(t) {
            if (t.setRequestHeader("X-HTTP-Method-Override", i), s) return s.apply(this, arguments);
        }), "GET" === r.type || n.emulateJSON || (r.processData = !1);
        var o = n.error;
        n.error = function(t, e, i) {
            n.textStatus = e, n.errorThrown = i, o && o.call(n.context, t, e, i);
        };
        r = n.xhr = h.ajax(b.extend(r, n));
        return e.trigger("request", e, r, n), r;
    };
    var $ = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        delete: "DELETE",
        read: "GET"
    };
    h.ajax = function() {
        return h.$.ajax.apply(h.$, arguments);
    };
    var y = h.Router = function(t) {
        t = t || {}, this.preinitialize.apply(this, arguments), t.routes && (this.routes = t.routes), this._bindRoutes(), this.initialize.apply(this, arguments);
    }, C = /\((.*?)\)/g, R = /(\(\?)?:\w+/g, M = /\*\w+/g, N = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    b.extend(y.prototype, n, {
        preinitialize: function() {},
        initialize: function() {},
        route: function(e, i, n) {
            b.isRegExp(e) || (e = this._routeToRegExp(e)), b.isFunction(i) && (n = i, i = ""), n = n || this[i];
            var s = this;
            return h.history.route(e, function(t) {
                t = s._extractParameters(e, t);
                !1 !== s.execute(n, t, i) && (s.trigger.apply(s, [
                    "route:" + i
                ].concat(t)), s.trigger("route", i, t), h.history.trigger("route", s, i, t));
            }), this;
        },
        execute: function(t, e, i) {
            t && t.apply(this, e);
        },
        navigate: function(t, e) {
            return h.history.navigate(t, e), this;
        },
        _bindRoutes: function() {
            if (this.routes) {
                this.routes = b.result(this, "routes");
                for(var t, e = b.keys(this.routes); null != (t = e.pop());)this.route(t, this.routes[t]);
            }
        },
        _routeToRegExp: function(t) {
            return t = t.replace(N, "\\$&").replace(C, "(?:$1)?").replace(R, function(t, e) {
                return e ? t : "([^/?]+)";
            }).replace(M, "([^?]*?)"), new RegExp("^" + t + "(?:\\?([\\s\\S]*))?$");
        },
        _extractParameters: function(t, e) {
            var i = t.exec(e).slice(1);
            return b.map(i, function(t, e) {
                return e === i.length - 1 ? t || null : t ? decodeURIComponent(t) : null;
            });
        }
    });
    var j = h.History = function() {
        this.handlers = [], this.checkUrl = this.checkUrl.bind(this), "undefined" != typeof window && (this.location = window.location, this.history = window.history);
    }, O = /^[#\/]|\s+$/g, U = /^\/+|\/+$/g, z = /#.*$/;
    j.started = !1, b.extend(j.prototype, n, {
        interval: 50,
        atRoot: function() {
            return this.location.pathname.replace(/[^\/]$/, "$&/") === this.root && !this.getSearch();
        },
        matchRoot: function() {
            return this.decodeFragment(this.location.pathname).slice(0, this.root.length - 1) + "/" === this.root;
        },
        decodeFragment: function(t) {
            return decodeURI(t.replace(/%25/g, "%2525"));
        },
        getSearch: function() {
            var t = this.location.href.replace(/#.*/, "").match(/\?.+/);
            return t ? t[0] : "";
        },
        getHash: function(t) {
            t = (t || this).location.href.match(/#(.*)$/);
            return t ? t[1] : "";
        },
        getPath: function() {
            var t = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
            return "/" === t.charAt(0) ? t.slice(1) : t;
        },
        getFragment: function(t) {
            return (t = null == t ? this._usePushState || !this._wantsHashChange ? this.getPath() : this.getHash() : t).replace(O, "");
        },
        start: function(t) {
            if (j.started) throw new Error("Backbone.history has already been started");
            if (j.started = !0, this.options = b.extend({
                root: "/"
            }, this.options, t), this.root = this.options.root, this._wantsHashChange = !1 !== this.options.hashChange, this._hasHashChange = "onhashchange" in window && (void 0 === document.documentMode || 7 < document.documentMode), this._useHashChange = this._wantsHashChange && this._hasHashChange, this._wantsPushState = !!this.options.pushState, this._hasPushState = !(!this.history || !this.history.pushState), this._usePushState = this._wantsPushState && this._hasPushState, this.fragment = this.getFragment(), this.root = ("/" + this.root + "/").replace(U, "/"), this._wantsHashChange && this._wantsPushState) {
                if (!this._hasPushState && !this.atRoot()) {
                    t = this.root.slice(0, -1) || "/";
                    return this.location.replace(t + "#" + this.getPath()), !0;
                }
                this._hasPushState && this.atRoot() && this.navigate(this.getHash(), {
                    replace: !0
                });
            }
            this._hasHashChange || !this._wantsHashChange || this._usePushState || (this.iframe = document.createElement("iframe"), this.iframe.src = "javascript:0", this.iframe.style.display = "none", this.iframe.tabIndex = -1, (e = (e = document.body).insertBefore(this.iframe, e.firstChild).contentWindow).document.open(), e.document.close(), e.location.hash = "#" + this.fragment);
            var e = window.addEventListener || function(t, e) {
                return attachEvent("on" + t, e);
            };
            if (this._usePushState ? e("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe ? e("hashchange", this.checkUrl, !1) : this._wantsHashChange && (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)), !this.options.silent) return this.loadUrl();
        },
        stop: function() {
            var t = window.removeEventListener || function(t, e) {
                return detachEvent("on" + t, e);
            };
            this._usePushState ? t("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe && t("hashchange", this.checkUrl, !1), this.iframe && (document.body.removeChild(this.iframe), this.iframe = null), this._checkUrlInterval && clearInterval(this._checkUrlInterval), j.started = !1;
        },
        route: function(t, e) {
            this.handlers.unshift({
                route: t,
                callback: e
            });
        },
        checkUrl: function(t) {
            var e = this.getFragment();
            if ((e = e === this.fragment && this.iframe ? this.getHash(this.iframe.contentWindow) : e) === this.fragment) return !1;
            this.iframe && this.navigate(e), this.loadUrl();
        },
        loadUrl: function(e) {
            return !!this.matchRoot() && (e = this.fragment = this.getFragment(e), b.some(this.handlers, function(t) {
                if (t.route.test(e)) return t.callback(e), !0;
            }));
        },
        navigate: function(t, e) {
            if (!j.started) return !1;
            e && !0 !== e || (e = {
                trigger: !!e
            }), t = this.getFragment(t || "");
            var i = this.root, n = (i = "" === t || "?" === t.charAt(0) ? i.slice(0, -1) || "/" : i) + t;
            t = t.replace(z, "");
            i = this.decodeFragment(t);
            if (this.fragment !== i) {
                if (this.fragment = i, this._usePushState) this.history[e.replace ? "replaceState" : "pushState"]({}, document.title, n);
                else {
                    if (!this._wantsHashChange) return this.location.assign(n);
                    this._updateHash(this.location, t, e.replace), this.iframe && t !== this.getHash(this.iframe.contentWindow) && (n = this.iframe.contentWindow, e.replace || (n.document.open(), n.document.close()), this._updateHash(n.location, t, e.replace));
                }
                return e.trigger ? this.loadUrl(t) : void 0;
            }
        },
        _updateHash: function(t, e, i) {
            i ? (i = t.href.replace(/(javascript:|#).*$/, ""), t.replace(i + "#" + e)) : t.hash = "#" + e;
        }
    }), h.history = new j;
    v.extend = m.extend = y.extend = e.extend = j.extend = function(t, e) {
        var i = this, n = t && b.has(t, "constructor") ? t.constructor : function() {
            return i.apply(this, arguments);
        };
        return b.extend(n, i, e), n.prototype = b.create(i.prototype, t), (n.prototype.constructor = n).__super__ = i.prototype, n;
    };
    var q = function() {
        throw new Error('A "url" property or function must be specified');
    }, F = function(e, i) {
        var n = i.error;
        i.error = function(t) {
            n && n.call(i.context, e, t, i), e.trigger("error", e, t, i);
        };
    };
    return h;
});

},{"/js/lib/underscore/underscore-umd-min":"dV14C","/js/lib/jquery/jquery.min":"4QkNZ"}],"dV14C":[function(require,module,exports) {
var global = arguments[3];
!function(n, r) {
    module.exports = r();
}(this, function() {
    //     Underscore.js 1.13.4
    //     https://underscorejs.org
    //     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    var n = "1.13.4", r = "object" == typeof self && self.self === self && self || "object" == typeof global && global.global === global && global || Function("return this")() || {}, t = Array.prototype, e = Object.prototype, u = "undefined" != typeof Symbol ? Symbol.prototype : null, o = t.push, i = t.slice, a = e.toString, f = e.hasOwnProperty, c = "undefined" != typeof ArrayBuffer, l = "undefined" != typeof DataView, s = Array.isArray, p = Object.keys, v = Object.create, h = c && ArrayBuffer.isView, y = isNaN, d = isFinite, g = !({
        toString: null
    }).propertyIsEnumerable("toString"), b = [
        "valueOf",
        "isPrototypeOf",
        "toString",
        "propertyIsEnumerable",
        "hasOwnProperty",
        "toLocaleString"
    ], m = Math.pow(2, 53) - 1;
    function j(n, r) {
        return r = null == r ? n.length - 1 : +r, function() {
            for(var t = Math.max(arguments.length - r, 0), e = Array(t), u = 0; u < t; u++)e[u] = arguments[u + r];
            switch(r){
                case 0:
                    return n.call(this, e);
                case 1:
                    return n.call(this, arguments[0], e);
                case 2:
                    return n.call(this, arguments[0], arguments[1], e);
            }
            var o = Array(r + 1);
            for(u = 0; u < r; u++)o[u] = arguments[u];
            return o[r] = e, n.apply(this, o);
        };
    }
    function _(n) {
        var r = typeof n;
        return "function" === r || "object" === r && !!n;
    }
    function w(n) {
        return void 0 === n;
    }
    function A(n) {
        return !0 === n || !1 === n || "[object Boolean]" === a.call(n);
    }
    function x(n) {
        var r = "[object " + n + "]";
        return function(n) {
            return a.call(n) === r;
        };
    }
    var S = x("String"), O = x("Number"), M = x("Date"), E = x("RegExp"), B = x("Error"), N = x("Symbol"), I = x("ArrayBuffer"), T = x("Function"), k = r.document && r.document.childNodes;
    "function" != typeof /./ && "object" != typeof Int8Array && "function" != typeof k && (T = function(n) {
        return "function" == typeof n || !1;
    });
    var D = T, R = x("Object"), F = l && R(new DataView(new ArrayBuffer(8))), V = "undefined" != typeof Map && R(new Map), P = x("DataView");
    var q = F ? function(n) {
        return null != n && D(n.getInt8) && I(n.buffer);
    } : P, U = s || x("Array");
    function W(n, r) {
        return null != n && f.call(n, r);
    }
    var z = x("Arguments");
    !function() {
        z(arguments) || (z = function(n) {
            return W(n, "callee");
        });
    }();
    var L = z;
    function $(n) {
        return O(n) && y(n);
    }
    function C(n) {
        return function() {
            return n;
        };
    }
    function K(n) {
        return function(r) {
            var t = n(r);
            return "number" == typeof t && t >= 0 && t <= m;
        };
    }
    function J(n) {
        return function(r) {
            return null == r ? void 0 : r[n];
        };
    }
    var G = J("byteLength"), H = K(G), Q = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    var X = c ? function(n) {
        return h ? h(n) && !q(n) : H(n) && Q.test(a.call(n));
    } : C(!1), Y = J("length");
    function Z(n, r) {
        r = function(n) {
            for(var r = {}, t = n.length, e = 0; e < t; ++e)r[n[e]] = !0;
            return {
                contains: function(n) {
                    return !0 === r[n];
                },
                push: function(t) {
                    return r[t] = !0, n.push(t);
                }
            };
        }(r);
        var t = b.length, u = n.constructor, o = D(u) && u.prototype || e, i = "constructor";
        for(W(n, i) && !r.contains(i) && r.push(i); t--;)(i = b[t]) in n && n[i] !== o[i] && !r.contains(i) && r.push(i);
    }
    function nn(n) {
        if (!_(n)) return [];
        if (p) return p(n);
        var r = [];
        for(var t in n)W(n, t) && r.push(t);
        return g && Z(n, r), r;
    }
    function rn(n, r) {
        var t = nn(r), e = t.length;
        if (null == n) return !e;
        for(var u = Object(n), o = 0; o < e; o++){
            var i = t[o];
            if (r[i] !== u[i] || !(i in u)) return !1;
        }
        return !0;
    }
    function tn(n) {
        return n instanceof tn ? n : this instanceof tn ? void (this._wrapped = n) : new tn(n);
    }
    function en(n) {
        return new Uint8Array(n.buffer || n, n.byteOffset || 0, G(n));
    }
    tn.VERSION = n, tn.prototype.value = function() {
        return this._wrapped;
    }, tn.prototype.valueOf = tn.prototype.toJSON = tn.prototype.value, tn.prototype.toString = function() {
        return String(this._wrapped);
    };
    var un = "[object DataView]";
    function on(n, r, t, e) {
        if (n === r) return 0 !== n || 1 / n == 1 / r;
        if (null == n || null == r) return !1;
        if (n != n) return r != r;
        var o = typeof n;
        return ("function" === o || "object" === o || "object" == typeof r) && function n(r, t, e, o) {
            r instanceof tn && (r = r._wrapped);
            t instanceof tn && (t = t._wrapped);
            var i = a.call(r);
            if (i !== a.call(t)) return !1;
            if (F && "[object Object]" == i && q(r)) {
                if (!q(t)) return !1;
                i = un;
            }
            switch(i){
                case "[object RegExp]":
                case "[object String]":
                    return "" + r == "" + t;
                case "[object Number]":
                    return +r != +r ? +t != +t : 0 == +r ? 1 / +r == 1 / t : +r == +t;
                case "[object Date]":
                case "[object Boolean]":
                    return +r == +t;
                case "[object Symbol]":
                    return u.valueOf.call(r) === u.valueOf.call(t);
                case "[object ArrayBuffer]":
                case un:
                    return n(en(r), en(t), e, o);
            }
            var f = "[object Array]" === i;
            if (!f && X(r)) {
                if (G(r) !== G(t)) return !1;
                if (r.buffer === t.buffer && r.byteOffset === t.byteOffset) return !0;
                f = !0;
            }
            if (!f) {
                if ("object" != typeof r || "object" != typeof t) return !1;
                var c = r.constructor, l = t.constructor;
                if (c !== l && !(D(c) && c instanceof c && D(l) && l instanceof l) && "constructor" in r && "constructor" in t) return !1;
            }
            o = o || [];
            var s = (e = e || []).length;
            for(; s--;)if (e[s] === r) return o[s] === t;
            if (e.push(r), o.push(t), f) {
                if ((s = r.length) !== t.length) return !1;
                for(; s--;)if (!on(r[s], t[s], e, o)) return !1;
            } else {
                var p, v = nn(r);
                if (s = v.length, nn(t).length !== s) return !1;
                for(; s--;)if (p = v[s], !W(t, p) || !on(r[p], t[p], e, o)) return !1;
            }
            return e.pop(), o.pop(), !0;
        }(n, r, t, e);
    }
    function an(n) {
        if (!_(n)) return [];
        var r = [];
        for(var t in n)r.push(t);
        return g && Z(n, r), r;
    }
    function fn(n) {
        var r = Y(n);
        return function(t) {
            if (null == t) return !1;
            var e = an(t);
            if (Y(e)) return !1;
            for(var u = 0; u < r; u++)if (!D(t[n[u]])) return !1;
            return n !== hn || !D(t[cn]);
        };
    }
    var cn = "forEach", ln = "has", sn = [
        "clear",
        "delete"
    ], pn = [
        "get",
        ln,
        "set"
    ], vn = sn.concat(cn, pn), hn = sn.concat(pn), yn = [
        "add"
    ].concat(sn, cn, ln), dn = V ? fn(vn) : x("Map"), gn = V ? fn(hn) : x("WeakMap"), bn = V ? fn(yn) : x("Set"), mn = x("WeakSet");
    function jn(n) {
        for(var r = nn(n), t = r.length, e = Array(t), u = 0; u < t; u++)e[u] = n[r[u]];
        return e;
    }
    function _n(n) {
        for(var r = {}, t = nn(n), e = 0, u = t.length; e < u; e++)r[n[t[e]]] = t[e];
        return r;
    }
    function wn(n) {
        var r = [];
        for(var t in n)D(n[t]) && r.push(t);
        return r.sort();
    }
    function An(n, r) {
        return function(t) {
            var e = arguments.length;
            if (r && (t = Object(t)), e < 2 || null == t) return t;
            for(var u = 1; u < e; u++)for(var o = arguments[u], i = n(o), a = i.length, f = 0; f < a; f++){
                var c = i[f];
                r && void 0 !== t[c] || (t[c] = o[c]);
            }
            return t;
        };
    }
    var xn = An(an), Sn = An(nn), On = An(an, !0);
    function Mn(n) {
        if (!_(n)) return {};
        if (v) return v(n);
        var r = function() {};
        r.prototype = n;
        var t = new r;
        return r.prototype = null, t;
    }
    function En(n) {
        return U(n) ? n : [
            n
        ];
    }
    function Bn(n) {
        return tn.toPath(n);
    }
    function Nn(n, r) {
        for(var t = r.length, e = 0; e < t; e++){
            if (null == n) return;
            n = n[r[e]];
        }
        return t ? n : void 0;
    }
    function In(n, r, t) {
        var e = Nn(n, Bn(r));
        return w(e) ? t : e;
    }
    function Tn(n) {
        return n;
    }
    function kn(n) {
        return n = Sn({}, n), function(r) {
            return rn(r, n);
        };
    }
    function Dn(n) {
        return n = Bn(n), function(r) {
            return Nn(r, n);
        };
    }
    function Rn(n, r, t) {
        if (void 0 === r) return n;
        switch(null == t ? 3 : t){
            case 1:
                return function(t) {
                    return n.call(r, t);
                };
            case 3:
                return function(t, e, u) {
                    return n.call(r, t, e, u);
                };
            case 4:
                return function(t, e, u, o) {
                    return n.call(r, t, e, u, o);
                };
        }
        return function() {
            return n.apply(r, arguments);
        };
    }
    function Fn(n, r, t) {
        return null == n ? Tn : D(n) ? Rn(n, r, t) : _(n) && !U(n) ? kn(n) : Dn(n);
    }
    function Vn(n, r) {
        return Fn(n, r, 1 / 0);
    }
    function Pn(n, r, t) {
        return tn.iteratee !== Vn ? tn.iteratee(n, r) : Fn(n, r, t);
    }
    function qn() {}
    function Un(n, r) {
        return null == r && (r = n, n = 0), n + Math.floor(Math.random() * (r - n + 1));
    }
    tn.toPath = En, tn.iteratee = Vn;
    var Wn = Date.now || function() {
        return (new Date).getTime();
    };
    function zn(n) {
        var r = function(r) {
            return n[r];
        }, t = "(?:" + nn(n).join("|") + ")", e = RegExp(t), u = RegExp(t, "g");
        return function(n) {
            return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, r) : n;
        };
    }
    var Ln = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, $n = zn(Ln), Cn = zn(_n(Ln)), Kn = tn.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    }, Jn = /(.)^/, Gn = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, Hn = /\\|'|\r|\n|\u2028|\u2029/g;
    function Qn(n) {
        return "\\" + Gn[n];
    }
    var Xn = /^\s*(\w|\$)+\s*$/;
    var Yn = 0;
    function Zn(n, r, t, e, u) {
        if (!(e instanceof r)) return n.apply(t, u);
        var o = Mn(n.prototype), i = n.apply(o, u);
        return _(i) ? i : o;
    }
    var nr = j(function(n, r) {
        var t = nr.placeholder, e = function() {
            for(var u = 0, o = r.length, i = Array(o), a = 0; a < o; a++)i[a] = r[a] === t ? arguments[u++] : r[a];
            for(; u < arguments.length;)i.push(arguments[u++]);
            return Zn(n, e, this, this, i);
        };
        return e;
    });
    nr.placeholder = tn;
    var rr = j(function(n, r, t) {
        if (!D(n)) throw new TypeError("Bind must be called on a function");
        var e = j(function(u) {
            return Zn(n, e, r, this, t.concat(u));
        });
        return e;
    }), tr = K(Y);
    function er(n, r, t, e) {
        if (e = e || [], r || 0 === r) {
            if (r <= 0) return e.concat(n);
        } else r = 1 / 0;
        for(var u = e.length, o = 0, i = Y(n); o < i; o++){
            var a = n[o];
            if (tr(a) && (U(a) || L(a))) {
                if (r > 1) er(a, r - 1, t, e), u = e.length;
                else for(var f = 0, c = a.length; f < c;)e[u++] = a[f++];
            } else t || (e[u++] = a);
        }
        return e;
    }
    var ur = j(function(n, r) {
        var t = (r = er(r, !1, !1)).length;
        if (t < 1) throw new Error("bindAll must be passed function names");
        for(; t--;){
            var e = r[t];
            n[e] = rr(n[e], n);
        }
        return n;
    });
    var or = j(function(n, r, t) {
        return setTimeout(function() {
            return n.apply(null, t);
        }, r);
    }), ir = nr(or, tn, 1);
    function ar(n) {
        return function() {
            return !n.apply(this, arguments);
        };
    }
    function fr(n, r) {
        var t;
        return function() {
            return --n > 0 && (t = r.apply(this, arguments)), n <= 1 && (r = null), t;
        };
    }
    var cr = nr(fr, 2);
    function lr(n, r, t) {
        r = Pn(r, t);
        for(var e, u = nn(n), o = 0, i = u.length; o < i; o++)if (r(n[e = u[o]], e, n)) return e;
    }
    function sr(n) {
        return function(r, t, e) {
            t = Pn(t, e);
            for(var u = Y(r), o = n > 0 ? 0 : u - 1; o >= 0 && o < u; o += n)if (t(r[o], o, r)) return o;
            return -1;
        };
    }
    var pr = sr(1), vr = sr(-1);
    function hr(n, r, t, e) {
        for(var u = (t = Pn(t, e, 1))(r), o = 0, i = Y(n); o < i;){
            var a = Math.floor((o + i) / 2);
            t(n[a]) < u ? o = a + 1 : i = a;
        }
        return o;
    }
    function yr(n, r, t) {
        return function(e, u, o) {
            var a = 0, f = Y(e);
            if ("number" == typeof o) n > 0 ? a = o >= 0 ? o : Math.max(o + f, a) : f = o >= 0 ? Math.min(o + 1, f) : o + f + 1;
            else if (t && o && f) return e[o = t(e, u)] === u ? o : -1;
            if (u != u) return (o = r(i.call(e, a, f), $)) >= 0 ? o + a : -1;
            for(o = n > 0 ? a : f - 1; o >= 0 && o < f; o += n)if (e[o] === u) return o;
            return -1;
        };
    }
    var dr = yr(1, pr, hr), gr = yr(-1, vr);
    function br(n, r, t) {
        var e = (tr(n) ? pr : lr)(n, r, t);
        if (void 0 !== e && -1 !== e) return n[e];
    }
    function mr(n, r, t) {
        var e, u;
        if (r = Rn(r, t), tr(n)) for(e = 0, u = n.length; e < u; e++)r(n[e], e, n);
        else {
            var o = nn(n);
            for(e = 0, u = o.length; e < u; e++)r(n[o[e]], o[e], n);
        }
        return n;
    }
    function jr(n, r, t) {
        r = Pn(r, t);
        for(var e = !tr(n) && nn(n), u = (e || n).length, o = Array(u), i = 0; i < u; i++){
            var a = e ? e[i] : i;
            o[i] = r(n[a], a, n);
        }
        return o;
    }
    function _r(n) {
        var r = function(r, t, e, u) {
            var o = !tr(r) && nn(r), i = (o || r).length, a = n > 0 ? 0 : i - 1;
            for(u || (e = r[o ? o[a] : a], a += n); a >= 0 && a < i; a += n){
                var f = o ? o[a] : a;
                e = t(e, r[f], f, r);
            }
            return e;
        };
        return function(n, t, e, u) {
            var o = arguments.length >= 3;
            return r(n, Rn(t, u, 4), e, o);
        };
    }
    var wr = _r(1), Ar = _r(-1);
    function xr(n, r, t) {
        var e = [];
        return r = Pn(r, t), mr(n, function(n, t, u) {
            r(n, t, u) && e.push(n);
        }), e;
    }
    function Sr(n, r, t) {
        r = Pn(r, t);
        for(var e = !tr(n) && nn(n), u = (e || n).length, o = 0; o < u; o++){
            var i = e ? e[o] : o;
            if (!r(n[i], i, n)) return !1;
        }
        return !0;
    }
    function Or(n, r, t) {
        r = Pn(r, t);
        for(var e = !tr(n) && nn(n), u = (e || n).length, o = 0; o < u; o++){
            var i = e ? e[o] : o;
            if (r(n[i], i, n)) return !0;
        }
        return !1;
    }
    function Mr(n, r, t, e) {
        return tr(n) || (n = jn(n)), ("number" != typeof t || e) && (t = 0), dr(n, r, t) >= 0;
    }
    var Er = j(function(n, r, t) {
        var e, u;
        return D(r) ? u = r : (r = Bn(r), e = r.slice(0, -1), r = r[r.length - 1]), jr(n, function(n) {
            var o = u;
            if (!o) {
                if (e && e.length && (n = Nn(n, e)), null == n) return;
                o = n[r];
            }
            return null == o ? o : o.apply(n, t);
        });
    });
    function Br(n, r) {
        return jr(n, Dn(r));
    }
    function Nr(n, r, t) {
        var e, u, o = -1 / 0, i = -1 / 0;
        if (null == r || "number" == typeof r && "object" != typeof n[0] && null != n) for(var a = 0, f = (n = tr(n) ? n : jn(n)).length; a < f; a++)null != (e = n[a]) && e > o && (o = e);
        else r = Pn(r, t), mr(n, function(n, t, e) {
            ((u = r(n, t, e)) > i || u === -1 / 0 && o === -1 / 0) && (o = n, i = u);
        });
        return o;
    }
    var Ir = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    function Tr(n) {
        return n ? U(n) ? i.call(n) : S(n) ? n.match(Ir) : tr(n) ? jr(n, Tn) : jn(n) : [];
    }
    function kr(n, r, t) {
        if (null == r || t) return tr(n) || (n = jn(n)), n[Un(n.length - 1)];
        var e = Tr(n), u = Y(e);
        r = Math.max(Math.min(r, u), 0);
        for(var o = u - 1, i = 0; i < r; i++){
            var a = Un(i, o), f = e[i];
            e[i] = e[a], e[a] = f;
        }
        return e.slice(0, r);
    }
    function Dr(n, r) {
        return function(t, e, u) {
            var o = r ? [
                [],
                []
            ] : {};
            return e = Pn(e, u), mr(t, function(r, u) {
                var i = e(r, u, t);
                n(o, r, i);
            }), o;
        };
    }
    var Rr = Dr(function(n, r, t) {
        W(n, t) ? n[t].push(r) : n[t] = [
            r
        ];
    }), Fr = Dr(function(n, r, t) {
        n[t] = r;
    }), Vr = Dr(function(n, r, t) {
        W(n, t) ? n[t]++ : n[t] = 1;
    }), Pr = Dr(function(n, r, t) {
        n[t ? 0 : 1].push(r);
    }, !0);
    function qr(n, r, t) {
        return r in t;
    }
    var Ur = j(function(n, r) {
        var t = {}, e = r[0];
        if (null == n) return t;
        D(e) ? (r.length > 1 && (e = Rn(e, r[1])), r = an(n)) : (e = qr, r = er(r, !1, !1), n = Object(n));
        for(var u = 0, o = r.length; u < o; u++){
            var i = r[u], a = n[i];
            e(a, i, n) && (t[i] = a);
        }
        return t;
    }), Wr = j(function(n, r) {
        var t, e = r[0];
        return D(e) ? (e = ar(e), r.length > 1 && (t = r[1])) : (r = jr(er(r, !1, !1), String), e = function(n, t) {
            return !Mr(r, t);
        }), Ur(n, e, t);
    });
    function zr(n, r, t) {
        return i.call(n, 0, Math.max(0, n.length - (null == r || t ? 1 : r)));
    }
    function Lr(n, r, t) {
        return null == n || n.length < 1 ? null == r || t ? void 0 : [] : null == r || t ? n[0] : zr(n, n.length - r);
    }
    function $r(n, r, t) {
        return i.call(n, null == r || t ? 1 : r);
    }
    var Cr = j(function(n, r) {
        return r = er(r, !0, !0), xr(n, function(n) {
            return !Mr(r, n);
        });
    }), Kr = j(function(n, r) {
        return Cr(n, r);
    });
    function Jr(n, r, t, e) {
        A(r) || (e = t, t = r, r = !1), null != t && (t = Pn(t, e));
        for(var u = [], o = [], i = 0, a = Y(n); i < a; i++){
            var f = n[i], c = t ? t(f, i, n) : f;
            r && !t ? (i && o === c || u.push(f), o = c) : t ? Mr(o, c) || (o.push(c), u.push(f)) : Mr(u, f) || u.push(f);
        }
        return u;
    }
    var Gr = j(function(n) {
        return Jr(er(n, !0, !0));
    });
    function Hr(n) {
        for(var r = n && Nr(n, Y).length || 0, t = Array(r), e = 0; e < r; e++)t[e] = Br(n, e);
        return t;
    }
    var Qr = j(Hr);
    function Xr(n, r) {
        return n._chain ? tn(r).chain() : r;
    }
    function Yr(n) {
        return mr(wn(n), function(r) {
            var t = tn[r] = n[r];
            tn.prototype[r] = function() {
                var n = [
                    this._wrapped
                ];
                return o.apply(n, arguments), Xr(this, t.apply(tn, n));
            };
        }), tn;
    }
    mr([
        "pop",
        "push",
        "reverse",
        "shift",
        "sort",
        "splice",
        "unshift"
    ], function(n) {
        var r = t[n];
        tn.prototype[n] = function() {
            var t = this._wrapped;
            return null != t && (r.apply(t, arguments), "shift" !== n && "splice" !== n || 0 !== t.length || delete t[0]), Xr(this, t);
        };
    }), mr([
        "concat",
        "join",
        "slice"
    ], function(n) {
        var r = t[n];
        tn.prototype[n] = function() {
            var n = this._wrapped;
            return null != n && (n = r.apply(n, arguments)), Xr(this, n);
        };
    });
    var Zr = Yr({
        __proto__: null,
        VERSION: n,
        restArguments: j,
        isObject: _,
        isNull: function(n) {
            return null === n;
        },
        isUndefined: w,
        isBoolean: A,
        isElement: function(n) {
            return !(!n || 1 !== n.nodeType);
        },
        isString: S,
        isNumber: O,
        isDate: M,
        isRegExp: E,
        isError: B,
        isSymbol: N,
        isArrayBuffer: I,
        isDataView: q,
        isArray: U,
        isFunction: D,
        isArguments: L,
        isFinite: function(n) {
            return !N(n) && d(n) && !isNaN(parseFloat(n));
        },
        isNaN: $,
        isTypedArray: X,
        isEmpty: function(n) {
            if (null == n) return !0;
            var r = Y(n);
            return "number" == typeof r && (U(n) || S(n) || L(n)) ? 0 === r : 0 === Y(nn(n));
        },
        isMatch: rn,
        isEqual: function(n, r) {
            return on(n, r);
        },
        isMap: dn,
        isWeakMap: gn,
        isSet: bn,
        isWeakSet: mn,
        keys: nn,
        allKeys: an,
        values: jn,
        pairs: function(n) {
            for(var r = nn(n), t = r.length, e = Array(t), u = 0; u < t; u++)e[u] = [
                r[u],
                n[r[u]]
            ];
            return e;
        },
        invert: _n,
        functions: wn,
        methods: wn,
        extend: xn,
        extendOwn: Sn,
        assign: Sn,
        defaults: On,
        create: function(n, r) {
            var t = Mn(n);
            return r && Sn(t, r), t;
        },
        clone: function(n) {
            return _(n) ? U(n) ? n.slice() : xn({}, n) : n;
        },
        tap: function(n, r) {
            return r(n), n;
        },
        get: In,
        has: function(n, r) {
            for(var t = (r = Bn(r)).length, e = 0; e < t; e++){
                var u = r[e];
                if (!W(n, u)) return !1;
                n = n[u];
            }
            return !!t;
        },
        mapObject: function(n, r, t) {
            r = Pn(r, t);
            for(var e = nn(n), u = e.length, o = {}, i = 0; i < u; i++){
                var a = e[i];
                o[a] = r(n[a], a, n);
            }
            return o;
        },
        identity: Tn,
        constant: C,
        noop: qn,
        toPath: En,
        property: Dn,
        propertyOf: function(n) {
            return null == n ? qn : function(r) {
                return In(n, r);
            };
        },
        matcher: kn,
        matches: kn,
        times: function(n, r, t) {
            var e = Array(Math.max(0, n));
            r = Rn(r, t, 1);
            for(var u = 0; u < n; u++)e[u] = r(u);
            return e;
        },
        random: Un,
        now: Wn,
        escape: $n,
        unescape: Cn,
        templateSettings: Kn,
        template: function(n, r, t) {
            !r && t && (r = t), r = On({}, r, tn.templateSettings);
            var e = RegExp([
                (r.escape || Jn).source,
                (r.interpolate || Jn).source,
                (r.evaluate || Jn).source
            ].join("|") + "|$", "g"), u = 0, o = "__p+='";
            n.replace(e, function(r, t, e, i, a) {
                return o += n.slice(u, a).replace(Hn, Qn), u = a + r.length, t ? o += "'+\n((__t=(" + t + "))==null?'':_.escape(__t))+\n'" : e ? o += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : i && (o += "';\n" + i + "\n__p+='"), r;
            }), o += "';\n";
            var i, a = r.variable;
            if (a) {
                if (!Xn.test(a)) throw new Error("variable is not a bare identifier: " + a);
            } else o = "with(obj||{}){\n" + o + "}\n", a = "obj";
            o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n";
            try {
                i = new Function(a, "_", o);
            } catch (n1) {
                throw n1.source = o, n1;
            }
            var f = function(n) {
                return i.call(this, n, tn);
            };
            return f.source = "function(" + a + "){\n" + o + "}", f;
        },
        result: function(n, r, t) {
            var e = (r = Bn(r)).length;
            if (!e) return D(t) ? t.call(n) : t;
            for(var u = 0; u < e; u++){
                var o = null == n ? void 0 : n[r[u]];
                void 0 === o && (o = t, u = e), n = D(o) ? o.call(n) : o;
            }
            return n;
        },
        uniqueId: function(n) {
            var r = ++Yn + "";
            return n ? n + r : r;
        },
        chain: function(n) {
            var r = tn(n);
            return r._chain = !0, r;
        },
        iteratee: Vn,
        partial: nr,
        bind: rr,
        bindAll: ur,
        memoize: function(n, r) {
            var t = function(e) {
                var u = t.cache, o = "" + (r ? r.apply(this, arguments) : e);
                return W(u, o) || (u[o] = n.apply(this, arguments)), u[o];
            };
            return t.cache = {}, t;
        },
        delay: or,
        defer: ir,
        throttle: function(n, r, t) {
            var e, u, o, i, a = 0;
            t || (t = {});
            var f = function() {
                a = !1 === t.leading ? 0 : Wn(), e = null, i = n.apply(u, o), e || (u = o = null);
            }, c = function() {
                var c = Wn();
                a || !1 !== t.leading || (a = c);
                var l = r - (c - a);
                return u = this, o = arguments, l <= 0 || l > r ? (e && (clearTimeout(e), e = null), a = c, i = n.apply(u, o), e || (u = o = null)) : e || !1 === t.trailing || (e = setTimeout(f, l)), i;
            };
            return c.cancel = function() {
                clearTimeout(e), a = 0, e = u = o = null;
            }, c;
        },
        debounce: function(n, r, t) {
            var e, u, o, i, a, f = function() {
                var c = Wn() - u;
                r > c ? e = setTimeout(f, r - c) : (e = null, t || (i = n.apply(a, o)), e || (o = a = null));
            }, c = j(function(c) {
                return a = this, o = c, u = Wn(), e || (e = setTimeout(f, r), t && (i = n.apply(a, o))), i;
            });
            return c.cancel = function() {
                clearTimeout(e), e = o = a = null;
            }, c;
        },
        wrap: function(n, r) {
            return nr(r, n);
        },
        negate: ar,
        compose: function() {
            var n = arguments, r = n.length - 1;
            return function() {
                for(var t = r, e = n[r].apply(this, arguments); t--;)e = n[t].call(this, e);
                return e;
            };
        },
        after: function(n, r) {
            return function() {
                if (--n < 1) return r.apply(this, arguments);
            };
        },
        before: fr,
        once: cr,
        findKey: lr,
        findIndex: pr,
        findLastIndex: vr,
        sortedIndex: hr,
        indexOf: dr,
        lastIndexOf: gr,
        find: br,
        detect: br,
        findWhere: function(n, r) {
            return br(n, kn(r));
        },
        each: mr,
        forEach: mr,
        map: jr,
        collect: jr,
        reduce: wr,
        foldl: wr,
        inject: wr,
        reduceRight: Ar,
        foldr: Ar,
        filter: xr,
        select: xr,
        reject: function(n, r, t) {
            return xr(n, ar(Pn(r)), t);
        },
        every: Sr,
        all: Sr,
        some: Or,
        any: Or,
        contains: Mr,
        includes: Mr,
        include: Mr,
        invoke: Er,
        pluck: Br,
        where: function(n, r) {
            return xr(n, kn(r));
        },
        max: Nr,
        min: function(n, r, t) {
            var e, u, o = 1 / 0, i = 1 / 0;
            if (null == r || "number" == typeof r && "object" != typeof n[0] && null != n) for(var a = 0, f = (n = tr(n) ? n : jn(n)).length; a < f; a++)null != (e = n[a]) && e < o && (o = e);
            else r = Pn(r, t), mr(n, function(n, t, e) {
                ((u = r(n, t, e)) < i || u === 1 / 0 && o === 1 / 0) && (o = n, i = u);
            });
            return o;
        },
        shuffle: function(n) {
            return kr(n, 1 / 0);
        },
        sample: kr,
        sortBy: function(n, r, t) {
            var e = 0;
            return r = Pn(r, t), Br(jr(n, function(n, t, u) {
                return {
                    value: n,
                    index: e++,
                    criteria: r(n, t, u)
                };
            }).sort(function(n, r) {
                var t = n.criteria, e = r.criteria;
                if (t !== e) {
                    if (t > e || void 0 === t) return 1;
                    if (t < e || void 0 === e) return -1;
                }
                return n.index - r.index;
            }), "value");
        },
        groupBy: Rr,
        indexBy: Fr,
        countBy: Vr,
        partition: Pr,
        toArray: Tr,
        size: function(n) {
            return null == n ? 0 : tr(n) ? n.length : nn(n).length;
        },
        pick: Ur,
        omit: Wr,
        first: Lr,
        head: Lr,
        take: Lr,
        initial: zr,
        last: function(n, r, t) {
            return null == n || n.length < 1 ? null == r || t ? void 0 : [] : null == r || t ? n[n.length - 1] : $r(n, Math.max(0, n.length - r));
        },
        rest: $r,
        tail: $r,
        drop: $r,
        compact: function(n) {
            return xr(n, Boolean);
        },
        flatten: function(n, r) {
            return er(n, r, !1);
        },
        without: Kr,
        uniq: Jr,
        unique: Jr,
        union: Gr,
        intersection: function(n) {
            for(var r = [], t = arguments.length, e = 0, u = Y(n); e < u; e++){
                var o = n[e];
                if (!Mr(r, o)) {
                    var i;
                    for(i = 1; i < t && Mr(arguments[i], o); i++);
                    i === t && r.push(o);
                }
            }
            return r;
        },
        difference: Cr,
        unzip: Hr,
        transpose: Hr,
        zip: Qr,
        object: function(n, r) {
            for(var t = {}, e = 0, u = Y(n); e < u; e++)r ? t[n[e]] = r[e] : t[n[e][0]] = n[e][1];
            return t;
        },
        range: function(n, r, t) {
            null == r && (r = n || 0, n = 0), t || (t = r < n ? -1 : 1);
            for(var e = Math.max(Math.ceil((r - n) / t), 0), u = Array(e), o = 0; o < e; o++, n += t)u[o] = n;
            return u;
        },
        chunk: function(n, r) {
            if (null == r || r < 1) return [];
            for(var t = [], e = 0, u = n.length; e < u;)t.push(i.call(n, e, e += r));
            return t;
        },
        mixin: Yr,
        default: tn
    });
    return Zr._ = Zr, Zr;
});

},{}],"jqSAO":[function(require,module,exports) {
var global = arguments[3];
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ (function() {
    function n(n, t, r) {
        switch(r.length){
            case 0:
                return n.call(t);
            case 1:
                return n.call(t, r[0]);
            case 2:
                return n.call(t, r[0], r[1]);
            case 3:
                return n.call(t, r[0], r[1], r[2]);
        }
        return n.apply(t, r);
    }
    function t(n, t, r, e) {
        for(var u = -1, i = null == n ? 0 : n.length; ++u < i;){
            var o = n[u];
            t(e, o, r(o), n);
        }
        return e;
    }
    function r(n, t) {
        for(var r = -1, e = null == n ? 0 : n.length; ++r < e && t(n[r], r, n) !== !1;);
        return n;
    }
    function e(n, t) {
        for(var r = null == n ? 0 : n.length; (r--) && t(n[r], r, n) !== !1;);
        return n;
    }
    function u(n, t) {
        for(var r = -1, e = null == n ? 0 : n.length; ++r < e;)if (!t(n[r], r, n)) return !1;
        return !0;
    }
    function i(n, t) {
        for(var r = -1, e = null == n ? 0 : n.length, u = 0, i = []; ++r < e;){
            var o = n[r];
            t(o, r, n) && (i[u++] = o);
        }
        return i;
    }
    function o(n, t) {
        return !!(null == n ? 0 : n.length) && y(n, t, 0) > -1;
    }
    function f(n, t, r) {
        for(var e = -1, u = null == n ? 0 : n.length; ++e < u;)if (r(t, n[e])) return !0;
        return !1;
    }
    function c(n, t) {
        for(var r = -1, e = null == n ? 0 : n.length, u = Array(e); ++r < e;)u[r] = t(n[r], r, n);
        return u;
    }
    function a(n, t) {
        for(var r = -1, e = t.length, u = n.length; ++r < e;)n[u + r] = t[r];
        return n;
    }
    function l(n, t, r, e) {
        var u = -1, i = null == n ? 0 : n.length;
        for(e && i && (r = n[++u]); ++u < i;)r = t(r, n[u], u, n);
        return r;
    }
    function s(n, t, r, e) {
        var u = null == n ? 0 : n.length;
        for(e && u && (r = n[--u]); u--;)r = t(r, n[u], u, n);
        return r;
    }
    function h(n, t) {
        for(var r = -1, e = null == n ? 0 : n.length; ++r < e;)if (t(n[r], r, n)) return !0;
        return !1;
    }
    function p(n) {
        return n.split("");
    }
    function _(n) {
        return n.match($t) || [];
    }
    function v(n, t, r) {
        var e;
        return r(n, function(n, r, u) {
            if (t(n, r, u)) return e = r, !1;
        }), e;
    }
    function g(n, t, r, e) {
        for(var u = n.length, i = r + (e ? 1 : -1); e ? i-- : ++i < u;)if (t(n[i], i, n)) return i;
        return -1;
    }
    function y(n, t, r) {
        return t === t ? Z(n, t, r) : g(n, b, r);
    }
    function d(n, t, r, e) {
        for(var u = r - 1, i = n.length; ++u < i;)if (e(n[u], t)) return u;
        return -1;
    }
    function b(n) {
        return n !== n;
    }
    function w(n, t) {
        var r = null == n ? 0 : n.length;
        return r ? k(n, t) / r : Cn;
    }
    function m(n) {
        return function(t) {
            return null == t ? X : t[n];
        };
    }
    function x(n) {
        return function(t) {
            return null == n ? X : n[t];
        };
    }
    function j(n, t, r, e, u) {
        return u(n, function(n, u, i) {
            r = e ? (e = !1, n) : t(r, n, u, i);
        }), r;
    }
    function A(n, t) {
        var r = n.length;
        for(n.sort(t); r--;)n[r] = n[r].value;
        return n;
    }
    function k(n, t) {
        for(var r, e = -1, u = n.length; ++e < u;){
            var i = t(n[e]);
            i !== X && (r = r === X ? i : r + i);
        }
        return r;
    }
    function O(n, t) {
        for(var r = -1, e = Array(n); ++r < n;)e[r] = t(r);
        return e;
    }
    function I(n, t) {
        return c(t, function(t) {
            return [
                t,
                n[t]
            ];
        });
    }
    function R(n) {
        return n ? n.slice(0, H(n) + 1).replace(Lt, "") : n;
    }
    function z(n) {
        return function(t) {
            return n(t);
        };
    }
    function E(n, t) {
        return c(t, function(t) {
            return n[t];
        });
    }
    function S(n, t) {
        return n.has(t);
    }
    function W(n, t) {
        for(var r = -1, e = n.length; ++r < e && y(t, n[r], 0) > -1;);
        return r;
    }
    function L(n, t) {
        for(var r = n.length; (r--) && y(t, n[r], 0) > -1;);
        return r;
    }
    function C(n, t) {
        for(var r = n.length, e = 0; r--;)n[r] === t && ++e;
        return e;
    }
    function U(n) {
        return "\\" + Yr[n];
    }
    function B(n, t) {
        return null == n ? X : n[t];
    }
    function T(n) {
        return Nr.test(n);
    }
    function $(n) {
        return Pr.test(n);
    }
    function D(n) {
        for(var t, r = []; !(t = n.next()).done;)r.push(t.value);
        return r;
    }
    function M(n) {
        var t = -1, r = Array(n.size);
        return n.forEach(function(n, e) {
            r[++t] = [
                e,
                n
            ];
        }), r;
    }
    function F(n, t) {
        return function(r) {
            return n(t(r));
        };
    }
    function N(n, t) {
        for(var r = -1, e = n.length, u = 0, i = []; ++r < e;){
            var o = n[r];
            o !== t && o !== cn || (n[r] = cn, i[u++] = r);
        }
        return i;
    }
    function P(n) {
        var t = -1, r = Array(n.size);
        return n.forEach(function(n) {
            r[++t] = n;
        }), r;
    }
    function q(n) {
        var t = -1, r = Array(n.size);
        return n.forEach(function(n) {
            r[++t] = [
                n,
                n
            ];
        }), r;
    }
    function Z(n, t, r) {
        for(var e = r - 1, u = n.length; ++e < u;)if (n[e] === t) return e;
        return -1;
    }
    function K(n, t, r) {
        for(var e = r + 1; e--;)if (n[e] === t) return e;
        return e;
    }
    function V(n) {
        return T(n) ? J(n) : _e(n);
    }
    function G(n) {
        return T(n) ? Y(n) : p(n);
    }
    function H(n) {
        for(var t = n.length; t-- && Ct.test(n.charAt(t)););
        return t;
    }
    function J(n) {
        for(var t = Mr.lastIndex = 0; Mr.test(n);)++t;
        return t;
    }
    function Y(n) {
        return n.match(Mr) || [];
    }
    function Q(n) {
        return n.match(Fr) || [];
    }
    var X, nn = "4.17.21", tn = 200, rn = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", en = "Expected a function", un = "Invalid `variable` option passed into `_.template`", on = "__lodash_hash_undefined__", fn = 500, cn = "__lodash_placeholder__", an = 1, ln = 2, sn = 4, hn = 1, pn = 2, _n = 1, vn = 2, gn = 4, yn = 8, dn = 16, bn = 32, wn = 64, mn = 128, xn = 256, jn = 512, An = 30, kn = "...", On = 800, In = 16, Rn = 1, zn = 2, En = 3, Sn = 1 / 0, Wn = 9007199254740991, Ln = 1.7976931348623157e308, Cn = NaN, Un = 4294967295, Bn = Un - 1, Tn = Un >>> 1, $n = [
        [
            "ary",
            mn
        ],
        [
            "bind",
            _n
        ],
        [
            "bindKey",
            vn
        ],
        [
            "curry",
            yn
        ],
        [
            "curryRight",
            dn
        ],
        [
            "flip",
            jn
        ],
        [
            "partial",
            bn
        ],
        [
            "partialRight",
            wn
        ],
        [
            "rearg",
            xn
        ]
    ], Dn = "[object Arguments]", Mn = "[object Array]", Fn = "[object AsyncFunction]", Nn = "[object Boolean]", Pn = "[object Date]", qn = "[object DOMException]", Zn = "[object Error]", Kn = "[object Function]", Vn = "[object GeneratorFunction]", Gn = "[object Map]", Hn = "[object Number]", Jn = "[object Null]", Yn = "[object Object]", Qn = "[object Promise]", Xn = "[object Proxy]", nt = "[object RegExp]", tt = "[object Set]", rt = "[object String]", et = "[object Symbol]", ut = "[object Undefined]", it = "[object WeakMap]", ot = "[object WeakSet]", ft = "[object ArrayBuffer]", ct = "[object DataView]", at = "[object Float32Array]", lt = "[object Float64Array]", st = "[object Int8Array]", ht = "[object Int16Array]", pt = "[object Int32Array]", _t = "[object Uint8Array]", vt = "[object Uint8ClampedArray]", gt = "[object Uint16Array]", yt = "[object Uint32Array]", dt = /\b__p \+= '';/g, bt = /\b(__p \+=) '' \+/g, wt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, mt = /&(?:amp|lt|gt|quot|#39);/g, xt = /[&<>"']/g, jt = RegExp(mt.source), At = RegExp(xt.source), kt = /<%-([\s\S]+?)%>/g, Ot = /<%([\s\S]+?)%>/g, It = /<%=([\s\S]+?)%>/g, Rt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, zt = /^\w*$/, Et = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, St = /[\\^$.*+?()[\]{}|]/g, Wt = RegExp(St.source), Lt = /^\s+/, Ct = /\s/, Ut = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Bt = /\{\n\/\* \[wrapped with (.+)\] \*/, Tt = /,? & /, $t = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Dt = /[()=,{}\[\]\/\s]/, Mt = /\\(\\)?/g, Ft = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Nt = /\w*$/, Pt = /^[-+]0x[0-9a-f]+$/i, qt = /^0b[01]+$/i, Zt = /^\[object .+?Constructor\]$/, Kt = /^0o[0-7]+$/i, Vt = /^(?:0|[1-9]\d*)$/, Gt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ht = /($^)/, Jt = /['\n\r\u2028\u2029\\]/g, Yt = "\ud800-\udfff", Qt = "\\u0300-\\u036f", Xt = "\\ufe20-\\ufe2f", nr = "\\u20d0-\\u20ff", tr = Qt + Xt + nr, rr = "\\u2700-\\u27bf", er = "a-z\\xdf-\\xf6\\xf8-\\xff", ur = "\\xac\\xb1\\xd7\\xf7", ir = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", or = "\\u2000-\\u206f", fr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", cr = "A-Z\\xc0-\\xd6\\xd8-\\xde", ar = "\\ufe0e\\ufe0f", lr = ur + ir + or + fr, sr = "['‚Äô]", hr = "[" + Yt + "]", pr = "[" + lr + "]", _r = "[" + tr + "]", vr = "\\d+", gr = "[" + rr + "]", yr = "[" + er + "]", dr = "[^" + Yt + lr + vr + rr + er + cr + "]", br = "\ud83c[\udffb-\udfff]", wr = "(?:" + _r + "|" + br + ")", mr = "[^" + Yt + "]", xr = "(?:\ud83c[\udde6-\uddff]){2}", jr = "[\ud800-\udbff][\udc00-\udfff]", Ar = "[" + cr + "]", kr = "\\u200d", Or = "(?:" + yr + "|" + dr + ")", Ir = "(?:" + Ar + "|" + dr + ")", Rr = "(?:" + sr + "(?:d|ll|m|re|s|t|ve))?", zr = "(?:" + sr + "(?:D|LL|M|RE|S|T|VE))?", Er = wr + "?", Sr = "[" + ar + "]?", Wr = "(?:" + kr + "(?:" + [
        mr,
        xr,
        jr
    ].join("|") + ")" + Sr + Er + ")*", Lr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Cr = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Ur = Sr + Er + Wr, Br = "(?:" + [
        gr,
        xr,
        jr
    ].join("|") + ")" + Ur, Tr = "(?:" + [
        mr + _r + "?",
        _r,
        xr,
        jr,
        hr
    ].join("|") + ")", $r = RegExp(sr, "g"), Dr = RegExp(_r, "g"), Mr = RegExp(br + "(?=" + br + ")|" + Tr + Ur, "g"), Fr = RegExp([
        Ar + "?" + yr + "+" + Rr + "(?=" + [
            pr,
            Ar,
            "$"
        ].join("|") + ")",
        Ir + "+" + zr + "(?=" + [
            pr,
            Ar + Or,
            "$"
        ].join("|") + ")",
        Ar + "?" + Or + "+" + Rr,
        Ar + "+" + zr,
        Cr,
        Lr,
        vr,
        Br
    ].join("|"), "g"), Nr = RegExp("[" + kr + Yt + tr + ar + "]"), Pr = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, qr = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
    ], Zr = -1, Kr = {};
    Kr[at] = Kr[lt] = Kr[st] = Kr[ht] = Kr[pt] = Kr[_t] = Kr[vt] = Kr[gt] = Kr[yt] = !0, Kr[Dn] = Kr[Mn] = Kr[ft] = Kr[Nn] = Kr[ct] = Kr[Pn] = Kr[Zn] = Kr[Kn] = Kr[Gn] = Kr[Hn] = Kr[Yn] = Kr[nt] = Kr[tt] = Kr[rt] = Kr[it] = !1;
    var Vr = {};
    Vr[Dn] = Vr[Mn] = Vr[ft] = Vr[ct] = Vr[Nn] = Vr[Pn] = Vr[at] = Vr[lt] = Vr[st] = Vr[ht] = Vr[pt] = Vr[Gn] = Vr[Hn] = Vr[Yn] = Vr[nt] = Vr[tt] = Vr[rt] = Vr[et] = Vr[_t] = Vr[vt] = Vr[gt] = Vr[yt] = !0, Vr[Zn] = Vr[Kn] = Vr[it] = !1;
    var Gr = {
        "\xc0": "A",
        "\xc1": "A",
        "\xc2": "A",
        "\xc3": "A",
        "\xc4": "A",
        "\xc5": "A",
        "\xe0": "a",
        "\xe1": "a",
        "\xe2": "a",
        "\xe3": "a",
        "\xe4": "a",
        "\xe5": "a",
        "\xc7": "C",
        "\xe7": "c",
        "\xd0": "D",
        "\xf0": "d",
        "\xc8": "E",
        "\xc9": "E",
        "\xca": "E",
        "\xcb": "E",
        "\xe8": "e",
        "\xe9": "e",
        "\xea": "e",
        "\xeb": "e",
        "\xcc": "I",
        "\xcd": "I",
        "\xce": "I",
        "\xcf": "I",
        "\xec": "i",
        "\xed": "i",
        "\xee": "i",
        "\xef": "i",
        "\xd1": "N",
        "\xf1": "n",
        "\xd2": "O",
        "\xd3": "O",
        "\xd4": "O",
        "\xd5": "O",
        "\xd6": "O",
        "\xd8": "O",
        "\xf2": "o",
        "\xf3": "o",
        "\xf4": "o",
        "\xf5": "o",
        "\xf6": "o",
        "\xf8": "o",
        "\xd9": "U",
        "\xda": "U",
        "\xdb": "U",
        "\xdc": "U",
        "\xf9": "u",
        "\xfa": "u",
        "\xfb": "u",
        "\xfc": "u",
        "\xdd": "Y",
        "\xfd": "y",
        "\xff": "y",
        "\xc6": "Ae",
        "\xe6": "ae",
        "\xde": "Th",
        "\xfe": "th",
        "\xdf": "ss",
        "ƒÄ": "A",
        "ƒÇ": "A",
        "ƒÑ": "A",
        "ƒÅ": "a",
        "ƒÉ": "a",
        "ƒÖ": "a",
        "ƒÜ": "C",
        "ƒà": "C",
        "ƒä": "C",
        "ƒå": "C",
        "ƒá": "c",
        "ƒâ": "c",
        "ƒã": "c",
        "ƒç": "c",
        "ƒé": "D",
        "ƒê": "D",
        "ƒè": "d",
        "ƒë": "d",
        "ƒí": "E",
        "ƒî": "E",
        "ƒñ": "E",
        "ƒò": "E",
        "ƒö": "E",
        "ƒì": "e",
        "ƒï": "e",
        "ƒó": "e",
        "ƒô": "e",
        "ƒõ": "e",
        "ƒú": "G",
        "ƒû": "G",
        "ƒ†": "G",
        "ƒ¢": "G",
        "ƒù": "g",
        "ƒü": "g",
        "ƒ°": "g",
        "ƒ£": "g",
        "ƒ§": "H",
        "ƒ¶": "H",
        "ƒ•": "h",
        "ƒß": "h",
        "ƒ®": "I",
        "ƒ™": "I",
        "ƒ¨": "I",
        "ƒÆ": "I",
        "ƒ∞": "I",
        "ƒ©": "i",
        "ƒ´": "i",
        "ƒ≠": "i",
        "ƒØ": "i",
        "ƒ±": "i",
        "ƒ¥": "J",
        "ƒµ": "j",
        "ƒ∂": "K",
        "ƒ∑": "k",
        "ƒ∏": "k",
        "ƒπ": "L",
        "ƒª": "L",
        "ƒΩ": "L",
        "ƒø": "L",
        "≈Å": "L",
        "ƒ∫": "l",
        "ƒº": "l",
        "ƒæ": "l",
        "≈Ä": "l",
        "≈Ç": "l",
        "≈É": "N",
        "≈Ö": "N",
        "≈á": "N",
        "≈ä": "N",
        "≈Ñ": "n",
        "≈Ü": "n",
        "≈à": "n",
        "≈ã": "n",
        "≈å": "O",
        "≈é": "O",
        "≈ê": "O",
        "≈ç": "o",
        "≈è": "o",
        "≈ë": "o",
        "≈î": "R",
        "≈ñ": "R",
        "≈ò": "R",
        "≈ï": "r",
        "≈ó": "r",
        "≈ô": "r",
        "≈ö": "S",
        "≈ú": "S",
        "≈û": "S",
        "≈†": "S",
        "≈õ": "s",
        "≈ù": "s",
        "≈ü": "s",
        "≈°": "s",
        "≈¢": "T",
        "≈§": "T",
        "≈¶": "T",
        "≈£": "t",
        "≈•": "t",
        "≈ß": "t",
        "≈®": "U",
        "≈™": "U",
        "≈¨": "U",
        "≈Æ": "U",
        "≈∞": "U",
        "≈≤": "U",
        "≈©": "u",
        "≈´": "u",
        "≈≠": "u",
        "≈Ø": "u",
        "≈±": "u",
        "≈≥": "u",
        "≈¥": "W",
        "≈µ": "w",
        "≈∂": "Y",
        "≈∑": "y",
        "≈∏": "Y",
        "≈π": "Z",
        "≈ª": "Z",
        "≈Ω": "Z",
        "≈∫": "z",
        "≈º": "z",
        "≈æ": "z",
        "ƒ≤": "IJ",
        "ƒ≥": "ij",
        "≈í": "Oe",
        "≈ì": "oe",
        "≈â": "'n",
        "≈ø": "s"
    }, Hr = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    }, Jr = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
    }, Yr = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, Qr = parseFloat, Xr = parseInt, ne = "object" == typeof global && global && global.Object === Object && global, te = "object" == typeof self && self && self.Object === Object && self, re = ne || te || Function("return this")(), ee = exports && !exports.nodeType && exports, ue = ee && true && module && !module.nodeType && module, ie = ue && ue.exports === ee, oe = ie && ne.process, fe = function() {
        try {
            var n = ue && ue.require && ue.require("util").types;
            return n ? n : oe && oe.binding && oe.binding("util");
        } catch (n1) {}
    }(), ce = fe && fe.isArrayBuffer, ae = fe && fe.isDate, le = fe && fe.isMap, se = fe && fe.isRegExp, he = fe && fe.isSet, pe = fe && fe.isTypedArray, _e = m("length"), ve = x(Gr), ge = x(Hr), ye = x(Jr), de = function p(x) {
        function Z(n) {
            if (cc(n) && !bh(n) && !(n instanceof Ct)) {
                if (n instanceof Y) return n;
                if (bl.call(n, "__wrapped__")) return eo(n);
            }
            return new Y(n);
        }
        function J() {}
        function Y(n, t) {
            this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, this.__values__ = X;
        }
        function Ct(n) {
            this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Un, this.__views__ = [];
        }
        function $t() {
            var n = new Ct(this.__wrapped__);
            return n.__actions__ = Tu(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, n.__iteratees__ = Tu(this.__iteratees__), n.__takeCount__ = this.__takeCount__, n.__views__ = Tu(this.__views__), n;
        }
        function Yt() {
            if (this.__filtered__) {
                var n = new Ct(this);
                n.__dir__ = -1, n.__filtered__ = !0;
            } else n = this.clone(), n.__dir__ *= -1;
            return n;
        }
        function Qt() {
            var n = this.__wrapped__.value(), t = this.__dir__, r = bh(n), e = t < 0, u = r ? n.length : 0, i = Oi(0, u, this.__views__), o = i.start, f = i.end, c = f - o, a = e ? f : o - 1, l = this.__iteratees__, s = l.length, h = 0, p = Hl(c, this.__takeCount__);
            if (!r || !e && u == c && p == c) return wu(n, this.__actions__);
            var _ = [];
            n: for(; (c--) && h < p;){
                a += t;
                for(var v = -1, g = n[a]; ++v < s;){
                    var y = l[v], d = y.iteratee, b = y.type, w = d(g);
                    if (b == zn) g = w;
                    else if (!w) {
                        if (b == Rn) continue n;
                        break n;
                    }
                }
                _[h++] = g;
            }
            return _;
        }
        function Xt(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for(this.clear(); ++t < r;){
                var e = n[t];
                this.set(e[0], e[1]);
            }
        }
        function nr() {
            this.__data__ = is ? is(null) : {}, this.size = 0;
        }
        function tr(n) {
            var t = this.has(n) && delete this.__data__[n];
            return this.size -= t ? 1 : 0, t;
        }
        function rr(n) {
            var t = this.__data__;
            if (is) {
                var r = t[n];
                return r === on ? X : r;
            }
            return bl.call(t, n) ? t[n] : X;
        }
        function er(n) {
            var t = this.__data__;
            return is ? t[n] !== X : bl.call(t, n);
        }
        function ur(n, t) {
            var r = this.__data__;
            return this.size += this.has(n) ? 0 : 1, r[n] = is && t === X ? on : t, this;
        }
        function ir(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for(this.clear(); ++t < r;){
                var e = n[t];
                this.set(e[0], e[1]);
            }
        }
        function or() {
            this.__data__ = [], this.size = 0;
        }
        function fr(n) {
            var t = this.__data__, r = Wr(t, n);
            return !(r < 0) && (r == t.length - 1 ? t.pop() : Ll.call(t, r, 1), --this.size, !0);
        }
        function cr(n) {
            var t = this.__data__, r = Wr(t, n);
            return r < 0 ? X : t[r][1];
        }
        function ar(n) {
            return Wr(this.__data__, n) > -1;
        }
        function lr(n, t) {
            var r = this.__data__, e = Wr(r, n);
            return e < 0 ? (++this.size, r.push([
                n,
                t
            ])) : r[e][1] = t, this;
        }
        function sr(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for(this.clear(); ++t < r;){
                var e = n[t];
                this.set(e[0], e[1]);
            }
        }
        function hr() {
            this.size = 0, this.__data__ = {
                hash: new Xt,
                map: new (ts || ir),
                string: new Xt
            };
        }
        function pr(n) {
            var t = xi(this, n).delete(n);
            return this.size -= t ? 1 : 0, t;
        }
        function _r(n) {
            return xi(this, n).get(n);
        }
        function vr(n) {
            return xi(this, n).has(n);
        }
        function gr(n, t) {
            var r = xi(this, n), e = r.size;
            return r.set(n, t), this.size += r.size == e ? 0 : 1, this;
        }
        function yr(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for(this.__data__ = new sr; ++t < r;)this.add(n[t]);
        }
        function dr(n) {
            return this.__data__.set(n, on), this;
        }
        function br(n) {
            return this.__data__.has(n);
        }
        function wr(n) {
            this.size = (this.__data__ = new ir(n)).size;
        }
        function mr() {
            this.__data__ = new ir, this.size = 0;
        }
        function xr(n) {
            var t = this.__data__, r = t.delete(n);
            return this.size = t.size, r;
        }
        function jr(n) {
            return this.__data__.get(n);
        }
        function Ar(n) {
            return this.__data__.has(n);
        }
        function kr(n, t) {
            var r = this.__data__;
            if (r instanceof ir) {
                var e = r.__data__;
                if (!ts || e.length < tn - 1) return e.push([
                    n,
                    t
                ]), this.size = ++r.size, this;
                r = this.__data__ = new sr(e);
            }
            return r.set(n, t), this.size = r.size, this;
        }
        function Or(n, t) {
            var r = bh(n), e = !r && dh(n), u = !r && !e && mh(n), i = !r && !e && !u && Oh(n), o = r || e || u || i, f = o ? O(n.length, hl) : [], c = f.length;
            for(var a in n)!t && !bl.call(n, a) || o && ("length" == a || u && ("offset" == a || "parent" == a) || i && ("buffer" == a || "byteLength" == a || "byteOffset" == a) || Ci(a, c)) || f.push(a);
            return f;
        }
        function Ir(n) {
            var t = n.length;
            return t ? n[tu(0, t - 1)] : X;
        }
        function Rr(n, t) {
            return Xi(Tu(n), Mr(t, 0, n.length));
        }
        function zr(n) {
            return Xi(Tu(n));
        }
        function Er(n, t, r) {
            (r === X || Gf(n[t], r)) && (r !== X || t in n) || Br(n, t, r);
        }
        function Sr(n, t, r) {
            var e = n[t];
            bl.call(n, t) && Gf(e, r) && (r !== X || t in n) || Br(n, t, r);
        }
        function Wr(n, t) {
            for(var r = n.length; r--;)if (Gf(n[r][0], t)) return r;
            return -1;
        }
        function Lr(n, t, r, e) {
            return ys(n, function(n, u, i) {
                t(e, n, r(n), i);
            }), e;
        }
        function Cr(n, t) {
            return n && $u(t, Pc(t), n);
        }
        function Ur(n, t) {
            return n && $u(t, qc(t), n);
        }
        function Br(n, t, r) {
            "__proto__" == t && Tl ? Tl(n, t, {
                configurable: !0,
                enumerable: !0,
                value: r,
                writable: !0
            }) : n[t] = r;
        }
        function Tr(n, t) {
            for(var r = -1, e = t.length, u = il(e), i = null == n; ++r < e;)u[r] = i ? X : Mc(n, t[r]);
            return u;
        }
        function Mr(n, t, r) {
            return n === n && (r !== X && (n = n <= r ? n : r), t !== X && (n = n >= t ? n : t)), n;
        }
        function Fr(n, t, e, u, i, o) {
            var f, c = t & an, a = t & ln, l = t & sn;
            if (e && (f = i ? e(n, u, i, o) : e(n)), f !== X) return f;
            if (!fc(n)) return n;
            var s = bh(n);
            if (s) {
                if (f = zi(n), !c) return Tu(n, f);
            } else {
                var h = zs(n), p = h == Kn || h == Vn;
                if (mh(n)) return Iu(n, c);
                if (h == Yn || h == Dn || p && !i) {
                    if (f = a || p ? {} : Ei(n), !c) return a ? Mu(n, Ur(f, n)) : Du(n, Cr(f, n));
                } else {
                    if (!Vr[h]) return i ? n : {};
                    f = Si(n, h, c);
                }
            }
            o || (o = new wr);
            var _ = o.get(n);
            if (_) return _;
            o.set(n, f), kh(n) ? n.forEach(function(r) {
                f.add(Fr(r, t, e, r, n, o));
            }) : jh(n) && n.forEach(function(r, u) {
                f.set(u, Fr(r, t, e, u, n, o));
            });
            var v = l ? a ? di : yi : a ? qc : Pc, g = s ? X : v(n);
            return r(g || n, function(r, u) {
                g && (u = r, r = n[u]), Sr(f, u, Fr(r, t, e, u, n, o));
            }), f;
        }
        function Nr(n) {
            var t = Pc(n);
            return function(r) {
                return Pr(r, n, t);
            };
        }
        function Pr(n, t, r) {
            var e = r.length;
            if (null == n) return !e;
            for(n = ll(n); e--;){
                var u = r[e], i = t[u], o = n[u];
                if (o === X && !(u in n) || !i(o)) return !1;
            }
            return !0;
        }
        function Gr(n, t, r) {
            if ("function" != typeof n) throw new pl(en);
            return Ws(function() {
                n.apply(X, r);
            }, t);
        }
        function Hr(n, t, r, e) {
            var u = -1, i = o, a = !0, l = n.length, s = [], h = t.length;
            if (!l) return s;
            r && (t = c(t, z(r))), e ? (i = f, a = !1) : t.length >= tn && (i = S, a = !1, t = new yr(t));
            n: for(; ++u < l;){
                var p = n[u], _ = null == r ? p : r(p);
                if (p = e || 0 !== p ? p : 0, a && _ === _) {
                    for(var v = h; v--;)if (t[v] === _) continue n;
                    s.push(p);
                } else i(t, _, e) || s.push(p);
            }
            return s;
        }
        function Jr(n, t) {
            var r = !0;
            return ys(n, function(n, e, u) {
                return r = !!t(n, e, u);
            }), r;
        }
        function Yr(n, t, r) {
            for(var e = -1, u = n.length; ++e < u;){
                var i = n[e], o = t(i);
                if (null != o && (f === X ? o === o && !bc(o) : r(o, f))) var f = o, c = i;
            }
            return c;
        }
        function ne(n, t, r, e) {
            var u = n.length;
            for(r = kc(r), r < 0 && (r = -r > u ? 0 : u + r), e = e === X || e > u ? u : kc(e), e < 0 && (e += u), e = r > e ? 0 : Oc(e); r < e;)n[r++] = t;
            return n;
        }
        function te(n, t) {
            var r = [];
            return ys(n, function(n, e, u) {
                t(n, e, u) && r.push(n);
            }), r;
        }
        function ee(n, t, r, e, u) {
            var i = -1, o = n.length;
            for(r || (r = Li), u || (u = []); ++i < o;){
                var f = n[i];
                t > 0 && r(f) ? t > 1 ? ee(f, t - 1, r, e, u) : a(u, f) : e || (u[u.length] = f);
            }
            return u;
        }
        function ue(n, t) {
            return n && bs(n, t, Pc);
        }
        function oe(n, t) {
            return n && ws(n, t, Pc);
        }
        function fe(n, t) {
            return i(t, function(t) {
                return uc(n[t]);
            });
        }
        function _e(n, t) {
            t = ku(t, n);
            for(var r = 0, e = t.length; null != n && r < e;)n = n[no(t[r++])];
            return r && r == e ? n : X;
        }
        function de(n, t, r) {
            var e = t(n);
            return bh(n) ? e : a(e, r(n));
        }
        function we(n) {
            return null == n ? n === X ? ut : Jn : Bl && Bl in ll(n) ? ki(n) : Ki(n);
        }
        function me(n, t) {
            return n > t;
        }
        function xe(n, t) {
            return null != n && bl.call(n, t);
        }
        function je(n, t) {
            return null != n && t in ll(n);
        }
        function Ae(n, t, r) {
            return n >= Hl(t, r) && n < Gl(t, r);
        }
        function ke(n, t, r) {
            for(var e = r ? f : o, u = n[0].length, i = n.length, a = i, l = il(i), s = 1 / 0, h = []; a--;){
                var p = n[a];
                a && t && (p = c(p, z(t))), s = Hl(p.length, s), l[a] = !r && (t || u >= 120 && p.length >= 120) ? new yr(a && p) : X;
            }
            p = n[0];
            var _ = -1, v = l[0];
            n: for(; ++_ < u && h.length < s;){
                var g = p[_], y = t ? t(g) : g;
                if (g = r || 0 !== g ? g : 0, !(v ? S(v, y) : e(h, y, r))) {
                    for(a = i; --a;){
                        var d = l[a];
                        if (!(d ? S(d, y) : e(n[a], y, r))) continue n;
                    }
                    v && v.push(y), h.push(g);
                }
            }
            return h;
        }
        function Oe(n, t, r, e) {
            return ue(n, function(n, u, i) {
                t(e, r(n), u, i);
            }), e;
        }
        function Ie(t, r, e) {
            r = ku(r, t), t = Gi(t, r);
            var u = null == t ? t : t[no(jo(r))];
            return null == u ? X : n(u, t, e);
        }
        function Re(n) {
            return cc(n) && we(n) == Dn;
        }
        function ze(n) {
            return cc(n) && we(n) == ft;
        }
        function Ee(n) {
            return cc(n) && we(n) == Pn;
        }
        function Se(n, t, r, e, u) {
            return n === t || (null == n || null == t || !cc(n) && !cc(t) ? n !== n && t !== t : We(n, t, r, e, Se, u));
        }
        function We(n, t, r, e, u, i) {
            var o = bh(n), f = bh(t), c = o ? Mn : zs(n), a = f ? Mn : zs(t);
            c = c == Dn ? Yn : c, a = a == Dn ? Yn : a;
            var l = c == Yn, s = a == Yn, h = c == a;
            if (h && mh(n)) {
                if (!mh(t)) return !1;
                o = !0, l = !1;
            }
            if (h && !l) return i || (i = new wr), o || Oh(n) ? pi(n, t, r, e, u, i) : _i(n, t, c, r, e, u, i);
            if (!(r & hn)) {
                var p = l && bl.call(n, "__wrapped__"), _ = s && bl.call(t, "__wrapped__");
                if (p || _) {
                    var v = p ? n.value() : n, g = _ ? t.value() : t;
                    return i || (i = new wr), u(v, g, r, e, i);
                }
            }
            return !!h && (i || (i = new wr), vi(n, t, r, e, u, i));
        }
        function Le(n) {
            return cc(n) && zs(n) == Gn;
        }
        function Ce(n, t, r, e) {
            var u = r.length, i = u, o = !e;
            if (null == n) return !i;
            for(n = ll(n); u--;){
                var f = r[u];
                if (o && f[2] ? f[1] !== n[f[0]] : !(f[0] in n)) return !1;
            }
            for(; ++u < i;){
                f = r[u];
                var c = f[0], a = n[c], l = f[1];
                if (o && f[2]) {
                    if (a === X && !(c in n)) return !1;
                } else {
                    var s = new wr;
                    if (e) var h = e(a, l, c, n, t, s);
                    if (!(h === X ? Se(l, a, hn | pn, e, s) : h)) return !1;
                }
            }
            return !0;
        }
        function Ue(n) {
            return !(!fc(n) || Di(n)) && (uc(n) ? kl : Zt).test(to(n));
        }
        function Be(n) {
            return cc(n) && we(n) == nt;
        }
        function Te(n) {
            return cc(n) && zs(n) == tt;
        }
        function $e(n) {
            return cc(n) && oc(n.length) && !!Kr[we(n)];
        }
        function De(n) {
            return "function" == typeof n ? n : null == n ? La : "object" == typeof n ? bh(n) ? Ze(n[0], n[1]) : qe(n) : Fa(n);
        }
        function Me(n) {
            if (!Mi(n)) return Vl(n);
            var t = [];
            for(var r in ll(n))bl.call(n, r) && "constructor" != r && t.push(r);
            return t;
        }
        function Fe(n) {
            if (!fc(n)) return Zi(n);
            var t = Mi(n), r = [];
            for(var e in n)("constructor" != e || !t && bl.call(n, e)) && r.push(e);
            return r;
        }
        function Ne(n, t) {
            return n < t;
        }
        function Pe(n, t) {
            var r = -1, e = Hf(n) ? il(n.length) : [];
            return ys(n, function(n, u, i) {
                e[++r] = t(n, u, i);
            }), e;
        }
        function qe(n) {
            var t = ji(n);
            return 1 == t.length && t[0][2] ? Ni(t[0][0], t[0][1]) : function(r) {
                return r === n || Ce(r, n, t);
            };
        }
        function Ze(n, t) {
            return Bi(n) && Fi(t) ? Ni(no(n), t) : function(r) {
                var e = Mc(r, n);
                return e === X && e === t ? Nc(r, n) : Se(t, e, hn | pn);
            };
        }
        function Ke(n, t, r, e, u) {
            n !== t && bs(t, function(i, o) {
                if (u || (u = new wr), fc(i)) Ve(n, t, o, r, Ke, e, u);
                else {
                    var f = e ? e(Ji(n, o), i, o + "", n, t, u) : X;
                    f === X && (f = i), Er(n, o, f);
                }
            }, qc);
        }
        function Ve(n, t, r, e, u, i, o) {
            var f = Ji(n, r), c = Ji(t, r), a = o.get(c);
            if (a) return Er(n, r, a), X;
            var l = i ? i(f, c, r + "", n, t, o) : X, s = l === X;
            if (s) {
                var h = bh(c), p = !h && mh(c), _ = !h && !p && Oh(c);
                l = c, h || p || _ ? bh(f) ? l = f : Jf(f) ? l = Tu(f) : p ? (s = !1, l = Iu(c, !0)) : _ ? (s = !1, l = Wu(c, !0)) : l = [] : gc(c) || dh(c) ? (l = f, dh(f) ? l = Rc(f) : fc(f) && !uc(f) || (l = Ei(c))) : s = !1;
            }
            s && (o.set(c, l), u(l, c, e, i, o), o.delete(c)), Er(n, r, l);
        }
        function Ge(n, t) {
            var r = n.length;
            if (r) return t += t < 0 ? r : 0, Ci(t, r) ? n[t] : X;
        }
        function He(n, t, r) {
            t = t.length ? c(t, function(n) {
                return bh(n) ? function(t) {
                    return _e(t, 1 === n.length ? n[0] : n);
                } : n;
            }) : [
                La
            ];
            var e = -1;
            return t = c(t, z(mi())), A(Pe(n, function(n, r, u) {
                return {
                    criteria: c(t, function(t) {
                        return t(n);
                    }),
                    index: ++e,
                    value: n
                };
            }), function(n, t) {
                return Cu(n, t, r);
            });
        }
        function Je(n, t) {
            return Ye(n, t, function(t, r) {
                return Nc(n, r);
            });
        }
        function Ye(n, t, r) {
            for(var e = -1, u = t.length, i = {}; ++e < u;){
                var o = t[e], f = _e(n, o);
                r(f, o) && fu(i, ku(o, n), f);
            }
            return i;
        }
        function Qe(n) {
            return function(t) {
                return _e(t, n);
            };
        }
        function Xe(n, t, r, e) {
            var u = e ? d : y, i = -1, o = t.length, f = n;
            for(n === t && (t = Tu(t)), r && (f = c(n, z(r))); ++i < o;)for(var a = 0, l = t[i], s = r ? r(l) : l; (a = u(f, s, a, e)) > -1;)f !== n && Ll.call(f, a, 1), Ll.call(n, a, 1);
            return n;
        }
        function nu(n, t) {
            for(var r = n ? t.length : 0, e = r - 1; r--;){
                var u = t[r];
                if (r == e || u !== i) {
                    var i = u;
                    Ci(u) ? Ll.call(n, u, 1) : yu(n, u);
                }
            }
            return n;
        }
        function tu(n, t) {
            return n + Nl(Ql() * (t - n + 1));
        }
        function ru(n, t, r, e) {
            for(var u = -1, i = Gl(Fl((t - n) / (r || 1)), 0), o = il(i); i--;)o[e ? i : ++u] = n, n += r;
            return o;
        }
        function eu(n, t) {
            var r = "";
            if (!n || t < 1 || t > Wn) return r;
            do t % 2 && (r += n), t = Nl(t / 2), t && (n += n);
            while (t);
            return r;
        }
        function uu(n, t) {
            return Ls(Vi(n, t, La), n + "");
        }
        function iu(n) {
            return Ir(ra(n));
        }
        function ou(n, t) {
            var r = ra(n);
            return Xi(r, Mr(t, 0, r.length));
        }
        function fu(n, t, r, e) {
            if (!fc(n)) return n;
            t = ku(t, n);
            for(var u = -1, i = t.length, o = i - 1, f = n; null != f && ++u < i;){
                var c = no(t[u]), a = r;
                if ("__proto__" === c || "constructor" === c || "prototype" === c) return n;
                if (u != o) {
                    var l = f[c];
                    a = e ? e(l, c, f) : X, a === X && (a = fc(l) ? l : Ci(t[u + 1]) ? [] : {});
                }
                Sr(f, c, a), f = f[c];
            }
            return n;
        }
        function cu(n) {
            return Xi(ra(n));
        }
        function au(n, t, r) {
            var e = -1, u = n.length;
            t < 0 && (t = -t > u ? 0 : u + t), r = r > u ? u : r, r < 0 && (r += u), u = t > r ? 0 : r - t >>> 0, t >>>= 0;
            for(var i = il(u); ++e < u;)i[e] = n[e + t];
            return i;
        }
        function lu(n, t) {
            var r;
            return ys(n, function(n, e, u) {
                return r = t(n, e, u), !r;
            }), !!r;
        }
        function su(n, t, r) {
            var e = 0, u = null == n ? e : n.length;
            if ("number" == typeof t && t === t && u <= Tn) {
                for(; e < u;){
                    var i = e + u >>> 1, o = n[i];
                    null !== o && !bc(o) && (r ? o <= t : o < t) ? e = i + 1 : u = i;
                }
                return u;
            }
            return hu(n, t, La, r);
        }
        function hu(n, t, r, e) {
            var u = 0, i = null == n ? 0 : n.length;
            if (0 === i) return 0;
            t = r(t);
            for(var o = t !== t, f = null === t, c = bc(t), a = t === X; u < i;){
                var l = Nl((u + i) / 2), s = r(n[l]), h = s !== X, p = null === s, _ = s === s, v = bc(s);
                if (o) var g = e || _;
                else g = a ? _ && (e || h) : f ? _ && h && (e || !p) : c ? _ && h && !p && (e || !v) : !p && !v && (e ? s <= t : s < t);
                g ? u = l + 1 : i = l;
            }
            return Hl(i, Bn);
        }
        function pu(n, t) {
            for(var r = -1, e = n.length, u = 0, i = []; ++r < e;){
                var o = n[r], f = t ? t(o) : o;
                if (!r || !Gf(f, c)) {
                    var c = f;
                    i[u++] = 0 === o ? 0 : o;
                }
            }
            return i;
        }
        function _u(n) {
            return "number" == typeof n ? n : bc(n) ? Cn : +n;
        }
        function vu(n) {
            if ("string" == typeof n) return n;
            if (bh(n)) return c(n, vu) + "";
            if (bc(n)) return vs ? vs.call(n) : "";
            var t = n + "";
            return "0" == t && 1 / n == -Sn ? "-0" : t;
        }
        function gu(n, t, r) {
            var e = -1, u = o, i = n.length, c = !0, a = [], l = a;
            if (r) c = !1, u = f;
            else if (i >= tn) {
                var s = t ? null : ks(n);
                if (s) return P(s);
                c = !1, u = S, l = new yr;
            } else l = t ? [] : a;
            n: for(; ++e < i;){
                var h = n[e], p = t ? t(h) : h;
                if (h = r || 0 !== h ? h : 0, c && p === p) {
                    for(var _ = l.length; _--;)if (l[_] === p) continue n;
                    t && l.push(p), a.push(h);
                } else u(l, p, r) || (l !== a && l.push(p), a.push(h));
            }
            return a;
        }
        function yu(n, t) {
            return t = ku(t, n), n = Gi(n, t), null == n || delete n[no(jo(t))];
        }
        function du(n, t, r, e) {
            return fu(n, t, r(_e(n, t)), e);
        }
        function bu(n, t, r, e) {
            for(var u = n.length, i = e ? u : -1; (e ? i-- : ++i < u) && t(n[i], i, n););
            return r ? au(n, e ? 0 : i, e ? i + 1 : u) : au(n, e ? i + 1 : 0, e ? u : i);
        }
        function wu(n, t) {
            var r = n;
            return r instanceof Ct && (r = r.value()), l(t, function(n, t) {
                return t.func.apply(t.thisArg, a([
                    n
                ], t.args));
            }, r);
        }
        function mu(n, t, r) {
            var e = n.length;
            if (e < 2) return e ? gu(n[0]) : [];
            for(var u = -1, i = il(e); ++u < e;)for(var o = n[u], f = -1; ++f < e;)f != u && (i[u] = Hr(i[u] || o, n[f], t, r));
            return gu(ee(i, 1), t, r);
        }
        function xu(n, t, r) {
            for(var e = -1, u = n.length, i = t.length, o = {}; ++e < u;)r(o, n[e], e < i ? t[e] : X);
            return o;
        }
        function ju(n) {
            return Jf(n) ? n : [];
        }
        function Au(n) {
            return "function" == typeof n ? n : La;
        }
        function ku(n, t) {
            return bh(n) ? n : Bi(n, t) ? [
                n
            ] : Cs(Ec(n));
        }
        function Ou(n, t, r) {
            var e = n.length;
            return r = r === X ? e : r, !t && r >= e ? n : au(n, t, r);
        }
        function Iu(n, t) {
            if (t) return n.slice();
            var r = n.length, e = zl ? zl(r) : new n.constructor(r);
            return n.copy(e), e;
        }
        function Ru(n) {
            var t = new n.constructor(n.byteLength);
            return new Rl(t).set(new Rl(n)), t;
        }
        function zu(n, t) {
            return new n.constructor(t ? Ru(n.buffer) : n.buffer, n.byteOffset, n.byteLength);
        }
        function Eu(n) {
            var t = new n.constructor(n.source, Nt.exec(n));
            return t.lastIndex = n.lastIndex, t;
        }
        function Su(n) {
            return _s ? ll(_s.call(n)) : {};
        }
        function Wu(n, t) {
            return new n.constructor(t ? Ru(n.buffer) : n.buffer, n.byteOffset, n.length);
        }
        function Lu(n, t) {
            if (n !== t) {
                var r = n !== X, e = null === n, u = n === n, i = bc(n), o = t !== X, f = null === t, c = t === t, a = bc(t);
                if (!f && !a && !i && n > t || i && o && c && !f && !a || e && o && c || !r && c || !u) return 1;
                if (!e && !i && !a && n < t || a && r && u && !e && !i || f && r && u || !o && u || !c) return -1;
            }
            return 0;
        }
        function Cu(n, t, r) {
            for(var e = -1, u = n.criteria, i = t.criteria, o = u.length, f = r.length; ++e < o;){
                var c = Lu(u[e], i[e]);
                if (c) {
                    if (e >= f) return c;
                    return c * ("desc" == r[e] ? -1 : 1);
                }
            }
            return n.index - t.index;
        }
        function Uu(n, t, r, e) {
            for(var u = -1, i = n.length, o = r.length, f = -1, c = t.length, a = Gl(i - o, 0), l = il(c + a), s = !e; ++f < c;)l[f] = t[f];
            for(; ++u < o;)(s || u < i) && (l[r[u]] = n[u]);
            for(; a--;)l[f++] = n[u++];
            return l;
        }
        function Bu(n, t, r, e) {
            for(var u = -1, i = n.length, o = -1, f = r.length, c = -1, a = t.length, l = Gl(i - f, 0), s = il(l + a), h = !e; ++u < l;)s[u] = n[u];
            for(var p = u; ++c < a;)s[p + c] = t[c];
            for(; ++o < f;)(h || u < i) && (s[p + r[o]] = n[u++]);
            return s;
        }
        function Tu(n, t) {
            var r = -1, e = n.length;
            for(t || (t = il(e)); ++r < e;)t[r] = n[r];
            return t;
        }
        function $u(n, t, r, e) {
            var u = !r;
            r || (r = {});
            for(var i = -1, o = t.length; ++i < o;){
                var f = t[i], c = e ? e(r[f], n[f], f, r, n) : X;
                c === X && (c = n[f]), u ? Br(r, f, c) : Sr(r, f, c);
            }
            return r;
        }
        function Du(n, t) {
            return $u(n, Is(n), t);
        }
        function Mu(n, t) {
            return $u(n, Rs(n), t);
        }
        function Fu(n, r) {
            return function(e, u) {
                var i = bh(e) ? t : Lr, o = r ? r() : {};
                return i(e, n, mi(u, 2), o);
            };
        }
        function Nu(n) {
            return uu(function(t, r) {
                var e = -1, u = r.length, i = u > 1 ? r[u - 1] : X, o = u > 2 ? r[2] : X;
                for(i = n.length > 3 && "function" == typeof i ? (u--, i) : X, o && Ui(r[0], r[1], o) && (i = u < 3 ? X : i, u = 1), t = ll(t); ++e < u;){
                    var f = r[e];
                    f && n(t, f, e, i);
                }
                return t;
            });
        }
        function Pu(n, t) {
            return function(r, e) {
                if (null == r) return r;
                if (!Hf(r)) return n(r, e);
                for(var u = r.length, i = t ? u : -1, o = ll(r); (t ? i-- : ++i < u) && e(o[i], i, o) !== !1;);
                return r;
            };
        }
        function qu(n) {
            return function(t, r, e) {
                for(var u = -1, i = ll(t), o = e(t), f = o.length; f--;){
                    var c = o[n ? f : ++u];
                    if (r(i[c], c, i) === !1) break;
                }
                return t;
            };
        }
        function Zu(n, t, r) {
            function e() {
                return (this && this !== re && this instanceof e ? i : n).apply(u ? r : this, arguments);
            }
            var u = t & _n, i = Gu(n);
            return e;
        }
        function Ku(n) {
            return function(t) {
                t = Ec(t);
                var r = T(t) ? G(t) : X, e = r ? r[0] : t.charAt(0), u = r ? Ou(r, 1).join("") : t.slice(1);
                return e[n]() + u;
            };
        }
        function Vu(n) {
            return function(t) {
                return l(Ra(ca(t).replace($r, "")), n, "");
            };
        }
        function Gu(n) {
            return function() {
                var t = arguments;
                switch(t.length){
                    case 0:
                        return new n;
                    case 1:
                        return new n(t[0]);
                    case 2:
                        return new n(t[0], t[1]);
                    case 3:
                        return new n(t[0], t[1], t[2]);
                    case 4:
                        return new n(t[0], t[1], t[2], t[3]);
                    case 5:
                        return new n(t[0], t[1], t[2], t[3], t[4]);
                    case 6:
                        return new n(t[0], t[1], t[2], t[3], t[4], t[5]);
                    case 7:
                        return new n(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
                }
                var r = gs(n.prototype), e = n.apply(r, t);
                return fc(e) ? e : r;
            };
        }
        function Hu(t, r, e) {
            function u() {
                for(var o = arguments.length, f = il(o), c = o, a = wi(u); c--;)f[c] = arguments[c];
                var l = o < 3 && f[0] !== a && f[o - 1] !== a ? [] : N(f, a);
                return o -= l.length, o < e ? oi(t, r, Qu, u.placeholder, X, f, l, X, X, e - o) : n(this && this !== re && this instanceof u ? i : t, this, f);
            }
            var i = Gu(t);
            return u;
        }
        function Ju(n) {
            return function(t, r, e) {
                var u = ll(t);
                if (!Hf(t)) {
                    var i = mi(r, 3);
                    t = Pc(t), r = function(n) {
                        return i(u[n], n, u);
                    };
                }
                var o = n(t, r, e);
                return o > -1 ? u[i ? t[o] : o] : X;
            };
        }
        function Yu(n) {
            return gi(function(t) {
                var r = t.length, e = r, u = Y.prototype.thru;
                for(n && t.reverse(); e--;){
                    var i = t[e];
                    if ("function" != typeof i) throw new pl(en);
                    if (u && !o && "wrapper" == bi(i)) var o = new Y([], !0);
                }
                for(e = o ? e : r; ++e < r;){
                    i = t[e];
                    var f = bi(i), c = "wrapper" == f ? Os(i) : X;
                    o = c && $i(c[0]) && c[1] == (mn | yn | bn | xn) && !c[4].length && 1 == c[9] ? o[bi(c[0])].apply(o, c[3]) : 1 == i.length && $i(i) ? o[f]() : o.thru(i);
                }
                return function() {
                    var n = arguments, e = n[0];
                    if (o && 1 == n.length && bh(e)) return o.plant(e).value();
                    for(var u = 0, i = r ? t[u].apply(this, n) : e; ++u < r;)i = t[u].call(this, i);
                    return i;
                };
            });
        }
        function Qu(n, t, r, e, u, i, o, f, c, a) {
            function l() {
                for(var y = arguments.length, d = il(y), b = y; b--;)d[b] = arguments[b];
                if (_) var w = wi(l), m = C(d, w);
                if (e && (d = Uu(d, e, u, _)), i && (d = Bu(d, i, o, _)), y -= m, _ && y < a) return oi(n, t, Qu, l.placeholder, r, d, N(d, w), f, c, a - y);
                var x = h ? r : this, j = p ? x[n] : n;
                return y = d.length, f ? d = Hi(d, f) : v && y > 1 && d.reverse(), s && c < y && (d.length = c), this && this !== re && this instanceof l && (j = g || Gu(j)), j.apply(x, d);
            }
            var s = t & mn, h = t & _n, p = t & vn, _ = t & (yn | dn), v = t & jn, g = p ? X : Gu(n);
            return l;
        }
        function Xu(n, t) {
            return function(r, e) {
                return Oe(r, n, t(e), {});
            };
        }
        function ni(n, t) {
            return function(r, e) {
                var u;
                if (r === X && e === X) return t;
                if (r !== X && (u = r), e !== X) {
                    if (u === X) return e;
                    "string" == typeof r || "string" == typeof e ? (r = vu(r), e = vu(e)) : (r = _u(r), e = _u(e)), u = n(r, e);
                }
                return u;
            };
        }
        function ti(t) {
            return gi(function(r) {
                return r = c(r, z(mi())), uu(function(e) {
                    var u = this;
                    return t(r, function(t) {
                        return n(t, u, e);
                    });
                });
            });
        }
        function ri(n, t) {
            t = t === X ? " " : vu(t);
            var r = t.length;
            if (r < 2) return r ? eu(t, n) : t;
            var e = eu(t, Fl(n / V(t)));
            return T(t) ? Ou(G(e), 0, n).join("") : e.slice(0, n);
        }
        function ei(t, r, e, u) {
            function i() {
                for(var r = -1, c = arguments.length, a = -1, l = u.length, s = il(l + c), h = this && this !== re && this instanceof i ? f : t; ++a < l;)s[a] = u[a];
                for(; c--;)s[a++] = arguments[++r];
                return n(h, o ? e : this, s);
            }
            var o = r & _n, f = Gu(t);
            return i;
        }
        function ui(n) {
            return function(t, r, e) {
                return e && "number" != typeof e && Ui(t, r, e) && (r = e = X), t = Ac(t), r === X ? (r = t, t = 0) : r = Ac(r), e = e === X ? t < r ? 1 : -1 : Ac(e), ru(t, r, e, n);
            };
        }
        function ii(n) {
            return function(t, r) {
                return "string" == typeof t && "string" == typeof r || (t = Ic(t), r = Ic(r)), n(t, r);
            };
        }
        function oi(n, t, r, e, u, i, o, f, c, a) {
            var l = t & yn, s = l ? o : X, h = l ? X : o, p = l ? i : X, _ = l ? X : i;
            t |= l ? bn : wn, t &= ~(l ? wn : bn), t & gn || (t &= ~(_n | vn));
            var v = [
                n,
                t,
                u,
                p,
                s,
                _,
                h,
                f,
                c,
                a
            ], g = r.apply(X, v);
            return $i(n) && Ss(g, v), g.placeholder = e, Yi(g, n, t);
        }
        function fi(n) {
            var t = al[n];
            return function(n, r) {
                if (n = Ic(n), r = null == r ? 0 : Hl(kc(r), 292), r && Zl(n)) {
                    var e = (Ec(n) + "e").split("e");
                    return e = (Ec(t(e[0] + "e" + (+e[1] + r))) + "e").split("e"), +(e[0] + "e" + (+e[1] - r));
                }
                return t(n);
            };
        }
        function ci(n) {
            return function(t) {
                var r = zs(t);
                return r == Gn ? M(t) : r == tt ? q(t) : I(t, n(t));
            };
        }
        function ai(n, t, r, e, u, i, o, f) {
            var c = t & vn;
            if (!c && "function" != typeof n) throw new pl(en);
            var a = e ? e.length : 0;
            if (a || (t &= ~(bn | wn), e = u = X), o = o === X ? o : Gl(kc(o), 0), f = f === X ? f : kc(f), a -= u ? u.length : 0, t & wn) {
                var l = e, s = u;
                e = u = X;
            }
            var h = c ? X : Os(n), p = [
                n,
                t,
                r,
                e,
                u,
                l,
                s,
                i,
                o,
                f
            ];
            if (h && qi(p, h), n = p[0], t = p[1], r = p[2], e = p[3], u = p[4], f = p[9] = p[9] === X ? c ? 0 : n.length : Gl(p[9] - a, 0), !f && t & (yn | dn) && (t &= ~(yn | dn)), t && t != _n) _ = t == yn || t == dn ? Hu(n, t, f) : t != bn && t != (_n | bn) || u.length ? Qu.apply(X, p) : ei(n, t, r, e);
            else var _ = Zu(n, t, r);
            return Yi((h ? ms : Ss)(_, p), n, t);
        }
        function li(n, t, r, e) {
            return n === X || Gf(n, gl[r]) && !bl.call(e, r) ? t : n;
        }
        function si(n, t, r, e, u, i) {
            return fc(n) && fc(t) && (i.set(t, n), Ke(n, t, X, si, i), i.delete(t)), n;
        }
        function hi(n) {
            return gc(n) ? X : n;
        }
        function pi(n, t, r, e, u, i) {
            var o = r & hn, f = n.length, c = t.length;
            if (f != c && !(o && c > f)) return !1;
            var a = i.get(n), l = i.get(t);
            if (a && l) return a == t && l == n;
            var s = -1, p = !0, _ = r & pn ? new yr : X;
            for(i.set(n, t), i.set(t, n); ++s < f;){
                var v = n[s], g = t[s];
                if (e) var y = o ? e(g, v, s, t, n, i) : e(v, g, s, n, t, i);
                if (y !== X) {
                    if (y) continue;
                    p = !1;
                    break;
                }
                if (_) {
                    if (!h(t, function(n, t) {
                        if (!S(_, t) && (v === n || u(v, n, r, e, i))) return _.push(t);
                    })) {
                        p = !1;
                        break;
                    }
                } else if (v !== g && !u(v, g, r, e, i)) {
                    p = !1;
                    break;
                }
            }
            return i.delete(n), i.delete(t), p;
        }
        function _i(n, t, r, e, u, i, o) {
            switch(r){
                case ct:
                    if (n.byteLength != t.byteLength || n.byteOffset != t.byteOffset) return !1;
                    n = n.buffer, t = t.buffer;
                case ft:
                    return !(n.byteLength != t.byteLength || !i(new Rl(n), new Rl(t)));
                case Nn:
                case Pn:
                case Hn:
                    return Gf(+n, +t);
                case Zn:
                    return n.name == t.name && n.message == t.message;
                case nt:
                case rt:
                    return n == t + "";
                case Gn:
                    var f = M;
                case tt:
                    var c = e & hn;
                    if (f || (f = P), n.size != t.size && !c) return !1;
                    var a = o.get(n);
                    if (a) return a == t;
                    e |= pn, o.set(n, t);
                    var l = pi(f(n), f(t), e, u, i, o);
                    return o.delete(n), l;
                case et:
                    if (_s) return _s.call(n) == _s.call(t);
            }
            return !1;
        }
        function vi(n, t, r, e, u, i) {
            var o = r & hn, f = yi(n), c = f.length;
            if (c != yi(t).length && !o) return !1;
            for(var a = c; a--;){
                var l = f[a];
                if (!(o ? l in t : bl.call(t, l))) return !1;
            }
            var s = i.get(n), h = i.get(t);
            if (s && h) return s == t && h == n;
            var p = !0;
            i.set(n, t), i.set(t, n);
            for(var _ = o; ++a < c;){
                l = f[a];
                var v = n[l], g = t[l];
                if (e) var y = o ? e(g, v, l, t, n, i) : e(v, g, l, n, t, i);
                if (!(y === X ? v === g || u(v, g, r, e, i) : y)) {
                    p = !1;
                    break;
                }
                _ || (_ = "constructor" == l);
            }
            if (p && !_) {
                var d = n.constructor, b = t.constructor;
                d != b && "constructor" in n && "constructor" in t && !("function" == typeof d && d instanceof d && "function" == typeof b && b instanceof b) && (p = !1);
            }
            return i.delete(n), i.delete(t), p;
        }
        function gi(n) {
            return Ls(Vi(n, X, _o), n + "");
        }
        function yi(n) {
            return de(n, Pc, Is);
        }
        function di(n) {
            return de(n, qc, Rs);
        }
        function bi(n) {
            for(var t = n.name + "", r = fs[t], e = bl.call(fs, t) ? r.length : 0; e--;){
                var u = r[e], i = u.func;
                if (null == i || i == n) return u.name;
            }
            return t;
        }
        function wi(n) {
            return (bl.call(Z, "placeholder") ? Z : n).placeholder;
        }
        function mi() {
            var n = Z.iteratee || Ca;
            return n = n === Ca ? De : n, arguments.length ? n(arguments[0], arguments[1]) : n;
        }
        function xi(n, t) {
            var r = n.__data__;
            return Ti(t) ? r["string" == typeof t ? "string" : "hash"] : r.map;
        }
        function ji(n) {
            for(var t = Pc(n), r = t.length; r--;){
                var e = t[r], u = n[e];
                t[r] = [
                    e,
                    u,
                    Fi(u)
                ];
            }
            return t;
        }
        function Ai(n, t) {
            var r = B(n, t);
            return Ue(r) ? r : X;
        }
        function ki(n) {
            var t = bl.call(n, Bl), r = n[Bl];
            try {
                n[Bl] = X;
                var e = !0;
            } catch (n1) {}
            var u = xl.call(n);
            return e && (t ? n[Bl] = r : delete n[Bl]), u;
        }
        function Oi(n, t, r) {
            for(var e = -1, u = r.length; ++e < u;){
                var i = r[e], o = i.size;
                switch(i.type){
                    case "drop":
                        n += o;
                        break;
                    case "dropRight":
                        t -= o;
                        break;
                    case "take":
                        t = Hl(t, n + o);
                        break;
                    case "takeRight":
                        n = Gl(n, t - o);
                }
            }
            return {
                start: n,
                end: t
            };
        }
        function Ii(n) {
            var t = n.match(Bt);
            return t ? t[1].split(Tt) : [];
        }
        function Ri(n, t, r) {
            t = ku(t, n);
            for(var e = -1, u = t.length, i = !1; ++e < u;){
                var o = no(t[e]);
                if (!(i = null != n && r(n, o))) break;
                n = n[o];
            }
            return i || ++e != u ? i : (u = null == n ? 0 : n.length, !!u && oc(u) && Ci(o, u) && (bh(n) || dh(n)));
        }
        function zi(n) {
            var t = n.length, r = new n.constructor(t);
            return t && "string" == typeof n[0] && bl.call(n, "index") && (r.index = n.index, r.input = n.input), r;
        }
        function Ei(n) {
            return "function" != typeof n.constructor || Mi(n) ? {} : gs(El(n));
        }
        function Si(n, t, r) {
            var e = n.constructor;
            switch(t){
                case ft:
                    return Ru(n);
                case Nn:
                case Pn:
                    return new e(+n);
                case ct:
                    return zu(n, r);
                case at:
                case lt:
                case st:
                case ht:
                case pt:
                case _t:
                case vt:
                case gt:
                case yt:
                    return Wu(n, r);
                case Gn:
                    return new e;
                case Hn:
                case rt:
                    return new e(n);
                case nt:
                    return Eu(n);
                case tt:
                    return new e;
                case et:
                    return Su(n);
            }
        }
        function Wi(n, t) {
            var r = t.length;
            if (!r) return n;
            var e = r - 1;
            return t[e] = (r > 1 ? "& " : "") + t[e], t = t.join(r > 2 ? ", " : " "), n.replace(Ut, "{\n/* [wrapped with " + t + "] */\n");
        }
        function Li(n) {
            return bh(n) || dh(n) || !!(Cl && n && n[Cl]);
        }
        function Ci(n, t) {
            var r = typeof n;
            return t = null == t ? Wn : t, !!t && ("number" == r || "symbol" != r && Vt.test(n)) && n > -1 && n % 1 == 0 && n < t;
        }
        function Ui(n, t, r) {
            if (!fc(r)) return !1;
            var e = typeof t;
            return !!("number" == e ? Hf(r) && Ci(t, r.length) : "string" == e && t in r) && Gf(r[t], n);
        }
        function Bi(n, t) {
            if (bh(n)) return !1;
            var r = typeof n;
            return !("number" != r && "symbol" != r && "boolean" != r && null != n && !bc(n)) || zt.test(n) || !Rt.test(n) || null != t && n in ll(t);
        }
        function Ti(n) {
            var t = typeof n;
            return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== n : null === n;
        }
        function $i(n) {
            var t = bi(n), r = Z[t];
            if ("function" != typeof r || !(t in Ct.prototype)) return !1;
            if (n === r) return !0;
            var e = Os(r);
            return !!e && n === e[0];
        }
        function Di(n) {
            return !!ml && ml in n;
        }
        function Mi(n) {
            var t = n && n.constructor;
            return n === ("function" == typeof t && t.prototype || gl);
        }
        function Fi(n) {
            return n === n && !fc(n);
        }
        function Ni(n, t) {
            return function(r) {
                return null != r && r[n] === t && (t !== X || n in ll(r));
            };
        }
        function Pi(n) {
            var t = Cf(n, function(n) {
                return r.size === fn && r.clear(), n;
            }), r = t.cache;
            return t;
        }
        function qi(n, t) {
            var r = n[1], e = t[1], u = r | e, i = u < (_n | vn | mn), o = e == mn && r == yn || e == mn && r == xn && n[7].length <= t[8] || e == (mn | xn) && t[7].length <= t[8] && r == yn;
            if (!i && !o) return n;
            e & _n && (n[2] = t[2], u |= r & _n ? 0 : gn);
            var f = t[3];
            if (f) {
                var c = n[3];
                n[3] = c ? Uu(c, f, t[4]) : f, n[4] = c ? N(n[3], cn) : t[4];
            }
            return f = t[5], f && (c = n[5], n[5] = c ? Bu(c, f, t[6]) : f, n[6] = c ? N(n[5], cn) : t[6]), f = t[7], f && (n[7] = f), e & mn && (n[8] = null == n[8] ? t[8] : Hl(n[8], t[8])), null == n[9] && (n[9] = t[9]), n[0] = t[0], n[1] = u, n;
        }
        function Zi(n) {
            var t = [];
            if (null != n) for(var r in ll(n))t.push(r);
            return t;
        }
        function Ki(n) {
            return xl.call(n);
        }
        function Vi(t, r, e) {
            return r = Gl(r === X ? t.length - 1 : r, 0), function() {
                for(var u = arguments, i = -1, o = Gl(u.length - r, 0), f = il(o); ++i < o;)f[i] = u[r + i];
                i = -1;
                for(var c = il(r + 1); ++i < r;)c[i] = u[i];
                return c[r] = e(f), n(t, this, c);
            };
        }
        function Gi(n, t) {
            return t.length < 2 ? n : _e(n, au(t, 0, -1));
        }
        function Hi(n, t) {
            for(var r = n.length, e = Hl(t.length, r), u = Tu(n); e--;){
                var i = t[e];
                n[e] = Ci(i, r) ? u[i] : X;
            }
            return n;
        }
        function Ji(n, t) {
            if (("constructor" !== t || "function" != typeof n[t]) && "__proto__" != t) return n[t];
        }
        function Yi(n, t, r) {
            var e = t + "";
            return Ls(n, Wi(e, ro(Ii(e), r)));
        }
        function Qi(n) {
            var t = 0, r = 0;
            return function() {
                var e = Jl(), u = In - (e - r);
                if (r = e, u > 0) {
                    if (++t >= On) return arguments[0];
                } else t = 0;
                return n.apply(X, arguments);
            };
        }
        function Xi(n, t) {
            var r = -1, e = n.length, u = e - 1;
            for(t = t === X ? e : t; ++r < t;){
                var i = tu(r, u), o = n[i];
                n[i] = n[r], n[r] = o;
            }
            return n.length = t, n;
        }
        function no(n) {
            if ("string" == typeof n || bc(n)) return n;
            var t = n + "";
            return "0" == t && 1 / n == -Sn ? "-0" : t;
        }
        function to(n) {
            if (null != n) {
                try {
                    return dl.call(n);
                } catch (n1) {}
                try {
                    return n + "";
                } catch (n2) {}
            }
            return "";
        }
        function ro(n, t) {
            return r($n, function(r) {
                var e = "_." + r[0];
                t & r[1] && !o(n, e) && n.push(e);
            }), n.sort();
        }
        function eo(n) {
            if (n instanceof Ct) return n.clone();
            var t = new Y(n.__wrapped__, n.__chain__);
            return t.__actions__ = Tu(n.__actions__), t.__index__ = n.__index__, t.__values__ = n.__values__, t;
        }
        function uo(n, t, r) {
            t = (r ? Ui(n, t, r) : t === X) ? 1 : Gl(kc(t), 0);
            var e = null == n ? 0 : n.length;
            if (!e || t < 1) return [];
            for(var u = 0, i = 0, o = il(Fl(e / t)); u < e;)o[i++] = au(n, u, u += t);
            return o;
        }
        function io(n) {
            for(var t = -1, r = null == n ? 0 : n.length, e = 0, u = []; ++t < r;){
                var i = n[t];
                i && (u[e++] = i);
            }
            return u;
        }
        function oo() {
            var n = arguments.length;
            if (!n) return [];
            for(var t = il(n - 1), r = arguments[0], e = n; e--;)t[e - 1] = arguments[e];
            return a(bh(r) ? Tu(r) : [
                r
            ], ee(t, 1));
        }
        function fo(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (t = r || t === X ? 1 : kc(t), au(n, t < 0 ? 0 : t, e)) : [];
        }
        function co(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (t = r || t === X ? 1 : kc(t), t = e - t, au(n, 0, t < 0 ? 0 : t)) : [];
        }
        function ao(n, t) {
            return n && n.length ? bu(n, mi(t, 3), !0, !0) : [];
        }
        function lo(n, t) {
            return n && n.length ? bu(n, mi(t, 3), !0) : [];
        }
        function so(n, t, r, e) {
            var u = null == n ? 0 : n.length;
            return u ? (r && "number" != typeof r && Ui(n, t, r) && (r = 0, e = u), ne(n, t, r, e)) : [];
        }
        function ho(n, t, r) {
            var e = null == n ? 0 : n.length;
            if (!e) return -1;
            var u = null == r ? 0 : kc(r);
            return u < 0 && (u = Gl(e + u, 0)), g(n, mi(t, 3), u);
        }
        function po(n, t, r) {
            var e = null == n ? 0 : n.length;
            if (!e) return -1;
            var u = e - 1;
            return r !== X && (u = kc(r), u = r < 0 ? Gl(e + u, 0) : Hl(u, e - 1)), g(n, mi(t, 3), u, !0);
        }
        function _o(n) {
            return (null == n ? 0 : n.length) ? ee(n, 1) : [];
        }
        function vo(n) {
            return (null == n ? 0 : n.length) ? ee(n, Sn) : [];
        }
        function go(n, t) {
            return (null == n ? 0 : n.length) ? (t = t === X ? 1 : kc(t), ee(n, t)) : [];
        }
        function yo(n) {
            for(var t = -1, r = null == n ? 0 : n.length, e = {}; ++t < r;){
                var u = n[t];
                e[u[0]] = u[1];
            }
            return e;
        }
        function bo(n) {
            return n && n.length ? n[0] : X;
        }
        function wo(n, t, r) {
            var e = null == n ? 0 : n.length;
            if (!e) return -1;
            var u = null == r ? 0 : kc(r);
            return u < 0 && (u = Gl(e + u, 0)), y(n, t, u);
        }
        function mo(n) {
            return (null == n ? 0 : n.length) ? au(n, 0, -1) : [];
        }
        function xo(n, t) {
            return null == n ? "" : Kl.call(n, t);
        }
        function jo(n) {
            var t = null == n ? 0 : n.length;
            return t ? n[t - 1] : X;
        }
        function Ao(n, t, r) {
            var e = null == n ? 0 : n.length;
            if (!e) return -1;
            var u = e;
            return r !== X && (u = kc(r), u = u < 0 ? Gl(e + u, 0) : Hl(u, e - 1)), t === t ? K(n, t, u) : g(n, b, u, !0);
        }
        function ko(n, t) {
            return n && n.length ? Ge(n, kc(t)) : X;
        }
        function Oo(n, t) {
            return n && n.length && t && t.length ? Xe(n, t) : n;
        }
        function Io(n, t, r) {
            return n && n.length && t && t.length ? Xe(n, t, mi(r, 2)) : n;
        }
        function Ro(n, t, r) {
            return n && n.length && t && t.length ? Xe(n, t, X, r) : n;
        }
        function zo(n, t) {
            var r = [];
            if (!n || !n.length) return r;
            var e = -1, u = [], i = n.length;
            for(t = mi(t, 3); ++e < i;){
                var o = n[e];
                t(o, e, n) && (r.push(o), u.push(e));
            }
            return nu(n, u), r;
        }
        function Eo(n) {
            return null == n ? n : Xl.call(n);
        }
        function So(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (r && "number" != typeof r && Ui(n, t, r) ? (t = 0, r = e) : (t = null == t ? 0 : kc(t), r = r === X ? e : kc(r)), au(n, t, r)) : [];
        }
        function Wo(n, t) {
            return su(n, t);
        }
        function Lo(n, t, r) {
            return hu(n, t, mi(r, 2));
        }
        function Co(n, t) {
            var r = null == n ? 0 : n.length;
            if (r) {
                var e = su(n, t);
                if (e < r && Gf(n[e], t)) return e;
            }
            return -1;
        }
        function Uo(n, t) {
            return su(n, t, !0);
        }
        function Bo(n, t, r) {
            return hu(n, t, mi(r, 2), !0);
        }
        function To(n, t) {
            if (null == n ? 0 : n.length) {
                var r = su(n, t, !0) - 1;
                if (Gf(n[r], t)) return r;
            }
            return -1;
        }
        function $o(n) {
            return n && n.length ? pu(n) : [];
        }
        function Do(n, t) {
            return n && n.length ? pu(n, mi(t, 2)) : [];
        }
        function Mo(n) {
            var t = null == n ? 0 : n.length;
            return t ? au(n, 1, t) : [];
        }
        function Fo(n, t, r) {
            return n && n.length ? (t = r || t === X ? 1 : kc(t), au(n, 0, t < 0 ? 0 : t)) : [];
        }
        function No(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (t = r || t === X ? 1 : kc(t), t = e - t, au(n, t < 0 ? 0 : t, e)) : [];
        }
        function Po(n, t) {
            return n && n.length ? bu(n, mi(t, 3), !1, !0) : [];
        }
        function qo(n, t) {
            return n && n.length ? bu(n, mi(t, 3)) : [];
        }
        function Zo(n) {
            return n && n.length ? gu(n) : [];
        }
        function Ko(n, t) {
            return n && n.length ? gu(n, mi(t, 2)) : [];
        }
        function Vo(n, t) {
            return t = "function" == typeof t ? t : X, n && n.length ? gu(n, X, t) : [];
        }
        function Go(n) {
            if (!n || !n.length) return [];
            var t = 0;
            return n = i(n, function(n) {
                if (Jf(n)) return t = Gl(n.length, t), !0;
            }), O(t, function(t) {
                return c(n, m(t));
            });
        }
        function Ho(t, r) {
            if (!t || !t.length) return [];
            var e = Go(t);
            return null == r ? e : c(e, function(t) {
                return n(r, X, t);
            });
        }
        function Jo(n, t) {
            return xu(n || [], t || [], Sr);
        }
        function Yo(n, t) {
            return xu(n || [], t || [], fu);
        }
        function Qo(n) {
            var t = Z(n);
            return t.__chain__ = !0, t;
        }
        function Xo(n, t) {
            return t(n), n;
        }
        function nf(n, t) {
            return t(n);
        }
        function tf() {
            return Qo(this);
        }
        function rf() {
            return new Y(this.value(), this.__chain__);
        }
        function ef() {
            this.__values__ === X && (this.__values__ = jc(this.value()));
            var n = this.__index__ >= this.__values__.length;
            return {
                done: n,
                value: n ? X : this.__values__[this.__index__++]
            };
        }
        function uf() {
            return this;
        }
        function of(n) {
            for(var t, r = this; r instanceof J;){
                var e = eo(r);
                e.__index__ = 0, e.__values__ = X, t ? u.__wrapped__ = e : t = e;
                var u = e;
                r = r.__wrapped__;
            }
            return u.__wrapped__ = n, t;
        }
        function ff() {
            var n = this.__wrapped__;
            if (n instanceof Ct) {
                var t = n;
                return this.__actions__.length && (t = new Ct(this)), t = t.reverse(), t.__actions__.push({
                    func: nf,
                    args: [
                        Eo
                    ],
                    thisArg: X
                }), new Y(t, this.__chain__);
            }
            return this.thru(Eo);
        }
        function cf() {
            return wu(this.__wrapped__, this.__actions__);
        }
        function af(n, t, r) {
            var e = bh(n) ? u : Jr;
            return r && Ui(n, t, r) && (t = X), e(n, mi(t, 3));
        }
        function lf(n, t) {
            return (bh(n) ? i : te)(n, mi(t, 3));
        }
        function sf(n, t) {
            return ee(yf(n, t), 1);
        }
        function hf(n, t) {
            return ee(yf(n, t), Sn);
        }
        function pf(n, t, r) {
            return r = r === X ? 1 : kc(r), ee(yf(n, t), r);
        }
        function _f(n, t) {
            return (bh(n) ? r : ys)(n, mi(t, 3));
        }
        function vf(n, t) {
            return (bh(n) ? e : ds)(n, mi(t, 3));
        }
        function gf(n, t, r, e) {
            n = Hf(n) ? n : ra(n), r = r && !e ? kc(r) : 0;
            var u = n.length;
            return r < 0 && (r = Gl(u + r, 0)), dc(n) ? r <= u && n.indexOf(t, r) > -1 : !!u && y(n, t, r) > -1;
        }
        function yf(n, t) {
            return (bh(n) ? c : Pe)(n, mi(t, 3));
        }
        function df(n, t, r, e) {
            return null == n ? [] : (bh(t) || (t = null == t ? [] : [
                t
            ]), r = e ? X : r, bh(r) || (r = null == r ? [] : [
                r
            ]), He(n, t, r));
        }
        function bf(n, t, r) {
            var e = bh(n) ? l : j, u = arguments.length < 3;
            return e(n, mi(t, 4), r, u, ys);
        }
        function wf(n, t, r) {
            var e = bh(n) ? s : j, u = arguments.length < 3;
            return e(n, mi(t, 4), r, u, ds);
        }
        function mf(n, t) {
            return (bh(n) ? i : te)(n, Uf(mi(t, 3)));
        }
        function xf(n) {
            return (bh(n) ? Ir : iu)(n);
        }
        function jf(n, t, r) {
            return t = (r ? Ui(n, t, r) : t === X) ? 1 : kc(t), (bh(n) ? Rr : ou)(n, t);
        }
        function Af(n) {
            return (bh(n) ? zr : cu)(n);
        }
        function kf(n) {
            if (null == n) return 0;
            if (Hf(n)) return dc(n) ? V(n) : n.length;
            var t = zs(n);
            return t == Gn || t == tt ? n.size : Me(n).length;
        }
        function Of(n, t, r) {
            var e = bh(n) ? h : lu;
            return r && Ui(n, t, r) && (t = X), e(n, mi(t, 3));
        }
        function If(n, t) {
            if ("function" != typeof t) throw new pl(en);
            return n = kc(n), function() {
                if (--n < 1) return t.apply(this, arguments);
            };
        }
        function Rf(n, t, r) {
            return t = r ? X : t, t = n && null == t ? n.length : t, ai(n, mn, X, X, X, X, t);
        }
        function zf(n, t) {
            var r;
            if ("function" != typeof t) throw new pl(en);
            return n = kc(n), function() {
                return --n > 0 && (r = t.apply(this, arguments)), n <= 1 && (t = X), r;
            };
        }
        function Ef(n, t, r) {
            t = r ? X : t;
            var e = ai(n, yn, X, X, X, X, X, t);
            return e.placeholder = Ef.placeholder, e;
        }
        function Sf(n, t, r) {
            t = r ? X : t;
            var e = ai(n, dn, X, X, X, X, X, t);
            return e.placeholder = Sf.placeholder, e;
        }
        function Wf(n, t, r) {
            function e(t) {
                var r = h, e = p;
                return h = p = X, d = t, v = n.apply(e, r);
            }
            function u(n) {
                return d = n, g = Ws(f, t), b ? e(n) : v;
            }
            function i(n) {
                var r = n - y, e = n - d, u = t - r;
                return w ? Hl(u, _ - e) : u;
            }
            function o(n) {
                var r = n - y, e = n - d;
                return y === X || r >= t || r < 0 || w && e >= _;
            }
            function f() {
                var n = fh();
                return o(n) ? c(n) : (g = Ws(f, i(n)), X);
            }
            function c(n) {
                return g = X, m && h ? e(n) : (h = p = X, v);
            }
            function a() {
                g !== X && As(g), d = 0, h = y = p = g = X;
            }
            function l() {
                return g === X ? v : c(fh());
            }
            function s() {
                var n = fh(), r = o(n);
                if (h = arguments, p = this, y = n, r) {
                    if (g === X) return u(y);
                    if (w) return As(g), g = Ws(f, t), e(y);
                }
                return g === X && (g = Ws(f, t)), v;
            }
            var h, p, _, v, g, y, d = 0, b = !1, w = !1, m = !0;
            if ("function" != typeof n) throw new pl(en);
            return t = Ic(t) || 0, fc(r) && (b = !!r.leading, w = "maxWait" in r, _ = w ? Gl(Ic(r.maxWait) || 0, t) : _, m = "trailing" in r ? !!r.trailing : m), s.cancel = a, s.flush = l, s;
        }
        function Lf(n) {
            return ai(n, jn);
        }
        function Cf(n, t) {
            if ("function" != typeof n || null != t && "function" != typeof t) throw new pl(en);
            var r = function() {
                var e = arguments, u = t ? t.apply(this, e) : e[0], i = r.cache;
                if (i.has(u)) return i.get(u);
                var o = n.apply(this, e);
                return r.cache = i.set(u, o) || i, o;
            };
            return r.cache = new (Cf.Cache || sr), r;
        }
        function Uf(n) {
            if ("function" != typeof n) throw new pl(en);
            return function() {
                var t = arguments;
                switch(t.length){
                    case 0:
                        return !n.call(this);
                    case 1:
                        return !n.call(this, t[0]);
                    case 2:
                        return !n.call(this, t[0], t[1]);
                    case 3:
                        return !n.call(this, t[0], t[1], t[2]);
                }
                return !n.apply(this, t);
            };
        }
        function Bf(n) {
            return zf(2, n);
        }
        function Tf(n, t) {
            if ("function" != typeof n) throw new pl(en);
            return t = t === X ? t : kc(t), uu(n, t);
        }
        function $f(t, r) {
            if ("function" != typeof t) throw new pl(en);
            return r = null == r ? 0 : Gl(kc(r), 0), uu(function(e) {
                var u = e[r], i = Ou(e, 0, r);
                return u && a(i, u), n(t, this, i);
            });
        }
        function Df(n, t, r) {
            var e = !0, u = !0;
            if ("function" != typeof n) throw new pl(en);
            return fc(r) && (e = "leading" in r ? !!r.leading : e, u = "trailing" in r ? !!r.trailing : u), Wf(n, t, {
                leading: e,
                maxWait: t,
                trailing: u
            });
        }
        function Mf(n) {
            return Rf(n, 1);
        }
        function Ff(n, t) {
            return ph(Au(t), n);
        }
        function Nf() {
            if (!arguments.length) return [];
            var n = arguments[0];
            return bh(n) ? n : [
                n
            ];
        }
        function Pf(n) {
            return Fr(n, sn);
        }
        function qf(n, t) {
            return t = "function" == typeof t ? t : X, Fr(n, sn, t);
        }
        function Zf(n) {
            return Fr(n, an | sn);
        }
        function Kf(n, t) {
            return t = "function" == typeof t ? t : X, Fr(n, an | sn, t);
        }
        function Vf(n, t) {
            return null == t || Pr(n, t, Pc(t));
        }
        function Gf(n, t) {
            return n === t || n !== n && t !== t;
        }
        function Hf(n) {
            return null != n && oc(n.length) && !uc(n);
        }
        function Jf(n) {
            return cc(n) && Hf(n);
        }
        function Yf(n) {
            return n === !0 || n === !1 || cc(n) && we(n) == Nn;
        }
        function Qf(n) {
            return cc(n) && 1 === n.nodeType && !gc(n);
        }
        function Xf(n) {
            if (null == n) return !0;
            if (Hf(n) && (bh(n) || "string" == typeof n || "function" == typeof n.splice || mh(n) || Oh(n) || dh(n))) return !n.length;
            var t = zs(n);
            if (t == Gn || t == tt) return !n.size;
            if (Mi(n)) return !Me(n).length;
            for(var r in n)if (bl.call(n, r)) return !1;
            return !0;
        }
        function nc(n, t) {
            return Se(n, t);
        }
        function tc(n, t, r) {
            r = "function" == typeof r ? r : X;
            var e = r ? r(n, t) : X;
            return e === X ? Se(n, t, X, r) : !!e;
        }
        function rc(n) {
            if (!cc(n)) return !1;
            var t = we(n);
            return t == Zn || t == qn || "string" == typeof n.message && "string" == typeof n.name && !gc(n);
        }
        function ec(n) {
            return "number" == typeof n && Zl(n);
        }
        function uc(n) {
            if (!fc(n)) return !1;
            var t = we(n);
            return t == Kn || t == Vn || t == Fn || t == Xn;
        }
        function ic(n) {
            return "number" == typeof n && n == kc(n);
        }
        function oc(n) {
            return "number" == typeof n && n > -1 && n % 1 == 0 && n <= Wn;
        }
        function fc(n) {
            var t = typeof n;
            return null != n && ("object" == t || "function" == t);
        }
        function cc(n) {
            return null != n && "object" == typeof n;
        }
        function ac(n, t) {
            return n === t || Ce(n, t, ji(t));
        }
        function lc(n, t, r) {
            return r = "function" == typeof r ? r : X, Ce(n, t, ji(t), r);
        }
        function sc(n) {
            return vc(n) && n != +n;
        }
        function hc(n) {
            if (Es(n)) throw new fl(rn);
            return Ue(n);
        }
        function pc(n) {
            return null === n;
        }
        function _c(n) {
            return null == n;
        }
        function vc(n) {
            return "number" == typeof n || cc(n) && we(n) == Hn;
        }
        function gc(n) {
            if (!cc(n) || we(n) != Yn) return !1;
            var t = El(n);
            if (null === t) return !0;
            var r = bl.call(t, "constructor") && t.constructor;
            return "function" == typeof r && r instanceof r && dl.call(r) == jl;
        }
        function yc(n) {
            return ic(n) && n >= -Wn && n <= Wn;
        }
        function dc(n) {
            return "string" == typeof n || !bh(n) && cc(n) && we(n) == rt;
        }
        function bc(n) {
            return "symbol" == typeof n || cc(n) && we(n) == et;
        }
        function wc(n) {
            return n === X;
        }
        function mc(n) {
            return cc(n) && zs(n) == it;
        }
        function xc(n) {
            return cc(n) && we(n) == ot;
        }
        function jc(n) {
            if (!n) return [];
            if (Hf(n)) return dc(n) ? G(n) : Tu(n);
            if (Ul && n[Ul]) return D(n[Ul]());
            var t = zs(n);
            return (t == Gn ? M : t == tt ? P : ra)(n);
        }
        function Ac(n) {
            if (!n) return 0 === n ? n : 0;
            if (n = Ic(n), n === Sn || n === -Sn) return (n < 0 ? -1 : 1) * Ln;
            return n === n ? n : 0;
        }
        function kc(n) {
            var t = Ac(n), r = t % 1;
            return t === t ? r ? t - r : t : 0;
        }
        function Oc(n) {
            return n ? Mr(kc(n), 0, Un) : 0;
        }
        function Ic(n) {
            if ("number" == typeof n) return n;
            if (bc(n)) return Cn;
            if (fc(n)) {
                var t = "function" == typeof n.valueOf ? n.valueOf() : n;
                n = fc(t) ? t + "" : t;
            }
            if ("string" != typeof n) return 0 === n ? n : +n;
            n = R(n);
            var r = qt.test(n);
            return r || Kt.test(n) ? Xr(n.slice(2), r ? 2 : 8) : Pt.test(n) ? Cn : +n;
        }
        function Rc(n) {
            return $u(n, qc(n));
        }
        function zc(n) {
            return n ? Mr(kc(n), -Wn, Wn) : 0 === n ? n : 0;
        }
        function Ec(n) {
            return null == n ? "" : vu(n);
        }
        function Sc(n, t) {
            var r = gs(n);
            return null == t ? r : Cr(r, t);
        }
        function Wc(n, t) {
            return v(n, mi(t, 3), ue);
        }
        function Lc(n, t) {
            return v(n, mi(t, 3), oe);
        }
        function Cc(n, t) {
            return null == n ? n : bs(n, mi(t, 3), qc);
        }
        function Uc(n, t) {
            return null == n ? n : ws(n, mi(t, 3), qc);
        }
        function Bc(n, t) {
            return n && ue(n, mi(t, 3));
        }
        function Tc(n, t) {
            return n && oe(n, mi(t, 3));
        }
        function $c(n) {
            return null == n ? [] : fe(n, Pc(n));
        }
        function Dc(n) {
            return null == n ? [] : fe(n, qc(n));
        }
        function Mc(n, t, r) {
            var e = null == n ? X : _e(n, t);
            return e === X ? r : e;
        }
        function Fc(n, t) {
            return null != n && Ri(n, t, xe);
        }
        function Nc(n, t) {
            return null != n && Ri(n, t, je);
        }
        function Pc(n) {
            return Hf(n) ? Or(n) : Me(n);
        }
        function qc(n) {
            return Hf(n) ? Or(n, !0) : Fe(n);
        }
        function Zc(n, t) {
            var r = {};
            return t = mi(t, 3), ue(n, function(n, e, u) {
                Br(r, t(n, e, u), n);
            }), r;
        }
        function Kc(n, t) {
            var r = {};
            return t = mi(t, 3), ue(n, function(n, e, u) {
                Br(r, e, t(n, e, u));
            }), r;
        }
        function Vc(n, t) {
            return Gc(n, Uf(mi(t)));
        }
        function Gc(n, t) {
            if (null == n) return {};
            var r = c(di(n), function(n) {
                return [
                    n
                ];
            });
            return t = mi(t), Ye(n, r, function(n, r) {
                return t(n, r[0]);
            });
        }
        function Hc(n, t, r) {
            t = ku(t, n);
            var e = -1, u = t.length;
            for(u || (u = 1, n = X); ++e < u;){
                var i = null == n ? X : n[no(t[e])];
                i === X && (e = u, i = r), n = uc(i) ? i.call(n) : i;
            }
            return n;
        }
        function Jc(n, t, r) {
            return null == n ? n : fu(n, t, r);
        }
        function Yc(n, t, r, e) {
            return e = "function" == typeof e ? e : X, null == n ? n : fu(n, t, r, e);
        }
        function Qc(n, t, e) {
            var u = bh(n), i = u || mh(n) || Oh(n);
            if (t = mi(t, 4), null == e) {
                var o = n && n.constructor;
                e = i ? u ? new o : [] : fc(n) && uc(o) ? gs(El(n)) : {};
            }
            return (i ? r : ue)(n, function(n, r, u) {
                return t(e, n, r, u);
            }), e;
        }
        function Xc(n, t) {
            return null == n || yu(n, t);
        }
        function na(n, t, r) {
            return null == n ? n : du(n, t, Au(r));
        }
        function ta(n, t, r, e) {
            return e = "function" == typeof e ? e : X, null == n ? n : du(n, t, Au(r), e);
        }
        function ra(n) {
            return null == n ? [] : E(n, Pc(n));
        }
        function ea(n) {
            return null == n ? [] : E(n, qc(n));
        }
        function ua(n, t, r) {
            return r === X && (r = t, t = X), r !== X && (r = Ic(r), r = r === r ? r : 0), t !== X && (t = Ic(t), t = t === t ? t : 0), Mr(Ic(n), t, r);
        }
        function ia(n, t, r) {
            return t = Ac(t), r === X ? (r = t, t = 0) : r = Ac(r), n = Ic(n), Ae(n, t, r);
        }
        function oa(n, t, r) {
            if (r && "boolean" != typeof r && Ui(n, t, r) && (t = r = X), r === X && ("boolean" == typeof t ? (r = t, t = X) : "boolean" == typeof n && (r = n, n = X)), n === X && t === X ? (n = 0, t = 1) : (n = Ac(n), t === X ? (t = n, n = 0) : t = Ac(t)), n > t) {
                var e = n;
                n = t, t = e;
            }
            if (r || n % 1 || t % 1) {
                var u = Ql();
                return Hl(n + u * (t - n + Qr("1e-" + ((u + "").length - 1))), t);
            }
            return tu(n, t);
        }
        function fa(n) {
            return Qh(Ec(n).toLowerCase());
        }
        function ca(n) {
            return n = Ec(n), n && n.replace(Gt, ve).replace(Dr, "");
        }
        function aa(n, t, r) {
            n = Ec(n), t = vu(t);
            var e = n.length;
            r = r === X ? e : Mr(kc(r), 0, e);
            var u = r;
            return r -= t.length, r >= 0 && n.slice(r, u) == t;
        }
        function la(n) {
            return n = Ec(n), n && At.test(n) ? n.replace(xt, ge) : n;
        }
        function sa(n) {
            return n = Ec(n), n && Wt.test(n) ? n.replace(St, "\\$&") : n;
        }
        function ha(n, t, r) {
            n = Ec(n), t = kc(t);
            var e = t ? V(n) : 0;
            if (!t || e >= t) return n;
            var u = (t - e) / 2;
            return ri(Nl(u), r) + n + ri(Fl(u), r);
        }
        function pa(n, t, r) {
            n = Ec(n), t = kc(t);
            var e = t ? V(n) : 0;
            return t && e < t ? n + ri(t - e, r) : n;
        }
        function _a(n, t, r) {
            n = Ec(n), t = kc(t);
            var e = t ? V(n) : 0;
            return t && e < t ? ri(t - e, r) + n : n;
        }
        function va(n, t, r) {
            return r || null == t ? t = 0 : t && (t = +t), Yl(Ec(n).replace(Lt, ""), t || 0);
        }
        function ga(n, t, r) {
            return t = (r ? Ui(n, t, r) : t === X) ? 1 : kc(t), eu(Ec(n), t);
        }
        function ya() {
            var n = arguments, t = Ec(n[0]);
            return n.length < 3 ? t : t.replace(n[1], n[2]);
        }
        function da(n, t, r) {
            return r && "number" != typeof r && Ui(n, t, r) && (t = r = X), (r = r === X ? Un : r >>> 0) ? (n = Ec(n), n && ("string" == typeof t || null != t && !Ah(t)) && (t = vu(t), !t && T(n)) ? Ou(G(n), 0, r) : n.split(t, r)) : [];
        }
        function ba(n, t, r) {
            return n = Ec(n), r = null == r ? 0 : Mr(kc(r), 0, n.length), t = vu(t), n.slice(r, r + t.length) == t;
        }
        function wa(n, t, r) {
            var e = Z.templateSettings;
            r && Ui(n, t, r) && (t = X), n = Ec(n), t = Sh({}, t, e, li);
            var u, i, o = Sh({}, t.imports, e.imports, li), f = Pc(o), c = E(o, f), a = 0, l = t.interpolate || Ht, s = "__p += '", h = sl((t.escape || Ht).source + "|" + l.source + "|" + (l === It ? Ft : Ht).source + "|" + (t.evaluate || Ht).source + "|$", "g"), p = "//# sourceURL=" + (bl.call(t, "sourceURL") ? (t.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Zr + "]") + "\n";
            n.replace(h, function(t, r, e, o, f, c) {
                return e || (e = o), s += n.slice(a, c).replace(Jt, U), r && (u = !0, s += "' +\n__e(" + r + ") +\n'"), f && (i = !0, s += "';\n" + f + ";\n__p += '"), e && (s += "' +\n((__t = (" + e + ")) == null ? '' : __t) +\n'"), a = c + t.length, t;
            }), s += "';\n";
            var _ = bl.call(t, "variable") && t.variable;
            if (_) {
                if (Dt.test(_)) throw new fl(un);
            } else s = "with (obj) {\n" + s + "\n}\n";
            s = (i ? s.replace(dt, "") : s).replace(bt, "$1").replace(wt, "$1;"), s = "function(" + (_ || "obj") + ") {\n" + (_ ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (u ? ", __e = _.escape" : "") + (i ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + s + "return __p\n}";
            var v = Xh(function() {
                return cl(f, p + "return " + s).apply(X, c);
            });
            if (v.source = s, rc(v)) throw v;
            return v;
        }
        function ma(n) {
            return Ec(n).toLowerCase();
        }
        function xa(n) {
            return Ec(n).toUpperCase();
        }
        function ja(n, t, r) {
            if (n = Ec(n), n && (r || t === X)) return R(n);
            if (!n || !(t = vu(t))) return n;
            var e = G(n), u = G(t);
            return Ou(e, W(e, u), L(e, u) + 1).join("");
        }
        function Aa(n, t, r) {
            if (n = Ec(n), n && (r || t === X)) return n.slice(0, H(n) + 1);
            if (!n || !(t = vu(t))) return n;
            var e = G(n);
            return Ou(e, 0, L(e, G(t)) + 1).join("");
        }
        function ka(n, t, r) {
            if (n = Ec(n), n && (r || t === X)) return n.replace(Lt, "");
            if (!n || !(t = vu(t))) return n;
            var e = G(n);
            return Ou(e, W(e, G(t))).join("");
        }
        function Oa(n, t) {
            var r = An, e = kn;
            if (fc(t)) {
                var u = "separator" in t ? t.separator : u;
                r = "length" in t ? kc(t.length) : r, e = "omission" in t ? vu(t.omission) : e;
            }
            n = Ec(n);
            var i = n.length;
            if (T(n)) {
                var o = G(n);
                i = o.length;
            }
            if (r >= i) return n;
            var f = r - V(e);
            if (f < 1) return e;
            var c = o ? Ou(o, 0, f).join("") : n.slice(0, f);
            if (u === X) return c + e;
            if (o && (f += c.length - f), Ah(u)) {
                if (n.slice(f).search(u)) {
                    var a, l = c;
                    for(u.global || (u = sl(u.source, Ec(Nt.exec(u)) + "g")), u.lastIndex = 0; a = u.exec(l);)var s = a.index;
                    c = c.slice(0, s === X ? f : s);
                }
            } else if (n.indexOf(vu(u), f) != f) {
                var h = c.lastIndexOf(u);
                h > -1 && (c = c.slice(0, h));
            }
            return c + e;
        }
        function Ia(n) {
            return n = Ec(n), n && jt.test(n) ? n.replace(mt, ye) : n;
        }
        function Ra(n, t, r) {
            return n = Ec(n), t = r ? X : t, t === X ? $(n) ? Q(n) : _(n) : n.match(t) || [];
        }
        function za(t) {
            var r = null == t ? 0 : t.length, e = mi();
            return t = r ? c(t, function(n) {
                if ("function" != typeof n[1]) throw new pl(en);
                return [
                    e(n[0]),
                    n[1]
                ];
            }) : [], uu(function(e) {
                for(var u = -1; ++u < r;){
                    var i = t[u];
                    if (n(i[0], this, e)) return n(i[1], this, e);
                }
            });
        }
        function Ea(n) {
            return Nr(Fr(n, an));
        }
        function Sa(n) {
            return function() {
                return n;
            };
        }
        function Wa(n, t) {
            return null == n || n !== n ? t : n;
        }
        function La(n) {
            return n;
        }
        function Ca(n) {
            return De("function" == typeof n ? n : Fr(n, an));
        }
        function Ua(n) {
            return qe(Fr(n, an));
        }
        function Ba(n, t) {
            return Ze(n, Fr(t, an));
        }
        function Ta(n, t, e) {
            var u = Pc(t), i = fe(t, u);
            null != e || fc(t) && (i.length || !u.length) || (e = t, t = n, n = this, i = fe(t, Pc(t)));
            var o = !(fc(e) && "chain" in e && !e.chain), f = uc(n);
            return r(i, function(r) {
                var e = t[r];
                n[r] = e, f && (n.prototype[r] = function() {
                    var t = this.__chain__;
                    if (o || t) {
                        var r = n(this.__wrapped__);
                        return (r.__actions__ = Tu(this.__actions__)).push({
                            func: e,
                            args: arguments,
                            thisArg: n
                        }), r.__chain__ = t, r;
                    }
                    return e.apply(n, a([
                        this.value()
                    ], arguments));
                });
            }), n;
        }
        function $a() {
            return re._ === this && (re._ = Al), this;
        }
        function Da() {}
        function Ma(n) {
            return n = kc(n), uu(function(t) {
                return Ge(t, n);
            });
        }
        function Fa(n) {
            return Bi(n) ? m(no(n)) : Qe(n);
        }
        function Na(n) {
            return function(t) {
                return null == n ? X : _e(n, t);
            };
        }
        function Pa() {
            return [];
        }
        function qa() {
            return !1;
        }
        function Za() {
            return {};
        }
        function Ka() {
            return "";
        }
        function Va() {
            return !0;
        }
        function Ga(n, t) {
            if (n = kc(n), n < 1 || n > Wn) return [];
            var r = Un, e = Hl(n, Un);
            t = mi(t), n -= Un;
            for(var u = O(e, t); ++r < n;)t(r);
            return u;
        }
        function Ha(n) {
            return bh(n) ? c(n, no) : bc(n) ? [
                n
            ] : Tu(Cs(Ec(n)));
        }
        function Ja(n) {
            var t = ++wl;
            return Ec(n) + t;
        }
        function Ya(n) {
            return n && n.length ? Yr(n, La, me) : X;
        }
        function Qa(n, t) {
            return n && n.length ? Yr(n, mi(t, 2), me) : X;
        }
        function Xa(n) {
            return w(n, La);
        }
        function nl(n, t) {
            return w(n, mi(t, 2));
        }
        function tl(n) {
            return n && n.length ? Yr(n, La, Ne) : X;
        }
        function rl(n, t) {
            return n && n.length ? Yr(n, mi(t, 2), Ne) : X;
        }
        function el(n) {
            return n && n.length ? k(n, La) : 0;
        }
        function ul(n, t) {
            return n && n.length ? k(n, mi(t, 2)) : 0;
        }
        x = null == x ? re : be.defaults(re.Object(), x, be.pick(re, qr));
        var il = x.Array, ol = x.Date, fl = x.Error, cl = x.Function, al = x.Math, ll = x.Object, sl = x.RegExp, hl = x.String, pl = x.TypeError, _l = il.prototype, vl = cl.prototype, gl = ll.prototype, yl = x["__core-js_shared__"], dl = vl.toString, bl = gl.hasOwnProperty, wl = 0, ml = function() {
            var n = /[^.]+$/.exec(yl && yl.keys && yl.keys.IE_PROTO || "");
            return n ? "Symbol(src)_1." + n : "";
        }(), xl = gl.toString, jl = dl.call(ll), Al = re._, kl = sl("^" + dl.call(bl).replace(St, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ol = ie ? x.Buffer : X, Il = x.Symbol, Rl = x.Uint8Array, zl = Ol ? Ol.allocUnsafe : X, El = F(ll.getPrototypeOf, ll), Sl = ll.create, Wl = gl.propertyIsEnumerable, Ll = _l.splice, Cl = Il ? Il.isConcatSpreadable : X, Ul = Il ? Il.iterator : X, Bl = Il ? Il.toStringTag : X, Tl = function() {
            try {
                var n = Ai(ll, "defineProperty");
                return n({}, "", {}), n;
            } catch (n1) {}
        }(), $l = x.clearTimeout !== re.clearTimeout && x.clearTimeout, Dl = ol && ol.now !== re.Date.now && ol.now, Ml = x.setTimeout !== re.setTimeout && x.setTimeout, Fl = al.ceil, Nl = al.floor, Pl = ll.getOwnPropertySymbols, ql = Ol ? Ol.isBuffer : X, Zl = x.isFinite, Kl = _l.join, Vl = F(ll.keys, ll), Gl = al.max, Hl = al.min, Jl = ol.now, Yl = x.parseInt, Ql = al.random, Xl = _l.reverse, ns = Ai(x, "DataView"), ts = Ai(x, "Map"), rs = Ai(x, "Promise"), es = Ai(x, "Set"), us = Ai(x, "WeakMap"), is = Ai(ll, "create"), os = us && new us, fs = {}, cs = to(ns), as = to(ts), ls = to(rs), ss = to(es), hs = to(us), ps = Il ? Il.prototype : X, _s = ps ? ps.valueOf : X, vs = ps ? ps.toString : X, gs = function() {
            function n() {}
            return function(t) {
                if (!fc(t)) return {};
                if (Sl) return Sl(t);
                n.prototype = t;
                var r = new n;
                return n.prototype = X, r;
            };
        }();
        Z.templateSettings = {
            escape: kt,
            evaluate: Ot,
            interpolate: It,
            variable: "",
            imports: {
                _: Z
            }
        }, Z.prototype = J.prototype, Z.prototype.constructor = Z, Y.prototype = gs(J.prototype), Y.prototype.constructor = Y, Ct.prototype = gs(J.prototype), Ct.prototype.constructor = Ct, Xt.prototype.clear = nr, Xt.prototype.delete = tr, Xt.prototype.get = rr, Xt.prototype.has = er, Xt.prototype.set = ur, ir.prototype.clear = or, ir.prototype.delete = fr, ir.prototype.get = cr, ir.prototype.has = ar, ir.prototype.set = lr, sr.prototype.clear = hr, sr.prototype.delete = pr, sr.prototype.get = _r, sr.prototype.has = vr, sr.prototype.set = gr, yr.prototype.add = yr.prototype.push = dr, yr.prototype.has = br, wr.prototype.clear = mr, wr.prototype.delete = xr, wr.prototype.get = jr, wr.prototype.has = Ar, wr.prototype.set = kr;
        var ys = Pu(ue), ds = Pu(oe, !0), bs = qu(), ws = qu(!0), ms = os ? function(n, t) {
            return os.set(n, t), n;
        } : La, xs = Tl ? function(n, t) {
            return Tl(n, "toString", {
                configurable: !0,
                enumerable: !1,
                value: Sa(t),
                writable: !0
            });
        } : La, js = uu, As = $l || function(n) {
            return re.clearTimeout(n);
        }, ks = es && 1 / P(new es([
            ,
            -0
        ]))[1] == Sn ? function(n) {
            return new es(n);
        } : Da, Os = os ? function(n) {
            return os.get(n);
        } : Da, Is = Pl ? function(n) {
            return null == n ? [] : (n = ll(n), i(Pl(n), function(t) {
                return Wl.call(n, t);
            }));
        } : Pa, Rs = Pl ? function(n) {
            for(var t = []; n;)a(t, Is(n)), n = El(n);
            return t;
        } : Pa, zs = we;
        (ns && zs(new ns(new ArrayBuffer(1))) != ct || ts && zs(new ts) != Gn || rs && zs(rs.resolve()) != Qn || es && zs(new es) != tt || us && zs(new us) != it) && (zs = function(n) {
            var t = we(n), r = t == Yn ? n.constructor : X, e = r ? to(r) : "";
            if (e) switch(e){
                case cs:
                    return ct;
                case as:
                    return Gn;
                case ls:
                    return Qn;
                case ss:
                    return tt;
                case hs:
                    return it;
            }
            return t;
        });
        var Es = yl ? uc : qa, Ss = Qi(ms), Ws = Ml || function(n, t) {
            return re.setTimeout(n, t);
        }, Ls = Qi(xs), Cs = Pi(function(n) {
            var t = [];
            return 46 === n.charCodeAt(0) && t.push(""), n.replace(Et, function(n, r, e, u) {
                t.push(e ? u.replace(Mt, "$1") : r || n);
            }), t;
        }), Us = uu(function(n, t) {
            return Jf(n) ? Hr(n, ee(t, 1, Jf, !0)) : [];
        }), Bs = uu(function(n, t) {
            var r = jo(t);
            return Jf(r) && (r = X), Jf(n) ? Hr(n, ee(t, 1, Jf, !0), mi(r, 2)) : [];
        }), Ts = uu(function(n, t) {
            var r = jo(t);
            return Jf(r) && (r = X), Jf(n) ? Hr(n, ee(t, 1, Jf, !0), X, r) : [];
        }), $s = uu(function(n) {
            var t = c(n, ju);
            return t.length && t[0] === n[0] ? ke(t) : [];
        }), Ds = uu(function(n) {
            var t = jo(n), r = c(n, ju);
            return t === jo(r) ? t = X : r.pop(), r.length && r[0] === n[0] ? ke(r, mi(t, 2)) : [];
        }), Ms = uu(function(n) {
            var t = jo(n), r = c(n, ju);
            return t = "function" == typeof t ? t : X, t && r.pop(), r.length && r[0] === n[0] ? ke(r, X, t) : [];
        }), Fs = uu(Oo), Ns = gi(function(n, t) {
            var r = null == n ? 0 : n.length, e = Tr(n, t);
            return nu(n, c(t, function(n) {
                return Ci(n, r) ? +n : n;
            }).sort(Lu)), e;
        }), Ps = uu(function(n) {
            return gu(ee(n, 1, Jf, !0));
        }), qs = uu(function(n) {
            var t = jo(n);
            return Jf(t) && (t = X), gu(ee(n, 1, Jf, !0), mi(t, 2));
        }), Zs = uu(function(n) {
            var t = jo(n);
            return t = "function" == typeof t ? t : X, gu(ee(n, 1, Jf, !0), X, t);
        }), Ks = uu(function(n, t) {
            return Jf(n) ? Hr(n, t) : [];
        }), Vs = uu(function(n) {
            return mu(i(n, Jf));
        }), Gs = uu(function(n) {
            var t = jo(n);
            return Jf(t) && (t = X), mu(i(n, Jf), mi(t, 2));
        }), Hs = uu(function(n) {
            var t = jo(n);
            return t = "function" == typeof t ? t : X, mu(i(n, Jf), X, t);
        }), Js = uu(Go), Ys = uu(function(n) {
            var t = n.length, r = t > 1 ? n[t - 1] : X;
            return r = "function" == typeof r ? (n.pop(), r) : X, Ho(n, r);
        }), Qs = gi(function(n) {
            var t = n.length, r = t ? n[0] : 0, e = this.__wrapped__, u = function(t) {
                return Tr(t, n);
            };
            return !(t > 1 || this.__actions__.length) && e instanceof Ct && Ci(r) ? (e = e.slice(r, +r + (t ? 1 : 0)), e.__actions__.push({
                func: nf,
                args: [
                    u
                ],
                thisArg: X
            }), new Y(e, this.__chain__).thru(function(n) {
                return t && !n.length && n.push(X), n;
            })) : this.thru(u);
        }), Xs = Fu(function(n, t, r) {
            bl.call(n, r) ? ++n[r] : Br(n, r, 1);
        }), nh = Ju(ho), th = Ju(po), rh = Fu(function(n, t, r) {
            bl.call(n, r) ? n[r].push(t) : Br(n, r, [
                t
            ]);
        }), eh = uu(function(t, r, e) {
            var u = -1, i = "function" == typeof r, o = Hf(t) ? il(t.length) : [];
            return ys(t, function(t) {
                o[++u] = i ? n(r, t, e) : Ie(t, r, e);
            }), o;
        }), uh = Fu(function(n, t, r) {
            Br(n, r, t);
        }), ih = Fu(function(n, t, r) {
            n[r ? 0 : 1].push(t);
        }, function() {
            return [
                [],
                []
            ];
        }), oh = uu(function(n, t) {
            if (null == n) return [];
            var r = t.length;
            return r > 1 && Ui(n, t[0], t[1]) ? t = [] : r > 2 && Ui(t[0], t[1], t[2]) && (t = [
                t[0]
            ]), He(n, ee(t, 1), []);
        }), fh = Dl || function() {
            return re.Date.now();
        }, ch = uu(function(n, t, r) {
            var e = _n;
            if (r.length) {
                var u = N(r, wi(ch));
                e |= bn;
            }
            return ai(n, e, t, r, u);
        }), ah = uu(function(n, t, r) {
            var e = _n | vn;
            if (r.length) {
                var u = N(r, wi(ah));
                e |= bn;
            }
            return ai(t, e, n, r, u);
        }), lh = uu(function(n, t) {
            return Gr(n, 1, t);
        }), sh = uu(function(n, t, r) {
            return Gr(n, Ic(t) || 0, r);
        });
        Cf.Cache = sr;
        var hh = js(function(t, r) {
            r = 1 == r.length && bh(r[0]) ? c(r[0], z(mi())) : c(ee(r, 1), z(mi()));
            var e = r.length;
            return uu(function(u) {
                for(var i = -1, o = Hl(u.length, e); ++i < o;)u[i] = r[i].call(this, u[i]);
                return n(t, this, u);
            });
        }), ph = uu(function(n, t) {
            return ai(n, bn, X, t, N(t, wi(ph)));
        }), _h = uu(function(n, t) {
            return ai(n, wn, X, t, N(t, wi(_h)));
        }), vh = gi(function(n, t) {
            return ai(n, xn, X, X, X, t);
        }), gh = ii(me), yh = ii(function(n, t) {
            return n >= t;
        }), dh = Re(function() {
            return arguments;
        }()) ? Re : function(n) {
            return cc(n) && bl.call(n, "callee") && !Wl.call(n, "callee");
        }, bh = il.isArray, wh = ce ? z(ce) : ze, mh = ql || qa, xh = ae ? z(ae) : Ee, jh = le ? z(le) : Le, Ah = se ? z(se) : Be, kh = he ? z(he) : Te, Oh = pe ? z(pe) : $e, Ih = ii(Ne), Rh = ii(function(n, t) {
            return n <= t;
        }), zh = Nu(function(n, t) {
            if (Mi(t) || Hf(t)) return $u(t, Pc(t), n), X;
            for(var r in t)bl.call(t, r) && Sr(n, r, t[r]);
        }), Eh = Nu(function(n, t) {
            $u(t, qc(t), n);
        }), Sh = Nu(function(n, t, r, e) {
            $u(t, qc(t), n, e);
        }), Wh = Nu(function(n, t, r, e) {
            $u(t, Pc(t), n, e);
        }), Lh = gi(Tr), Ch = uu(function(n, t) {
            n = ll(n);
            var r = -1, e = t.length, u = e > 2 ? t[2] : X;
            for(u && Ui(t[0], t[1], u) && (e = 1); ++r < e;)for(var i = t[r], o = qc(i), f = -1, c = o.length; ++f < c;){
                var a = o[f], l = n[a];
                (l === X || Gf(l, gl[a]) && !bl.call(n, a)) && (n[a] = i[a]);
            }
            return n;
        }), Uh = uu(function(t) {
            return t.push(X, si), n(Mh, X, t);
        }), Bh = Xu(function(n, t, r) {
            null != t && "function" != typeof t.toString && (t = xl.call(t)), n[t] = r;
        }, Sa(La)), Th = Xu(function(n, t, r) {
            null != t && "function" != typeof t.toString && (t = xl.call(t)), bl.call(n, t) ? n[t].push(r) : n[t] = [
                r
            ];
        }, mi), $h = uu(Ie), Dh = Nu(function(n, t, r) {
            Ke(n, t, r);
        }), Mh = Nu(function(n, t, r, e) {
            Ke(n, t, r, e);
        }), Fh = gi(function(n, t) {
            var r = {};
            if (null == n) return r;
            var e = !1;
            t = c(t, function(t) {
                return t = ku(t, n), e || (e = t.length > 1), t;
            }), $u(n, di(n), r), e && (r = Fr(r, an | ln | sn, hi));
            for(var u = t.length; u--;)yu(r, t[u]);
            return r;
        }), Nh = gi(function(n, t) {
            return null == n ? {} : Je(n, t);
        }), Ph = ci(Pc), qh = ci(qc), Zh = Vu(function(n, t, r) {
            return t = t.toLowerCase(), n + (r ? fa(t) : t);
        }), Kh = Vu(function(n, t, r) {
            return n + (r ? "-" : "") + t.toLowerCase();
        }), Vh = Vu(function(n, t, r) {
            return n + (r ? " " : "") + t.toLowerCase();
        }), Gh = Ku("toLowerCase"), Hh = Vu(function(n, t, r) {
            return n + (r ? "_" : "") + t.toLowerCase();
        }), Jh = Vu(function(n, t, r) {
            return n + (r ? " " : "") + Qh(t);
        }), Yh = Vu(function(n, t, r) {
            return n + (r ? " " : "") + t.toUpperCase();
        }), Qh = Ku("toUpperCase"), Xh = uu(function(t, r) {
            try {
                return n(t, X, r);
            } catch (n1) {
                return rc(n1) ? n1 : new fl(n1);
            }
        }), np = gi(function(n, t) {
            return r(t, function(t) {
                t = no(t), Br(n, t, ch(n[t], n));
            }), n;
        }), tp = Yu(), rp = Yu(!0), ep = uu(function(n, t) {
            return function(r) {
                return Ie(r, n, t);
            };
        }), up = uu(function(n, t) {
            return function(r) {
                return Ie(n, r, t);
            };
        }), ip = ti(c), op = ti(u), fp = ti(h), cp = ui(), ap = ui(!0), lp = ni(function(n, t) {
            return n + t;
        }, 0), sp = fi("ceil"), hp = ni(function(n, t) {
            return n / t;
        }, 1), pp = fi("floor"), _p = ni(function(n, t) {
            return n * t;
        }, 1), vp = fi("round"), gp = ni(function(n, t) {
            return n - t;
        }, 0);
        return Z.after = If, Z.ary = Rf, Z.assign = zh, Z.assignIn = Eh, Z.assignInWith = Sh, Z.assignWith = Wh, Z.at = Lh, Z.before = zf, Z.bind = ch, Z.bindAll = np, Z.bindKey = ah, Z.castArray = Nf, Z.chain = Qo, Z.chunk = uo, Z.compact = io, Z.concat = oo, Z.cond = za, Z.conforms = Ea, Z.constant = Sa, Z.countBy = Xs, Z.create = Sc, Z.curry = Ef, Z.curryRight = Sf, Z.debounce = Wf, Z.defaults = Ch, Z.defaultsDeep = Uh, Z.defer = lh, Z.delay = sh, Z.difference = Us, Z.differenceBy = Bs, Z.differenceWith = Ts, Z.drop = fo, Z.dropRight = co, Z.dropRightWhile = ao, Z.dropWhile = lo, Z.fill = so, Z.filter = lf, Z.flatMap = sf, Z.flatMapDeep = hf, Z.flatMapDepth = pf, Z.flatten = _o, Z.flattenDeep = vo, Z.flattenDepth = go, Z.flip = Lf, Z.flow = tp, Z.flowRight = rp, Z.fromPairs = yo, Z.functions = $c, Z.functionsIn = Dc, Z.groupBy = rh, Z.initial = mo, Z.intersection = $s, Z.intersectionBy = Ds, Z.intersectionWith = Ms, Z.invert = Bh, Z.invertBy = Th, Z.invokeMap = eh, Z.iteratee = Ca, Z.keyBy = uh, Z.keys = Pc, Z.keysIn = qc, Z.map = yf, Z.mapKeys = Zc, Z.mapValues = Kc, Z.matches = Ua, Z.matchesProperty = Ba, Z.memoize = Cf, Z.merge = Dh, Z.mergeWith = Mh, Z.method = ep, Z.methodOf = up, Z.mixin = Ta, Z.negate = Uf, Z.nthArg = Ma, Z.omit = Fh, Z.omitBy = Vc, Z.once = Bf, Z.orderBy = df, Z.over = ip, Z.overArgs = hh, Z.overEvery = op, Z.overSome = fp, Z.partial = ph, Z.partialRight = _h, Z.partition = ih, Z.pick = Nh, Z.pickBy = Gc, Z.property = Fa, Z.propertyOf = Na, Z.pull = Fs, Z.pullAll = Oo, Z.pullAllBy = Io, Z.pullAllWith = Ro, Z.pullAt = Ns, Z.range = cp, Z.rangeRight = ap, Z.rearg = vh, Z.reject = mf, Z.remove = zo, Z.rest = Tf, Z.reverse = Eo, Z.sampleSize = jf, Z.set = Jc, Z.setWith = Yc, Z.shuffle = Af, Z.slice = So, Z.sortBy = oh, Z.sortedUniq = $o, Z.sortedUniqBy = Do, Z.split = da, Z.spread = $f, Z.tail = Mo, Z.take = Fo, Z.takeRight = No, Z.takeRightWhile = Po, Z.takeWhile = qo, Z.tap = Xo, Z.throttle = Df, Z.thru = nf, Z.toArray = jc, Z.toPairs = Ph, Z.toPairsIn = qh, Z.toPath = Ha, Z.toPlainObject = Rc, Z.transform = Qc, Z.unary = Mf, Z.union = Ps, Z.unionBy = qs, Z.unionWith = Zs, Z.uniq = Zo, Z.uniqBy = Ko, Z.uniqWith = Vo, Z.unset = Xc, Z.unzip = Go, Z.unzipWith = Ho, Z.update = na, Z.updateWith = ta, Z.values = ra, Z.valuesIn = ea, Z.without = Ks, Z.words = Ra, Z.wrap = Ff, Z.xor = Vs, Z.xorBy = Gs, Z.xorWith = Hs, Z.zip = Js, Z.zipObject = Jo, Z.zipObjectDeep = Yo, Z.zipWith = Ys, Z.entries = Ph, Z.entriesIn = qh, Z.extend = Eh, Z.extendWith = Sh, Ta(Z, Z), Z.add = lp, Z.attempt = Xh, Z.camelCase = Zh, Z.capitalize = fa, Z.ceil = sp, Z.clamp = ua, Z.clone = Pf, Z.cloneDeep = Zf, Z.cloneDeepWith = Kf, Z.cloneWith = qf, Z.conformsTo = Vf, Z.deburr = ca, Z.defaultTo = Wa, Z.divide = hp, Z.endsWith = aa, Z.eq = Gf, Z.escape = la, Z.escapeRegExp = sa, Z.every = af, Z.find = nh, Z.findIndex = ho, Z.findKey = Wc, Z.findLast = th, Z.findLastIndex = po, Z.findLastKey = Lc, Z.floor = pp, Z.forEach = _f, Z.forEachRight = vf, Z.forIn = Cc, Z.forInRight = Uc, Z.forOwn = Bc, Z.forOwnRight = Tc, Z.get = Mc, Z.gt = gh, Z.gte = yh, Z.has = Fc, Z.hasIn = Nc, Z.head = bo, Z.identity = La, Z.includes = gf, Z.indexOf = wo, Z.inRange = ia, Z.invoke = $h, Z.isArguments = dh, Z.isArray = bh, Z.isArrayBuffer = wh, Z.isArrayLike = Hf, Z.isArrayLikeObject = Jf, Z.isBoolean = Yf, Z.isBuffer = mh, Z.isDate = xh, Z.isElement = Qf, Z.isEmpty = Xf, Z.isEqual = nc, Z.isEqualWith = tc, Z.isError = rc, Z.isFinite = ec, Z.isFunction = uc, Z.isInteger = ic, Z.isLength = oc, Z.isMap = jh, Z.isMatch = ac, Z.isMatchWith = lc, Z.isNaN = sc, Z.isNative = hc, Z.isNil = _c, Z.isNull = pc, Z.isNumber = vc, Z.isObject = fc, Z.isObjectLike = cc, Z.isPlainObject = gc, Z.isRegExp = Ah, Z.isSafeInteger = yc, Z.isSet = kh, Z.isString = dc, Z.isSymbol = bc, Z.isTypedArray = Oh, Z.isUndefined = wc, Z.isWeakMap = mc, Z.isWeakSet = xc, Z.join = xo, Z.kebabCase = Kh, Z.last = jo, Z.lastIndexOf = Ao, Z.lowerCase = Vh, Z.lowerFirst = Gh, Z.lt = Ih, Z.lte = Rh, Z.max = Ya, Z.maxBy = Qa, Z.mean = Xa, Z.meanBy = nl, Z.min = tl, Z.minBy = rl, Z.stubArray = Pa, Z.stubFalse = qa, Z.stubObject = Za, Z.stubString = Ka, Z.stubTrue = Va, Z.multiply = _p, Z.nth = ko, Z.noConflict = $a, Z.noop = Da, Z.now = fh, Z.pad = ha, Z.padEnd = pa, Z.padStart = _a, Z.parseInt = va, Z.random = oa, Z.reduce = bf, Z.reduceRight = wf, Z.repeat = ga, Z.replace = ya, Z.result = Hc, Z.round = vp, Z.runInContext = p, Z.sample = xf, Z.size = kf, Z.snakeCase = Hh, Z.some = Of, Z.sortedIndex = Wo, Z.sortedIndexBy = Lo, Z.sortedIndexOf = Co, Z.sortedLastIndex = Uo, Z.sortedLastIndexBy = Bo, Z.sortedLastIndexOf = To, Z.startCase = Jh, Z.startsWith = ba, Z.subtract = gp, Z.sum = el, Z.sumBy = ul, Z.template = wa, Z.times = Ga, Z.toFinite = Ac, Z.toInteger = kc, Z.toLength = Oc, Z.toLower = ma, Z.toNumber = Ic, Z.toSafeInteger = zc, Z.toString = Ec, Z.toUpper = xa, Z.trim = ja, Z.trimEnd = Aa, Z.trimStart = ka, Z.truncate = Oa, Z.unescape = Ia, Z.uniqueId = Ja, Z.upperCase = Yh, Z.upperFirst = Qh, Z.each = _f, Z.eachRight = vf, Z.first = bo, Ta(Z, function() {
            var n = {};
            return ue(Z, function(t, r) {
                bl.call(Z.prototype, r) || (n[r] = t);
            }), n;
        }(), {
            chain: !1
        }), Z.VERSION = nn, r([
            "bind",
            "bindKey",
            "curry",
            "curryRight",
            "partial",
            "partialRight"
        ], function(n) {
            Z[n].placeholder = Z;
        }), r([
            "drop",
            "take"
        ], function(n, t) {
            Ct.prototype[n] = function(r) {
                r = r === X ? 1 : Gl(kc(r), 0);
                var e = this.__filtered__ && !t ? new Ct(this) : this.clone();
                return e.__filtered__ ? e.__takeCount__ = Hl(r, e.__takeCount__) : e.__views__.push({
                    size: Hl(r, Un),
                    type: n + (e.__dir__ < 0 ? "Right" : "")
                }), e;
            }, Ct.prototype[n + "Right"] = function(t) {
                return this.reverse()[n](t).reverse();
            };
        }), r([
            "filter",
            "map",
            "takeWhile"
        ], function(n, t) {
            var r = t + 1, e = r == Rn || r == En;
            Ct.prototype[n] = function(n) {
                var t = this.clone();
                return t.__iteratees__.push({
                    iteratee: mi(n, 3),
                    type: r
                }), t.__filtered__ = t.__filtered__ || e, t;
            };
        }), r([
            "head",
            "last"
        ], function(n, t) {
            var r = "take" + (t ? "Right" : "");
            Ct.prototype[n] = function() {
                return this[r](1).value()[0];
            };
        }), r([
            "initial",
            "tail"
        ], function(n, t) {
            var r = "drop" + (t ? "" : "Right");
            Ct.prototype[n] = function() {
                return this.__filtered__ ? new Ct(this) : this[r](1);
            };
        }), Ct.prototype.compact = function() {
            return this.filter(La);
        }, Ct.prototype.find = function(n) {
            return this.filter(n).head();
        }, Ct.prototype.findLast = function(n) {
            return this.reverse().find(n);
        }, Ct.prototype.invokeMap = uu(function(n, t) {
            return "function" == typeof n ? new Ct(this) : this.map(function(r) {
                return Ie(r, n, t);
            });
        }), Ct.prototype.reject = function(n) {
            return this.filter(Uf(mi(n)));
        }, Ct.prototype.slice = function(n, t) {
            n = kc(n);
            var r = this;
            return r.__filtered__ && (n > 0 || t < 0) ? new Ct(r) : (n < 0 ? r = r.takeRight(-n) : n && (r = r.drop(n)), t !== X && (t = kc(t), r = t < 0 ? r.dropRight(-t) : r.take(t - n)), r);
        }, Ct.prototype.takeRightWhile = function(n) {
            return this.reverse().takeWhile(n).reverse();
        }, Ct.prototype.toArray = function() {
            return this.take(Un);
        }, ue(Ct.prototype, function(n, t) {
            var r = /^(?:filter|find|map|reject)|While$/.test(t), e = /^(?:head|last)$/.test(t), u = Z[e ? "take" + ("last" == t ? "Right" : "") : t], i = e || /^find/.test(t);
            u && (Z.prototype[t] = function() {
                var t = this.__wrapped__, o = e ? [
                    1
                ] : arguments, f = t instanceof Ct, c = o[0], l = f || bh(t), s = function(n) {
                    var t = u.apply(Z, a([
                        n
                    ], o));
                    return e && h ? t[0] : t;
                };
                l && r && "function" == typeof c && 1 != c.length && (f = l = !1);
                var h = this.__chain__, p = !!this.__actions__.length, _ = i && !h, v = f && !p;
                if (!i && l) {
                    t = v ? t : new Ct(this);
                    var g = n.apply(t, o);
                    return g.__actions__.push({
                        func: nf,
                        args: [
                            s
                        ],
                        thisArg: X
                    }), new Y(g, h);
                }
                return _ && v ? n.apply(this, o) : (g = this.thru(s), _ ? e ? g.value()[0] : g.value() : g);
            });
        }), r([
            "pop",
            "push",
            "shift",
            "sort",
            "splice",
            "unshift"
        ], function(n) {
            var t = _l[n], r = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru", e = /^(?:pop|shift)$/.test(n);
            Z.prototype[n] = function() {
                var n = arguments;
                if (e && !this.__chain__) {
                    var u = this.value();
                    return t.apply(bh(u) ? u : [], n);
                }
                return this[r](function(r) {
                    return t.apply(bh(r) ? r : [], n);
                });
            };
        }), ue(Ct.prototype, function(n, t) {
            var r = Z[t];
            if (r) {
                var e = r.name + "";
                bl.call(fs, e) || (fs[e] = []), fs[e].push({
                    name: t,
                    func: r
                });
            }
        }), fs[Qu(X, vn).name] = [
            {
                name: "wrapper",
                func: X
            }
        ], Ct.prototype.clone = $t, Ct.prototype.reverse = Yt, Ct.prototype.value = Qt, Z.prototype.at = Qs, Z.prototype.chain = tf, Z.prototype.commit = rf, Z.prototype.next = ef, Z.prototype.plant = of, Z.prototype.reverse = ff, Z.prototype.toJSON = Z.prototype.valueOf = Z.prototype.value = cf, Z.prototype.first = Z.prototype.head, Ul && (Z.prototype[Ul] = uf), Z;
    }, be = de();
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (re._ = be, define(function() {
        return be;
    })) : ue ? ((ue.exports = be)._ = be, ee._ = be) : re._ = be;
}).call(this);

},{}],"4DuVy":[function(require,module,exports) {
var global = arguments[3];
(function(f) {
    var g;
    module.exports = f();
})(function() {
    var define, module1, exports;
    return (function() {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = undefined;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw a.code = "MODULE_NOT_FOUND", a;
                    }
                    var p = n[i] = {
                        exports: {}
                    };
                    e[i][0].call(p.exports, function(r) {
                        var n = e[i][1][r];
                        return o(n || r);
                    }, p, p.exports, r, e, n, t);
                }
                return n[i].exports;
            }
            for(var u = undefined, i = 0; i < t.length; i++)o(t[i]);
            return o;
        }
        return r;
    })()({
        1: [
            function(require, module1, exports) {
                /*
    Copyright (c) 2012-2014 Chris Pettitt
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */ module1.exports = {
                    graphlib: require("./lib/graphlib"),
                    layout: require("./lib/layout"),
                    debug: require("./lib/debug"),
                    util: {
                        time: require("./lib/util").time,
                        notime: require("./lib/util").notime
                    },
                    version: require("./lib/version")
                };
            },
            {
                "./lib/debug": 6,
                "./lib/graphlib": 7,
                "./lib/layout": 9,
                "./lib/util": 29,
                "./lib/version": 30
            }, 
        ],
        2: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("./lodash");
                var greedyFAS = require("./greedy-fas");
                module1.exports = {
                    run: run,
                    undo: undo
                };
                function run(g) {
                    var fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
                    _.forEach(fas, function(e) {
                        var label = g.edge(e);
                        g.removeEdge(e);
                        label.forwardName = e.name;
                        label.reversed = true;
                        g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
                    });
                    function weightFn(g) {
                        return function(e) {
                            return g.edge(e).weight;
                        };
                    }
                }
                function dfsFAS(g) {
                    var fas = [];
                    var stack = {};
                    var visited = {};
                    function dfs(v) {
                        if (_.has(visited, v)) return;
                        visited[v] = true;
                        stack[v] = true;
                        _.forEach(g.outEdges(v), function(e) {
                            if (_.has(stack, e.w)) fas.push(e);
                            else dfs(e.w);
                        });
                        delete stack[v];
                    }
                    _.forEach(g.nodes(), dfs);
                    return fas;
                }
                function undo(g) {
                    _.forEach(g.edges(), function(e) {
                        var label = g.edge(e);
                        if (label.reversed) {
                            g.removeEdge(e);
                            var forwardName = label.forwardName;
                            delete label.reversed;
                            delete label.forwardName;
                            g.setEdge(e.w, e.v, label, forwardName);
                        }
                    });
                }
            },
            {
                "./greedy-fas": 8,
                "./lodash": 10
            }, 
        ],
        3: [
            function(require, module1, exports) {
                var _ = require("./lodash");
                var util = require("./util");
                module1.exports = addBorderSegments;
                function addBorderSegments(g) {
                    function dfs(v) {
                        var children = g.children(v);
                        var node = g.node(v);
                        if (children.length) _.forEach(children, dfs);
                        if (_.has(node, "minRank")) {
                            node.borderLeft = [];
                            node.borderRight = [];
                            for(var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank){
                                addBorderNode(g, "borderLeft", "_bl", v, node, rank);
                                addBorderNode(g, "borderRight", "_br", v, node, rank);
                            }
                        }
                    }
                    _.forEach(g.children(), dfs);
                }
                function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
                    var label = {
                        width: 0,
                        height: 0,
                        rank: rank,
                        borderType: prop
                    };
                    var prev = sgNode[prop][rank - 1];
                    var curr = util.addDummyNode(g, "border", label, prefix);
                    sgNode[prop][rank] = curr;
                    g.setParent(curr, sg);
                    if (prev) g.setEdge(prev, curr, {
                        weight: 1
                    });
                }
            },
            {
                "./lodash": 10,
                "./util": 29
            }, 
        ],
        4: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("./lodash");
                module1.exports = {
                    adjust: adjust,
                    undo: undo
                };
                function adjust(g) {
                    var rankDir = g.graph().rankdir.toLowerCase();
                    if (rankDir === "lr" || rankDir === "rl") swapWidthHeight(g);
                }
                function undo(g) {
                    var rankDir = g.graph().rankdir.toLowerCase();
                    if (rankDir === "bt" || rankDir === "rl") reverseY(g);
                    if (rankDir === "lr" || rankDir === "rl") {
                        swapXY(g);
                        swapWidthHeight(g);
                    }
                }
                function swapWidthHeight(g) {
                    _.forEach(g.nodes(), function(v) {
                        swapWidthHeightOne(g.node(v));
                    });
                    _.forEach(g.edges(), function(e) {
                        swapWidthHeightOne(g.edge(e));
                    });
                }
                function swapWidthHeightOne(attrs) {
                    var w = attrs.width;
                    attrs.width = attrs.height;
                    attrs.height = w;
                }
                function reverseY(g) {
                    _.forEach(g.nodes(), function(v) {
                        reverseYOne(g.node(v));
                    });
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        _.forEach(edge.points, reverseYOne);
                        if (_.has(edge, "y")) reverseYOne(edge);
                    });
                }
                function reverseYOne(attrs) {
                    attrs.y = -attrs.y;
                }
                function swapXY(g) {
                    _.forEach(g.nodes(), function(v) {
                        swapXYOne(g.node(v));
                    });
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        _.forEach(edge.points, swapXYOne);
                        if (_.has(edge, "x")) swapXYOne(edge);
                    });
                }
                function swapXYOne(attrs) {
                    var x = attrs.x;
                    attrs.x = attrs.y;
                    attrs.y = x;
                }
            },
            {
                "./lodash": 10
            }, 
        ],
        5: [
            function(require, module1, exports) {
                /*
                     * Simple doubly linked list implementation derived from Cormen, et al.,
                     * "Introduction to Algorithms".
                     */ module1.exports = List;
                function List() {
                    var sentinel = {};
                    sentinel._next = sentinel._prev = sentinel;
                    this._sentinel = sentinel;
                }
                List.prototype.dequeue = function() {
                    var sentinel = this._sentinel;
                    var entry = sentinel._prev;
                    if (entry !== sentinel) {
                        unlink(entry);
                        return entry;
                    }
                };
                List.prototype.enqueue = function(entry) {
                    var sentinel = this._sentinel;
                    if (entry._prev && entry._next) unlink(entry);
                    entry._next = sentinel._next;
                    sentinel._next._prev = entry;
                    sentinel._next = entry;
                    entry._prev = sentinel;
                };
                List.prototype.toString = function() {
                    var strs = [];
                    var sentinel = this._sentinel;
                    var curr = sentinel._prev;
                    while(curr !== sentinel){
                        strs.push(JSON.stringify(curr, filterOutLinks));
                        curr = curr._prev;
                    }
                    return "[" + strs.join(", ") + "]";
                };
                function unlink(entry) {
                    entry._prev._next = entry._next;
                    entry._next._prev = entry._prev;
                    delete entry._next;
                    delete entry._prev;
                }
                function filterOutLinks(k, v) {
                    if (k !== "_next" && k !== "_prev") return v;
                }
            },
            {}, 
        ],
        6: [
            function(require, module1, exports) {
                var _ = require("./lodash");
                var util = require("./util");
                var Graph = require("./graphlib").Graph;
                module1.exports = {
                    debugOrdering: debugOrdering
                };
                /* istanbul ignore next */ function debugOrdering(g) {
                    var layerMatrix = util.buildLayerMatrix(g);
                    var h = new Graph({
                        compound: true,
                        multigraph: true
                    }).setGraph({});
                    _.forEach(g.nodes(), function(v) {
                        h.setNode(v, {
                            label: v
                        });
                        h.setParent(v, "layer" + g.node(v).rank);
                    });
                    _.forEach(g.edges(), function(e) {
                        h.setEdge(e.v, e.w, {}, e.name);
                    });
                    _.forEach(layerMatrix, function(layer, i) {
                        var layerV = "layer" + i;
                        h.setNode(layerV, {
                            rank: "same"
                        });
                        _.reduce(layer, function(u, v) {
                            h.setEdge(u, v, {
                                style: "invis"
                            });
                            return v;
                        });
                    });
                    return h;
                }
            },
            {
                "./graphlib": 7,
                "./lodash": 10,
                "./util": 29
            }, 
        ],
        7: [
            function(require, module1, exports) {
                /* global window */ var graphlib;
                if (typeof require === "function") try {
                    graphlib = require("graphlib");
                } catch (e) {
                // continue regardless of error
                }
                if (!graphlib) graphlib = window.graphlib;
                module1.exports = graphlib;
            },
            {
                graphlib: 31
            }, 
        ],
        8: [
            function(require, module1, exports) {
                var _ = require("./lodash");
                var Graph = require("./graphlib").Graph;
                var List = require("./data/list");
                /*
                     * A greedy heuristic for finding a feedback arc set for a graph. A feedback
                     * arc set is a set of edges that can be removed to make a graph acyclic.
                     * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
                     * effective heuristic for the feedback arc set problem." This implementation
                     * adjusts that from the paper to allow for weighted edges.
                     */ module1.exports = greedyFAS;
                var DEFAULT_WEIGHT_FN = _.constant(1);
                function greedyFAS(g, weightFn) {
                    if (g.nodeCount() <= 1) return [];
                    var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
                    var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
                    // Expand multi-edges
                    return _.flatten(_.map(results, function(e) {
                        return g.outEdges(e.v, e.w);
                    }), true);
                }
                function doGreedyFAS(g, buckets, zeroIdx) {
                    var results = [];
                    var sources = buckets[buckets.length - 1];
                    var sinks = buckets[0];
                    var entry;
                    while(g.nodeCount()){
                        while(entry = sinks.dequeue())removeNode(g, buckets, zeroIdx, entry);
                        while(entry = sources.dequeue())removeNode(g, buckets, zeroIdx, entry);
                        if (g.nodeCount()) for(var i = buckets.length - 2; i > 0; --i){
                            entry = buckets[i].dequeue();
                            if (entry) {
                                results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
                                break;
                            }
                        }
                    }
                    return results;
                }
                function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
                    var results = collectPredecessors ? [] : undefined;
                    _.forEach(g.inEdges(entry.v), function(edge) {
                        var weight = g.edge(edge);
                        var uEntry = g.node(edge.v);
                        if (collectPredecessors) results.push({
                            v: edge.v,
                            w: edge.w
                        });
                        uEntry.out -= weight;
                        assignBucket(buckets, zeroIdx, uEntry);
                    });
                    _.forEach(g.outEdges(entry.v), function(edge) {
                        var weight = g.edge(edge);
                        var w = edge.w;
                        var wEntry = g.node(w);
                        wEntry["in"] -= weight;
                        assignBucket(buckets, zeroIdx, wEntry);
                    });
                    g.removeNode(entry.v);
                    return results;
                }
                function buildState(g, weightFn) {
                    var fasGraph = new Graph();
                    var maxIn = 0;
                    var maxOut = 0;
                    _.forEach(g.nodes(), function(v) {
                        fasGraph.setNode(v, {
                            v: v,
                            in: 0,
                            out: 0
                        });
                    });
                    // Aggregate weights on nodes, but also sum the weights across multi-edges
                    // into a single edge for the fasGraph.
                    _.forEach(g.edges(), function(e) {
                        var prevWeight = fasGraph.edge(e.v, e.w) || 0;
                        var weight = weightFn(e);
                        var edgeWeight = prevWeight + weight;
                        fasGraph.setEdge(e.v, e.w, edgeWeight);
                        maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
                        maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
                    });
                    var buckets = _.range(maxOut + maxIn + 3).map(function() {
                        return new List();
                    });
                    var zeroIdx = maxIn + 1;
                    _.forEach(fasGraph.nodes(), function(v) {
                        assignBucket(buckets, zeroIdx, fasGraph.node(v));
                    });
                    return {
                        graph: fasGraph,
                        buckets: buckets,
                        zeroIdx: zeroIdx
                    };
                }
                function assignBucket(buckets, zeroIdx, entry) {
                    if (!entry.out) buckets[0].enqueue(entry);
                    else if (!entry["in"]) buckets[buckets.length - 1].enqueue(entry);
                    else buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
                }
            },
            {
                "./data/list": 5,
                "./graphlib": 7,
                "./lodash": 10
            }, 
        ],
        9: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("./lodash");
                var acyclic = require("./acyclic");
                var normalize = require("./normalize");
                var rank = require("./rank");
                var normalizeRanks = require("./util").normalizeRanks;
                var parentDummyChains = require("./parent-dummy-chains");
                var removeEmptyRanks = require("./util").removeEmptyRanks;
                var nestingGraph = require("./nesting-graph");
                var addBorderSegments = require("./add-border-segments");
                var coordinateSystem = require("./coordinate-system");
                var order = require("./order");
                var position = require("./position");
                var util = require("./util");
                var Graph = require("./graphlib").Graph;
                module1.exports = layout;
                function layout(g, opts) {
                    var time = opts && opts.debugTiming ? util.time : util.notime;
                    time("layout", function() {
                        var layoutGraph = time("  buildLayoutGraph", function() {
                            return buildLayoutGraph(g);
                        });
                        time("  runLayout", function() {
                            runLayout(layoutGraph, time);
                        });
                        time("  updateInputGraph", function() {
                            updateInputGraph(g, layoutGraph);
                        });
                    });
                }
                function runLayout(g, time) {
                    time("    makeSpaceForEdgeLabels", function() {
                        makeSpaceForEdgeLabels(g);
                    });
                    time("    removeSelfEdges", function() {
                        removeSelfEdges(g);
                    });
                    time("    acyclic", function() {
                        acyclic.run(g);
                    });
                    time("    nestingGraph.run", function() {
                        nestingGraph.run(g);
                    });
                    time("    rank", function() {
                        rank(util.asNonCompoundGraph(g));
                    });
                    time("    injectEdgeLabelProxies", function() {
                        injectEdgeLabelProxies(g);
                    });
                    time("    removeEmptyRanks", function() {
                        removeEmptyRanks(g);
                    });
                    time("    nestingGraph.cleanup", function() {
                        nestingGraph.cleanup(g);
                    });
                    time("    normalizeRanks", function() {
                        normalizeRanks(g);
                    });
                    time("    assignRankMinMax", function() {
                        assignRankMinMax(g);
                    });
                    time("    removeEdgeLabelProxies", function() {
                        removeEdgeLabelProxies(g);
                    });
                    time("    normalize.run", function() {
                        normalize.run(g);
                    });
                    time("    parentDummyChains", function() {
                        parentDummyChains(g);
                    });
                    time("    addBorderSegments", function() {
                        addBorderSegments(g);
                    });
                    time("    order", function() {
                        order(g);
                    });
                    time("    insertSelfEdges", function() {
                        insertSelfEdges(g);
                    });
                    time("    adjustCoordinateSystem", function() {
                        coordinateSystem.adjust(g);
                    });
                    time("    position", function() {
                        position(g);
                    });
                    time("    positionSelfEdges", function() {
                        positionSelfEdges(g);
                    });
                    time("    removeBorderNodes", function() {
                        removeBorderNodes(g);
                    });
                    time("    normalize.undo", function() {
                        normalize.undo(g);
                    });
                    time("    fixupEdgeLabelCoords", function() {
                        fixupEdgeLabelCoords(g);
                    });
                    time("    undoCoordinateSystem", function() {
                        coordinateSystem.undo(g);
                    });
                    time("    translateGraph", function() {
                        translateGraph(g);
                    });
                    time("    assignNodeIntersects", function() {
                        assignNodeIntersects(g);
                    });
                    time("    reversePoints", function() {
                        reversePointsForReversedEdges(g);
                    });
                    time("    acyclic.undo", function() {
                        acyclic.undo(g);
                    });
                }
                /*
                     * Copies final layout information from the layout graph back to the input
                     * graph. This process only copies whitelisted attributes from the layout graph
                     * to the input graph, so it serves as a good place to determine what
                     * attributes can influence layout.
                     */ function updateInputGraph(inputGraph, layoutGraph) {
                    _.forEach(inputGraph.nodes(), function(v) {
                        var inputLabel = inputGraph.node(v);
                        var layoutLabel = layoutGraph.node(v);
                        if (inputLabel) {
                            inputLabel.x = layoutLabel.x;
                            inputLabel.y = layoutLabel.y;
                            if (layoutGraph.children(v).length) {
                                inputLabel.width = layoutLabel.width;
                                inputLabel.height = layoutLabel.height;
                            }
                        }
                    });
                    _.forEach(inputGraph.edges(), function(e) {
                        var inputLabel = inputGraph.edge(e);
                        var layoutLabel = layoutGraph.edge(e);
                        inputLabel.points = layoutLabel.points;
                        if (_.has(layoutLabel, "x")) {
                            inputLabel.x = layoutLabel.x;
                            inputLabel.y = layoutLabel.y;
                        }
                    });
                    inputGraph.graph().width = layoutGraph.graph().width;
                    inputGraph.graph().height = layoutGraph.graph().height;
                }
                var graphNumAttrs = [
                    "nodesep",
                    "edgesep",
                    "ranksep",
                    "marginx",
                    "marginy", 
                ];
                var graphDefaults = {
                    ranksep: 50,
                    edgesep: 20,
                    nodesep: 50,
                    rankdir: "tb"
                };
                var graphAttrs = [
                    "acyclicer",
                    "ranker",
                    "rankdir",
                    "align", 
                ];
                var nodeNumAttrs = [
                    "width",
                    "height"
                ];
                var nodeDefaults = {
                    width: 0,
                    height: 0
                };
                var edgeNumAttrs = [
                    "minlen",
                    "weight",
                    "width",
                    "height",
                    "labeloffset", 
                ];
                var edgeDefaults = {
                    minlen: 1,
                    weight: 1,
                    width: 0,
                    height: 0,
                    labeloffset: 10,
                    labelpos: "r"
                };
                var edgeAttrs = [
                    "labelpos"
                ];
                /*
                     * Constructs a new graph from the input graph, which can be used for layout.
                     * This process copies only whitelisted attributes from the input graph to the
                     * layout graph. Thus this function serves as a good place to determine what
                     * attributes can influence layout.
                     */ function buildLayoutGraph(inputGraph) {
                    var g = new Graph({
                        multigraph: true,
                        compound: true
                    });
                    var graph = canonicalize(inputGraph.graph());
                    g.setGraph(_.merge({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), _.pick(graph, graphAttrs)));
                    _.forEach(inputGraph.nodes(), function(v) {
                        var node = canonicalize(inputGraph.node(v));
                        g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
                        g.setParent(v, inputGraph.parent(v));
                    });
                    _.forEach(inputGraph.edges(), function(e) {
                        var edge = canonicalize(inputGraph.edge(e));
                        g.setEdge(e, _.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), _.pick(edge, edgeAttrs)));
                    });
                    return g;
                }
                /*
                     * This idea comes from the Gansner paper: to account for edge labels in our
                     * layout we split each rank in half by doubling minlen and halving ranksep.
                     * Then we can place labels at these mid-points between nodes.
                     *
                     * We also add some minimal padding to the width to push the label for the edge
                     * away from the edge itself a bit.
                     */ function makeSpaceForEdgeLabels(g) {
                    var graph = g.graph();
                    graph.ranksep /= 2;
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        edge.minlen *= 2;
                        if (edge.labelpos.toLowerCase() !== "c") {
                            if (graph.rankdir === "TB" || graph.rankdir === "BT") edge.width += edge.labeloffset;
                            else edge.height += edge.labeloffset;
                        }
                    });
                }
                /*
                     * Creates temporary dummy nodes that capture the rank in which each edge's
                     * label is going to, if it has one of non-zero width and height. We do this
                     * so that we can safely remove empty ranks while preserving balance for the
                     * label's position.
                     */ function injectEdgeLabelProxies(g) {
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        if (edge.width && edge.height) {
                            var v = g.node(e.v);
                            var w = g.node(e.w);
                            var label = {
                                rank: (w.rank - v.rank) / 2 + v.rank,
                                e: e
                            };
                            util.addDummyNode(g, "edge-proxy", label, "_ep");
                        }
                    });
                }
                function assignRankMinMax(g) {
                    var maxRank = 0;
                    _.forEach(g.nodes(), function(v) {
                        var node = g.node(v);
                        if (node.borderTop) {
                            node.minRank = g.node(node.borderTop).rank;
                            node.maxRank = g.node(node.borderBottom).rank;
                            maxRank = _.max(maxRank, node.maxRank);
                        }
                    });
                    g.graph().maxRank = maxRank;
                }
                function removeEdgeLabelProxies(g) {
                    _.forEach(g.nodes(), function(v) {
                        var node = g.node(v);
                        if (node.dummy === "edge-proxy") {
                            g.edge(node.e).labelRank = node.rank;
                            g.removeNode(v);
                        }
                    });
                }
                function translateGraph(g) {
                    var minX = Number.POSITIVE_INFINITY;
                    var maxX = 0;
                    var minY = Number.POSITIVE_INFINITY;
                    var maxY = 0;
                    var graphLabel = g.graph();
                    var marginX = graphLabel.marginx || 0;
                    var marginY = graphLabel.marginy || 0;
                    function getExtremes(attrs) {
                        var x = attrs.x;
                        var y = attrs.y;
                        var w = attrs.width;
                        var h = attrs.height;
                        minX = Math.min(minX, x - w / 2);
                        maxX = Math.max(maxX, x + w / 2);
                        minY = Math.min(minY, y - h / 2);
                        maxY = Math.max(maxY, y + h / 2);
                    }
                    _.forEach(g.nodes(), function(v) {
                        getExtremes(g.node(v));
                    });
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        if (_.has(edge, "x")) getExtremes(edge);
                    });
                    minX -= marginX;
                    minY -= marginY;
                    _.forEach(g.nodes(), function(v) {
                        var node = g.node(v);
                        node.x -= minX;
                        node.y -= minY;
                    });
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        _.forEach(edge.points, function(p) {
                            p.x -= minX;
                            p.y -= minY;
                        });
                        if (_.has(edge, "x")) edge.x -= minX;
                        if (_.has(edge, "y")) edge.y -= minY;
                    });
                    graphLabel.width = maxX - minX + marginX;
                    graphLabel.height = maxY - minY + marginY;
                }
                function assignNodeIntersects(g) {
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        var nodeV = g.node(e.v);
                        var nodeW = g.node(e.w);
                        var p1, p2;
                        if (!edge.points) {
                            edge.points = [];
                            p1 = nodeW;
                            p2 = nodeV;
                        } else {
                            p1 = edge.points[0];
                            p2 = edge.points[edge.points.length - 1];
                        }
                        edge.points.unshift(util.intersectRect(nodeV, p1));
                        edge.points.push(util.intersectRect(nodeW, p2));
                    });
                }
                function fixupEdgeLabelCoords(g) {
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        if (_.has(edge, "x")) {
                            if (edge.labelpos === "l" || edge.labelpos === "r") edge.width -= edge.labeloffset;
                            switch(edge.labelpos){
                                case "l":
                                    edge.x -= edge.width / 2 + edge.labeloffset;
                                    break;
                                case "r":
                                    edge.x += edge.width / 2 + edge.labeloffset;
                                    break;
                            }
                        }
                    });
                }
                function reversePointsForReversedEdges(g) {
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        if (edge.reversed) edge.points.reverse();
                    });
                }
                function removeBorderNodes(g) {
                    _.forEach(g.nodes(), function(v) {
                        if (g.children(v).length) {
                            var node = g.node(v);
                            var t = g.node(node.borderTop);
                            var b = g.node(node.borderBottom);
                            var l = g.node(_.last(node.borderLeft));
                            var r = g.node(_.last(node.borderRight));
                            node.width = Math.abs(r.x - l.x);
                            node.height = Math.abs(b.y - t.y);
                            node.x = l.x + node.width / 2;
                            node.y = t.y + node.height / 2;
                        }
                    });
                    _.forEach(g.nodes(), function(v) {
                        if (g.node(v).dummy === "border") g.removeNode(v);
                    });
                }
                function removeSelfEdges(g) {
                    _.forEach(g.edges(), function(e) {
                        if (e.v === e.w) {
                            var node = g.node(e.v);
                            if (!node.selfEdges) node.selfEdges = [];
                            node.selfEdges.push({
                                e: e,
                                label: g.edge(e)
                            });
                            g.removeEdge(e);
                        }
                    });
                }
                function insertSelfEdges(g) {
                    var layers = util.buildLayerMatrix(g);
                    _.forEach(layers, function(layer) {
                        var orderShift = 0;
                        _.forEach(layer, function(v, i) {
                            var node = g.node(v);
                            node.order = i + orderShift;
                            _.forEach(node.selfEdges, function(selfEdge) {
                                util.addDummyNode(g, "selfedge", {
                                    width: selfEdge.label.width,
                                    height: selfEdge.label.height,
                                    rank: node.rank,
                                    order: i + ++orderShift,
                                    e: selfEdge.e,
                                    label: selfEdge.label
                                }, "_se");
                            });
                            delete node.selfEdges;
                        });
                    });
                }
                function positionSelfEdges(g) {
                    _.forEach(g.nodes(), function(v) {
                        var node = g.node(v);
                        if (node.dummy === "selfedge") {
                            var selfNode = g.node(node.e.v);
                            var x = selfNode.x + selfNode.width / 2;
                            var y = selfNode.y;
                            var dx = node.x - x;
                            var dy = selfNode.height / 2;
                            g.setEdge(node.e, node.label);
                            g.removeNode(v);
                            node.label.points = [
                                {
                                    x: x + 2 * dx / 3,
                                    y: y - dy
                                },
                                {
                                    x: x + 5 * dx / 6,
                                    y: y - dy
                                },
                                {
                                    x: x + dx,
                                    y: y
                                },
                                {
                                    x: x + 5 * dx / 6,
                                    y: y + dy
                                },
                                {
                                    x: x + 2 * dx / 3,
                                    y: y + dy
                                }, 
                            ];
                            node.label.x = node.x;
                            node.label.y = node.y;
                        }
                    });
                }
                function selectNumberAttrs(obj, attrs) {
                    return _.mapValues(_.pick(obj, attrs), Number);
                }
                function canonicalize(attrs) {
                    var newAttrs = {};
                    _.forEach(attrs, function(v, k) {
                        newAttrs[k.toLowerCase()] = v;
                    });
                    return newAttrs;
                }
            },
            {
                "./acyclic": 2,
                "./add-border-segments": 3,
                "./coordinate-system": 4,
                "./graphlib": 7,
                "./lodash": 10,
                "./nesting-graph": 11,
                "./normalize": 12,
                "./order": 17,
                "./parent-dummy-chains": 22,
                "./position": 24,
                "./rank": 26,
                "./util": 29
            }, 
        ],
        10: [
            function(require, module1, exports) {
                /* global window */ var lodash;
                if (typeof require === "function") try {
                    lodash = {
                        cloneDeep: require("lodash/cloneDeep"),
                        constant: require("lodash/constant"),
                        defaults: require("lodash/defaults"),
                        each: require("lodash/each"),
                        filter: require("lodash/filter"),
                        find: require("lodash/find"),
                        flatten: require("lodash/flatten"),
                        forEach: require("lodash/forEach"),
                        forIn: require("lodash/forIn"),
                        has: require("lodash/has"),
                        isUndefined: require("lodash/isUndefined"),
                        last: require("lodash/last"),
                        map: require("lodash/map"),
                        mapValues: require("lodash/mapValues"),
                        max: require("lodash/max"),
                        merge: require("lodash/merge"),
                        min: require("lodash/min"),
                        minBy: require("lodash/minBy"),
                        now: require("lodash/now"),
                        pick: require("lodash/pick"),
                        range: require("lodash/range"),
                        reduce: require("lodash/reduce"),
                        sortBy: require("lodash/sortBy"),
                        uniqueId: require("lodash/uniqueId"),
                        values: require("lodash/values"),
                        zipObject: require("lodash/zipObject")
                    };
                } catch (e) {
                // continue regardless of error
                }
                if (!lodash) lodash = window._;
                module1.exports = lodash;
            },
            {
                "lodash/cloneDeep": 227,
                "lodash/constant": 228,
                "lodash/defaults": 229,
                "lodash/each": 230,
                "lodash/filter": 232,
                "lodash/find": 233,
                "lodash/flatten": 235,
                "lodash/forEach": 236,
                "lodash/forIn": 237,
                "lodash/has": 239,
                "lodash/isUndefined": 258,
                "lodash/last": 261,
                "lodash/map": 262,
                "lodash/mapValues": 263,
                "lodash/max": 264,
                "lodash/merge": 266,
                "lodash/min": 267,
                "lodash/minBy": 268,
                "lodash/now": 270,
                "lodash/pick": 271,
                "lodash/range": 273,
                "lodash/reduce": 274,
                "lodash/sortBy": 276,
                "lodash/uniqueId": 286,
                "lodash/values": 287,
                "lodash/zipObject": 288
            }, 
        ],
        11: [
            function(require, module1, exports) {
                var _ = require("./lodash");
                var util = require("./util");
                module1.exports = {
                    run: run,
                    cleanup: cleanup
                };
                /*
                     * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
                     * adds appropriate edges to ensure that all cluster nodes are placed between
                     * these boundries, and ensures that the graph is connected.
                     *
                     * In addition we ensure, through the use of the minlen property, that nodes
                     * and subgraph border nodes to not end up on the same rank.
                     *
                     * Preconditions:
                     *
                     *    1. Input graph is a DAG
                     *    2. Nodes in the input graph has a minlen attribute
                     *
                     * Postconditions:
                     *
                     *    1. Input graph is connected.
                     *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
                     *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
                     *       get placed on the same rank as subgraph border nodes.
                     *
                     * The nesting graph idea comes from Sander, "Layout of Compound Directed
                     * Graphs."
                     */ function run(g) {
                    var root = util.addDummyNode(g, "root", {}, "_root");
                    var depths = treeDepths(g);
                    var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array
                    var nodeSep = 2 * height + 1;
                    g.graph().nestingRoot = root;
                    // Multiply minlen by nodeSep to align nodes on non-border ranks.
                    _.forEach(g.edges(), function(e) {
                        g.edge(e).minlen *= nodeSep;
                    });
                    // Calculate a weight that is sufficient to keep subgraphs vertically compact
                    var weight = sumWeights(g) + 1;
                    // Create border nodes and link them up
                    _.forEach(g.children(), function(child) {
                        dfs(g, root, nodeSep, weight, height, depths, child);
                    });
                    // Save the multiplier for node layers for later removal of empty border
                    // layers.
                    g.graph().nodeRankFactor = nodeSep;
                }
                function dfs(g, root, nodeSep, weight, height, depths, v) {
                    var children = g.children(v);
                    if (!children.length) {
                        if (v !== root) g.setEdge(root, v, {
                            weight: 0,
                            minlen: nodeSep
                        });
                        return;
                    }
                    var top = util.addBorderNode(g, "_bt");
                    var bottom = util.addBorderNode(g, "_bb");
                    var label = g.node(v);
                    g.setParent(top, v);
                    label.borderTop = top;
                    g.setParent(bottom, v);
                    label.borderBottom = bottom;
                    _.forEach(children, function(child) {
                        dfs(g, root, nodeSep, weight, height, depths, child);
                        var childNode = g.node(child);
                        var childTop = childNode.borderTop ? childNode.borderTop : child;
                        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
                        var thisWeight = childNode.borderTop ? weight : 2 * weight;
                        var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
                        g.setEdge(top, childTop, {
                            weight: thisWeight,
                            minlen: minlen,
                            nestingEdge: true
                        });
                        g.setEdge(childBottom, bottom, {
                            weight: thisWeight,
                            minlen: minlen,
                            nestingEdge: true
                        });
                    });
                    if (!g.parent(v)) g.setEdge(root, top, {
                        weight: 0,
                        minlen: height + depths[v]
                    });
                }
                function treeDepths(g) {
                    var depths = {};
                    function dfs(v, depth) {
                        var children = g.children(v);
                        if (children && children.length) _.forEach(children, function(child) {
                            dfs(child, depth + 1);
                        });
                        depths[v] = depth;
                    }
                    _.forEach(g.children(), function(v) {
                        dfs(v, 1);
                    });
                    return depths;
                }
                function sumWeights(g) {
                    return _.reduce(g.edges(), function(acc, e) {
                        return acc + g.edge(e).weight;
                    }, 0);
                }
                function cleanup(g) {
                    var graphLabel = g.graph();
                    g.removeNode(graphLabel.nestingRoot);
                    delete graphLabel.nestingRoot;
                    _.forEach(g.edges(), function(e) {
                        var edge = g.edge(e);
                        if (edge.nestingEdge) g.removeEdge(e);
                    });
                }
            },
            {
                "./lodash": 10,
                "./util": 29
            }, 
        ],
        12: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("./lodash");
                var util = require("./util");
                module1.exports = {
                    run: run,
                    undo: undo
                };
                /*
                     * Breaks any long edges in the graph into short segments that span 1 layer
                     * each. This operation is undoable with the denormalize function.
                     *
                     * Pre-conditions:
                     *
                     *    1. The input graph is a DAG.
                     *    2. Each node in the graph has a "rank" property.
                     *
                     * Post-condition:
                     *
                     *    1. All edges in the graph have a length of 1.
                     *    2. Dummy nodes are added where edges have been split into segments.
                     *    3. The graph is augmented with a "dummyChains" attribute which contains
                     *       the first dummy in each chain of dummy nodes produced.
                     */ function run(g) {
                    g.graph().dummyChains = [];
                    _.forEach(g.edges(), function(edge) {
                        normalizeEdge(g, edge);
                    });
                }
                function normalizeEdge(g, e) {
                    var v = e.v;
                    var vRank = g.node(v).rank;
                    var w = e.w;
                    var wRank = g.node(w).rank;
                    var name = e.name;
                    var edgeLabel = g.edge(e);
                    var labelRank = edgeLabel.labelRank;
                    if (wRank === vRank + 1) return;
                    g.removeEdge(e);
                    var dummy, attrs, i;
                    for(i = 0, ++vRank; vRank < wRank; ++i, ++vRank){
                        edgeLabel.points = [];
                        attrs = {
                            width: 0,
                            height: 0,
                            edgeLabel: edgeLabel,
                            edgeObj: e,
                            rank: vRank
                        };
                        dummy = util.addDummyNode(g, "edge", attrs, "_d");
                        if (vRank === labelRank) {
                            attrs.width = edgeLabel.width;
                            attrs.height = edgeLabel.height;
                            attrs.dummy = "edge-label";
                            attrs.labelpos = edgeLabel.labelpos;
                        }
                        g.setEdge(v, dummy, {
                            weight: edgeLabel.weight
                        }, name);
                        if (i === 0) g.graph().dummyChains.push(dummy);
                        v = dummy;
                    }
                    g.setEdge(v, w, {
                        weight: edgeLabel.weight
                    }, name);
                }
                function undo(g) {
                    _.forEach(g.graph().dummyChains, function(v) {
                        var node = g.node(v);
                        var origLabel = node.edgeLabel;
                        var w;
                        g.setEdge(node.edgeObj, origLabel);
                        while(node.dummy){
                            w = g.successors(v)[0];
                            g.removeNode(v);
                            origLabel.points.push({
                                x: node.x,
                                y: node.y
                            });
                            if (node.dummy === "edge-label") {
                                origLabel.x = node.x;
                                origLabel.y = node.y;
                                origLabel.width = node.width;
                                origLabel.height = node.height;
                            }
                            v = w;
                            node = g.node(v);
                        }
                    });
                }
            },
            {
                "./lodash": 10,
                "./util": 29
            }, 
        ],
        13: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = addSubgraphConstraints;
                function addSubgraphConstraints(g, cg, vs) {
                    var prev = {}, rootPrev;
                    _.forEach(vs, function(v) {
                        var child = g.parent(v), parent, prevChild;
                        while(child){
                            parent = g.parent(child);
                            if (parent) {
                                prevChild = prev[parent];
                                prev[parent] = child;
                            } else {
                                prevChild = rootPrev;
                                rootPrev = child;
                            }
                            if (prevChild && prevChild !== child) {
                                cg.setEdge(prevChild, child);
                                return;
                            }
                            child = parent;
                        }
                    });
                /*
      function dfs(v) {
        var children = v ? g.children(v) : g.children();
        if (children.length) {
          var min = Number.POSITIVE_INFINITY,
              subgraphs = [];
          _.each(children, function(child) {
            var childMin = dfs(child);
            if (g.children(child).length) {
              subgraphs.push({ v: child, order: childMin });
            }
            min = Math.min(min, childMin);
          });
          _.reduce(_.sortBy(subgraphs, "order"), function(prev, curr) {
            cg.setEdge(prev.v, curr.v);
            return curr;
          });
          return min;
        }
        return g.node(v).order;
      }
      dfs(undefined);
      */ }
            },
            {
                "../lodash": 10
            }, 
        ],
        14: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = barycenter;
                function barycenter(g, movable) {
                    return _.map(movable, function(v) {
                        var inV = g.inEdges(v);
                        if (!inV.length) return {
                            v: v
                        };
                        else {
                            var result = _.reduce(inV, function(acc, e) {
                                var edge = g.edge(e), nodeU = g.node(e.v);
                                return {
                                    sum: acc.sum + edge.weight * nodeU.order,
                                    weight: acc.weight + edge.weight
                                };
                            }, {
                                sum: 0,
                                weight: 0
                            });
                            return {
                                v: v,
                                barycenter: result.sum / result.weight,
                                weight: result.weight
                            };
                        }
                    });
                }
            },
            {
                "../lodash": 10
            }, 
        ],
        15: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                var Graph = require("../graphlib").Graph;
                module1.exports = buildLayerGraph;
                /*
                     * Constructs a graph that can be used to sort a layer of nodes. The graph will
                     * contain all base and subgraph nodes from the request layer in their original
                     * hierarchy and any edges that are incident on these nodes and are of the type
                     * requested by the "relationship" parameter.
                     *
                     * Nodes from the requested rank that do not have parents are assigned a root
                     * node in the output graph, which is set in the root graph attribute. This
                     * makes it easy to walk the hierarchy of movable nodes during ordering.
                     *
                     * Pre-conditions:
                     *
                     *    1. Input graph is a DAG
                     *    2. Base nodes in the input graph have a rank attribute
                     *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
                     *    4. Edges have an assigned weight
                     *
                     * Post-conditions:
                     *
                     *    1. Output graph has all nodes in the movable rank with preserved
                     *       hierarchy.
                     *    2. Root nodes in the movable layer are made children of the node
                     *       indicated by the root attribute of the graph.
                     *    3. Non-movable nodes incident on movable nodes, selected by the
                     *       relationship parameter, are included in the graph (without hierarchy).
                     *    4. Edges incident on movable nodes, selected by the relationship
                     *       parameter, are added to the output graph.
                     *    5. The weights for copied edges are aggregated as need, since the output
                     *       graph is not a multi-graph.
                     */ function buildLayerGraph(g, rank, relationship) {
                    var root = createRootNode(g), result = new Graph({
                        compound: true
                    }).setGraph({
                        root: root
                    }).setDefaultNodeLabel(function(v) {
                        return g.node(v);
                    });
                    _.forEach(g.nodes(), function(v) {
                        var node = g.node(v), parent = g.parent(v);
                        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
                            result.setNode(v);
                            result.setParent(v, parent || root);
                            // This assumes we have only short edges!
                            _.forEach(g[relationship](v), function(e) {
                                var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = !_.isUndefined(edge) ? edge.weight : 0;
                                result.setEdge(u, v, {
                                    weight: g.edge(e).weight + weight
                                });
                            });
                            if (_.has(node, "minRank")) result.setNode(v, {
                                borderLeft: node.borderLeft[rank],
                                borderRight: node.borderRight[rank]
                            });
                        }
                    });
                    return result;
                }
                function createRootNode(g) {
                    var v;
                    while(g.hasNode(v = _.uniqueId("_root")));
                    return v;
                }
            },
            {
                "../graphlib": 7,
                "../lodash": 10
            }, 
        ],
        16: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                module1.exports = crossCount;
                /*
                     * A function that takes a layering (an array of layers, each with an array of
                     * ordererd nodes) and a graph and returns a weighted crossing count.
                     *
                     * Pre-conditions:
                     *
                     *    1. Input graph must be simple (not a multigraph), directed, and include
                     *       only simple edges.
                     *    2. Edges in the input graph must have assigned weights.
                     *
                     * Post-conditions:
                     *
                     *    1. The graph and layering matrix are left unchanged.
                     *
                     * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
                     */ function crossCount(g, layering) {
                    var cc = 0;
                    for(var i = 1; i < layering.length; ++i)cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
                    return cc;
                }
                function twoLayerCrossCount(g, northLayer, southLayer) {
                    // Sort all of the edges between the north and south layers by their position
                    // in the north layer and then the south. Map these edges to the position of
                    // their head in the south layer.
                    var southPos = _.zipObject(southLayer, _.map(southLayer, function(v, i) {
                        return i;
                    }));
                    var southEntries = _.flatten(_.map(northLayer, function(v) {
                        return _.sortBy(_.map(g.outEdges(v), function(e) {
                            return {
                                pos: southPos[e.w],
                                weight: g.edge(e).weight
                            };
                        }), "pos");
                    }), true);
                    // Build the accumulator tree
                    var firstIndex = 1;
                    while(firstIndex < southLayer.length)firstIndex <<= 1;
                    var treeSize = 2 * firstIndex - 1;
                    firstIndex -= 1;
                    var tree = _.map(new Array(treeSize), function() {
                        return 0;
                    });
                    // Calculate the weighted crossings
                    var cc = 0;
                    _.forEach(southEntries.forEach(function(entry) {
                        var index = entry.pos + firstIndex;
                        tree[index] += entry.weight;
                        var weightSum = 0;
                        while(index > 0){
                            if (index % 2) weightSum += tree[index + 1];
                            index = index - 1 >> 1;
                            tree[index] += entry.weight;
                        }
                        cc += entry.weight * weightSum;
                    }));
                    return cc;
                }
            },
            {
                "../lodash": 10
            }, 
        ],
        17: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                var initOrder = require("./init-order");
                var crossCount = require("./cross-count");
                var sortSubgraph = require("./sort-subgraph");
                var buildLayerGraph = require("./build-layer-graph");
                var addSubgraphConstraints = require("./add-subgraph-constraints");
                var Graph = require("../graphlib").Graph;
                var util = require("../util");
                module1.exports = order;
                /*
                     * Applies heuristics to minimize edge crossings in the graph and sets the best
                     * order solution as an order attribute on each node.
                     *
                     * Pre-conditions:
                     *
                     *    1. Graph must be DAG
                     *    2. Graph nodes must be objects with a "rank" attribute
                     *    3. Graph edges must have the "weight" attribute
                     *
                     * Post-conditions:
                     *
                     *    1. Graph nodes will have an "order" attribute based on the results of the
                     *       algorithm.
                     */ function order(g) {
                    var maxRank = util.maxRank(g), downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");
                    var layering = initOrder(g);
                    assignOrder(g, layering);
                    var bestCC = Number.POSITIVE_INFINITY, best;
                    for(var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest){
                        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
                        layering = util.buildLayerMatrix(g);
                        var cc = crossCount(g, layering);
                        if (cc < bestCC) {
                            lastBest = 0;
                            best = _.cloneDeep(layering);
                            bestCC = cc;
                        }
                    }
                    assignOrder(g, best);
                }
                function buildLayerGraphs(g, ranks, relationship) {
                    return _.map(ranks, function(rank) {
                        return buildLayerGraph(g, rank, relationship);
                    });
                }
                function sweepLayerGraphs(layerGraphs, biasRight) {
                    var cg = new Graph();
                    _.forEach(layerGraphs, function(lg) {
                        var root = lg.graph().root;
                        var sorted = sortSubgraph(lg, root, cg, biasRight);
                        _.forEach(sorted.vs, function(v, i) {
                            lg.node(v).order = i;
                        });
                        addSubgraphConstraints(lg, cg, sorted.vs);
                    });
                }
                function assignOrder(g, layering) {
                    _.forEach(layering, function(layer) {
                        _.forEach(layer, function(v, i) {
                            g.node(v).order = i;
                        });
                    });
                }
            },
            {
                "../graphlib": 7,
                "../lodash": 10,
                "../util": 29,
                "./add-subgraph-constraints": 13,
                "./build-layer-graph": 15,
                "./cross-count": 16,
                "./init-order": 18,
                "./sort-subgraph": 20
            }, 
        ],
        18: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                module1.exports = initOrder;
                /*
                     * Assigns an initial order value for each node by performing a DFS search
                     * starting from nodes in the first rank. Nodes are assigned an order in their
                     * rank as they are first visited.
                     *
                     * This approach comes from Gansner, et al., "A Technique for Drawing Directed
                     * Graphs."
                     *
                     * Returns a layering matrix with an array per layer and each layer sorted by
                     * the order of its nodes.
                     */ function initOrder(g) {
                    var visited = {};
                    var simpleNodes = _.filter(g.nodes(), function(v) {
                        return !g.children(v).length;
                    });
                    var maxRank = _.max(_.map(simpleNodes, function(v) {
                        return g.node(v).rank;
                    }));
                    var layers = _.map(_.range(maxRank + 1), function() {
                        return [];
                    });
                    function dfs(v) {
                        if (_.has(visited, v)) return;
                        visited[v] = true;
                        var node = g.node(v);
                        layers[node.rank].push(v);
                        _.forEach(g.successors(v), dfs);
                    }
                    var orderedVs = _.sortBy(simpleNodes, function(v) {
                        return g.node(v).rank;
                    });
                    _.forEach(orderedVs, dfs);
                    return layers;
                }
            },
            {
                "../lodash": 10
            }, 
        ],
        19: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                module1.exports = resolveConflicts;
                /*
                     * Given a list of entries of the form {v, barycenter, weight} and a
                     * constraint graph this function will resolve any conflicts between the
                     * constraint graph and the barycenters for the entries. If the barycenters for
                     * an entry would violate a constraint in the constraint graph then we coalesce
                     * the nodes in the conflict into a new node that respects the contraint and
                     * aggregates barycenter and weight information.
                     *
                     * This implementation is based on the description in Forster, "A Fast and
                     * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
                     * differs in some specific details.
                     *
                     * Pre-conditions:
                     *
                     *    1. Each entry has the form {v, barycenter, weight}, or if the node has
                     *       no barycenter, then {v}.
                     *
                     * Returns:
                     *
                     *    A new list of entries of the form {vs, i, barycenter, weight}. The list
                     *    `vs` may either be a singleton or it may be an aggregation of nodes
                     *    ordered such that they do not violate constraints from the constraint
                     *    graph. The property `i` is the lowest original index of any of the
                     *    elements in `vs`.
                     */ function resolveConflicts(entries, cg) {
                    var mappedEntries = {};
                    _.forEach(entries, function(entry, i) {
                        var tmp = mappedEntries[entry.v] = {
                            indegree: 0,
                            in: [],
                            out: [],
                            vs: [
                                entry.v
                            ],
                            i: i
                        };
                        if (!_.isUndefined(entry.barycenter)) {
                            tmp.barycenter = entry.barycenter;
                            tmp.weight = entry.weight;
                        }
                    });
                    _.forEach(cg.edges(), function(e) {
                        var entryV = mappedEntries[e.v];
                        var entryW = mappedEntries[e.w];
                        if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
                            entryW.indegree++;
                            entryV.out.push(mappedEntries[e.w]);
                        }
                    });
                    var sourceSet = _.filter(mappedEntries, function(entry) {
                        return !entry.indegree;
                    });
                    return doResolveConflicts(sourceSet);
                }
                function doResolveConflicts(sourceSet) {
                    var entries = [];
                    function handleIn(vEntry) {
                        return function(uEntry) {
                            if (uEntry.merged) return;
                            if (_.isUndefined(uEntry.barycenter) || _.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) mergeEntries(vEntry, uEntry);
                        };
                    }
                    function handleOut(vEntry) {
                        return function(wEntry) {
                            wEntry["in"].push(vEntry);
                            if (--wEntry.indegree === 0) sourceSet.push(wEntry);
                        };
                    }
                    while(sourceSet.length){
                        var entry = sourceSet.pop();
                        entries.push(entry);
                        _.forEach(entry["in"].reverse(), handleIn(entry));
                        _.forEach(entry.out, handleOut(entry));
                    }
                    return _.map(_.filter(entries, function(entry) {
                        return !entry.merged;
                    }), function(entry) {
                        return _.pick(entry, [
                            "vs",
                            "i",
                            "barycenter",
                            "weight", 
                        ]);
                    });
                }
                function mergeEntries(target, source) {
                    var sum = 0;
                    var weight = 0;
                    if (target.weight) {
                        sum += target.barycenter * target.weight;
                        weight += target.weight;
                    }
                    if (source.weight) {
                        sum += source.barycenter * source.weight;
                        weight += source.weight;
                    }
                    target.vs = source.vs.concat(target.vs);
                    target.barycenter = sum / weight;
                    target.weight = weight;
                    target.i = Math.min(source.i, target.i);
                    source.merged = true;
                }
            },
            {
                "../lodash": 10
            }, 
        ],
        20: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                var barycenter = require("./barycenter");
                var resolveConflicts = require("./resolve-conflicts");
                var sort = require("./sort");
                module1.exports = sortSubgraph;
                function sortSubgraph(g, v, cg, biasRight) {
                    var movable = g.children(v);
                    var node = g.node(v);
                    var bl = node ? node.borderLeft : undefined;
                    var br = node ? node.borderRight : undefined;
                    var subgraphs = {};
                    if (bl) movable = _.filter(movable, function(w) {
                        return w !== bl && w !== br;
                    });
                    var barycenters = barycenter(g, movable);
                    _.forEach(barycenters, function(entry) {
                        if (g.children(entry.v).length) {
                            var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
                            subgraphs[entry.v] = subgraphResult;
                            if (_.has(subgraphResult, "barycenter")) mergeBarycenters(entry, subgraphResult);
                        }
                    });
                    var entries = resolveConflicts(barycenters, cg);
                    expandSubgraphs(entries, subgraphs);
                    var result = sort(entries, biasRight);
                    if (bl) {
                        result.vs = _.flatten([
                            bl,
                            result.vs,
                            br
                        ], true);
                        if (g.predecessors(bl).length) {
                            var blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
                            if (!_.has(result, "barycenter")) {
                                result.barycenter = 0;
                                result.weight = 0;
                            }
                            result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
                            result.weight += 2;
                        }
                    }
                    return result;
                }
                function expandSubgraphs(entries, subgraphs) {
                    _.forEach(entries, function(entry) {
                        entry.vs = _.flatten(entry.vs.map(function(v) {
                            if (subgraphs[v]) return subgraphs[v].vs;
                            return v;
                        }), true);
                    });
                }
                function mergeBarycenters(target, other) {
                    if (!_.isUndefined(target.barycenter)) {
                        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
                        target.weight += other.weight;
                    } else {
                        target.barycenter = other.barycenter;
                        target.weight = other.weight;
                    }
                }
            },
            {
                "../lodash": 10,
                "./barycenter": 14,
                "./resolve-conflicts": 19,
                "./sort": 21
            }, 
        ],
        21: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                var util = require("../util");
                module1.exports = sort;
                function sort(entries, biasRight) {
                    var parts = util.partition(entries, function(entry) {
                        return _.has(entry, "barycenter");
                    });
                    var sortable = parts.lhs, unsortable = _.sortBy(parts.rhs, function(entry) {
                        return -entry.i;
                    }), vs = [], sum = 0, weight = 0, vsIndex = 0;
                    sortable.sort(compareWithBias(!!biasRight));
                    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
                    _.forEach(sortable, function(entry) {
                        vsIndex += entry.vs.length;
                        vs.push(entry.vs);
                        sum += entry.barycenter * entry.weight;
                        weight += entry.weight;
                        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
                    });
                    var result = {
                        vs: _.flatten(vs, true)
                    };
                    if (weight) {
                        result.barycenter = sum / weight;
                        result.weight = weight;
                    }
                    return result;
                }
                function consumeUnsortable(vs, unsortable, index) {
                    var last;
                    while(unsortable.length && (last = _.last(unsortable)).i <= index){
                        unsortable.pop();
                        vs.push(last.vs);
                        index++;
                    }
                    return index;
                }
                function compareWithBias(bias) {
                    return function(entryV, entryW) {
                        if (entryV.barycenter < entryW.barycenter) return -1;
                        else if (entryV.barycenter > entryW.barycenter) return 1;
                        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
                    };
                }
            },
            {
                "../lodash": 10,
                "../util": 29
            }, 
        ],
        22: [
            function(require, module1, exports) {
                var _ = require("./lodash");
                module1.exports = parentDummyChains;
                function parentDummyChains(g) {
                    var postorderNums = postorder(g);
                    _.forEach(g.graph().dummyChains, function(v) {
                        var node = g.node(v);
                        var edgeObj = node.edgeObj;
                        var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
                        var path = pathData.path;
                        var lca = pathData.lca;
                        var pathIdx = 0;
                        var pathV = path[pathIdx];
                        var ascending = true;
                        while(v !== edgeObj.w){
                            node = g.node(v);
                            if (ascending) {
                                while((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank)pathIdx++;
                                if (pathV === lca) ascending = false;
                            }
                            if (!ascending) {
                                while(pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank)pathIdx++;
                                pathV = path[pathIdx];
                            }
                            g.setParent(v, pathV);
                            v = g.successors(v)[0];
                        }
                    });
                }
                // Find a path from v to w through the lowest common ancestor (LCA). Return the
                // full path and the LCA.
                function findPath(g, postorderNums, v, w) {
                    var vPath = [];
                    var wPath = [];
                    var low = Math.min(postorderNums[v].low, postorderNums[w].low);
                    var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
                    var parent;
                    var lca;
                    // Traverse up from v to find the LCA
                    parent = v;
                    do {
                        parent = g.parent(parent);
                        vPath.push(parent);
                    }while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
                    lca = parent;
                    // Traverse from w to LCA
                    parent = w;
                    while((parent = g.parent(parent)) !== lca)wPath.push(parent);
                    return {
                        path: vPath.concat(wPath.reverse()),
                        lca: lca
                    };
                }
                function postorder(g) {
                    var result = {};
                    var lim = 0;
                    function dfs(v) {
                        var low = lim;
                        _.forEach(g.children(v), dfs);
                        result[v] = {
                            low: low,
                            lim: lim++
                        };
                    }
                    _.forEach(g.children(), dfs);
                    return result;
                }
            },
            {
                "./lodash": 10
            }, 
        ],
        23: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                var Graph = require("../graphlib").Graph;
                var util = require("../util");
                /*
                     * This module provides coordinate assignment based on Brandes and K√∂pf, "Fast
                     * and Simple Horizontal Coordinate Assignment."
                     */ module1.exports = {
                    positionX: positionX,
                    findType1Conflicts: findType1Conflicts,
                    findType2Conflicts: findType2Conflicts,
                    addConflict: addConflict,
                    hasConflict: hasConflict,
                    verticalAlignment: verticalAlignment,
                    horizontalCompaction: horizontalCompaction,
                    alignCoordinates: alignCoordinates,
                    findSmallestWidthAlignment: findSmallestWidthAlignment,
                    balance: balance
                };
                /*
                     * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
                     * property. A type-1 conflict is one where a non-inner segment crosses an
                     * inner segment. An inner segment is an edge with both incident nodes marked
                     * with the "dummy" property.
                     *
                     * This algorithm scans layer by layer, starting with the second, for type-1
                     * conflicts between the current layer and the previous layer. For each layer
                     * it scans the nodes from left to right until it reaches one that is incident
                     * on an inner segment. It then scans predecessors to determine if they have
                     * edges that cross that inner segment. At the end a final scan is done for all
                     * nodes on the current rank to see if they cross the last visited inner
                     * segment.
                     *
                     * This algorithm (safely) assumes that a dummy node will only be incident on a
                     * single node in the layers being scanned.
                     */ function findType1Conflicts(g, layering) {
                    var conflicts = {};
                    function visitLayer(prevLayer, layer) {
                        var // segment.
                        k0 = 0, // Tracks the last node in this layer scanned for crossings with a type-1
                        // segment.
                        scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _.last(layer);
                        _.forEach(layer, function(v, i) {
                            var w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
                            if (w || v === lastNode) {
                                _.forEach(layer.slice(scanPos, i + 1), function(scanNode) {
                                    _.forEach(g.predecessors(scanNode), function(u) {
                                        var uLabel = g.node(u), uPos = uLabel.order;
                                        if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) addConflict(conflicts, u, scanNode);
                                    });
                                });
                                scanPos = i + 1;
                                k0 = k1;
                            }
                        });
                        return layer;
                    }
                    _.reduce(layering, visitLayer);
                    return conflicts;
                }
                function findType2Conflicts(g, layering) {
                    var conflicts = {};
                    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
                        var v;
                        _.forEach(_.range(southPos, southEnd), function(i) {
                            v = south[i];
                            if (g.node(v).dummy) _.forEach(g.predecessors(v), function(u) {
                                var uNode = g.node(u);
                                if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) addConflict(conflicts, u, v);
                            });
                        });
                    }
                    function visitLayer(north, south) {
                        var prevNorthPos = -1, nextNorthPos, southPos = 0;
                        _.forEach(south, function(v, southLookahead) {
                            if (g.node(v).dummy === "border") {
                                var predecessors = g.predecessors(v);
                                if (predecessors.length) {
                                    nextNorthPos = g.node(predecessors[0]).order;
                                    scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
                                    southPos = southLookahead;
                                    prevNorthPos = nextNorthPos;
                                }
                            }
                            scan(south, southPos, south.length, nextNorthPos, north.length);
                        });
                        return south;
                    }
                    _.reduce(layering, visitLayer);
                    return conflicts;
                }
                function findOtherInnerSegmentNode(g, v) {
                    if (g.node(v).dummy) return _.find(g.predecessors(v), function(u) {
                        return g.node(u).dummy;
                    });
                }
                function addConflict(conflicts, v, w) {
                    if (v > w) {
                        var tmp = v;
                        v = w;
                        w = tmp;
                    }
                    var conflictsV = conflicts[v];
                    if (!conflictsV) conflicts[v] = conflictsV = {};
                    conflictsV[w] = true;
                }
                function hasConflict(conflicts, v, w) {
                    if (v > w) {
                        var tmp = v;
                        v = w;
                        w = tmp;
                    }
                    return _.has(conflicts[v], w);
                }
                /*
                     * Try to align nodes into vertical "blocks" where possible. This algorithm
                     * attempts to align a node with one of its median neighbors. If the edge
                     * connecting a neighbor is a type-1 conflict then we ignore that possibility.
                     * If a previous node has already formed a block with a node after the node
                     * we're trying to form a block with, we also ignore that possibility - our
                     * blocks would be split in that scenario.
                     */ function verticalAlignment(g, layering, conflicts, neighborFn) {
                    var root = {}, align = {}, pos = {};
                    // We cache the position here based on the layering because the graph and
                    // layering may be out of sync. The layering matrix is manipulated to
                    // generate different extreme alignments.
                    _.forEach(layering, function(layer) {
                        _.forEach(layer, function(v, order) {
                            root[v] = v;
                            align[v] = v;
                            pos[v] = order;
                        });
                    });
                    _.forEach(layering, function(layer) {
                        var prevIdx = -1;
                        _.forEach(layer, function(v) {
                            var ws = neighborFn(v);
                            if (ws.length) {
                                ws = _.sortBy(ws, function(w) {
                                    return pos[w];
                                });
                                var mp = (ws.length - 1) / 2;
                                for(var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i){
                                    var w = ws[i];
                                    if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
                                        align[w] = v;
                                        align[v] = root[v] = root[w];
                                        prevIdx = pos[w];
                                    }
                                }
                            }
                        });
                    });
                    return {
                        root: root,
                        align: align
                    };
                }
                function horizontalCompaction(g, layering, root, align, reverseSep) {
                    // This portion of the algorithm differs from BK due to a number of problems.
                    // Instead of their algorithm we construct a new block graph and do two
                    // sweeps. The first sweep places blocks with the smallest possible
                    // coordinates. The second sweep removes unused space by moving blocks to the
                    // greatest coordinates without violating separation.
                    var xs = {}, blockG = buildBlockGraph(g, layering, root, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
                    function iterate(setXsFunc, nextNodesFunc) {
                        var stack = blockG.nodes();
                        var elem = stack.pop();
                        var visited = {};
                        while(elem){
                            if (visited[elem]) setXsFunc(elem);
                            else {
                                visited[elem] = true;
                                stack.push(elem);
                                stack = stack.concat(nextNodesFunc(elem));
                            }
                            elem = stack.pop();
                        }
                    }
                    // First pass, assign smallest coordinates
                    function pass1(elem) {
                        xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
                            return Math.max(acc, xs[e.v] + blockG.edge(e));
                        }, 0);
                    }
                    // Second pass, assign greatest coordinates
                    function pass2(elem) {
                        var min = blockG.outEdges(elem).reduce(function(acc, e) {
                            return Math.min(acc, xs[e.w] - blockG.edge(e));
                        }, Number.POSITIVE_INFINITY);
                        var node = g.node(elem);
                        if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) xs[elem] = Math.max(xs[elem], min);
                    }
                    iterate(pass1, blockG.predecessors.bind(blockG));
                    iterate(pass2, blockG.successors.bind(blockG));
                    // Assign x coordinates to all nodes
                    _.forEach(align, function(v) {
                        xs[v] = xs[root[v]];
                    });
                    return xs;
                }
                function buildBlockGraph(g, layering, root, reverseSep) {
                    var blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
                    _.forEach(layering, function(layer) {
                        var u;
                        _.forEach(layer, function(v) {
                            var vRoot = root[v];
                            blockGraph.setNode(vRoot);
                            if (u) {
                                var uRoot = root[u], prevMax = blockGraph.edge(uRoot, vRoot);
                                blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
                            }
                            u = v;
                        });
                    });
                    return blockGraph;
                }
                /*
                     * Returns the alignment that has the smallest width of the given alignments.
                     */ function findSmallestWidthAlignment(g, xss) {
                    return _.minBy(_.values(xss), function(xs) {
                        var max = Number.NEGATIVE_INFINITY;
                        var min = Number.POSITIVE_INFINITY;
                        _.forIn(xs, function(x, v) {
                            var halfWidth = width(g, v) / 2;
                            max = Math.max(x + halfWidth, max);
                            min = Math.min(x - halfWidth, min);
                        });
                        return max - min;
                    });
                }
                /*
                     * Align the coordinates of each of the layout alignments such that
                     * left-biased alignments have their minimum coordinate at the same point as
                     * the minimum coordinate of the smallest width alignment and right-biased
                     * alignments have their maximum coordinate at the same point as the maximum
                     * coordinate of the smallest width alignment.
                     */ function alignCoordinates(xss, alignTo) {
                    var alignToVals = _.values(alignTo), alignToMin = _.min(alignToVals), alignToMax = _.max(alignToVals);
                    _.forEach([
                        "u",
                        "d"
                    ], function(vert) {
                        _.forEach([
                            "l",
                            "r"
                        ], function(horiz) {
                            var alignment = vert + horiz, xs = xss[alignment], delta;
                            if (xs === alignTo) return;
                            var xsVals = _.values(xs);
                            delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);
                            if (delta) xss[alignment] = _.mapValues(xs, function(x) {
                                return x + delta;
                            });
                        });
                    });
                }
                function balance(xss, align) {
                    return _.mapValues(xss.ul, function(ignore, v) {
                        if (align) return xss[align.toLowerCase()][v];
                        else {
                            var xs = _.sortBy(_.map(xss, v));
                            return (xs[1] + xs[2]) / 2;
                        }
                    });
                }
                function positionX(g) {
                    var layering = util.buildLayerMatrix(g);
                    var conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
                    var xss = {};
                    var adjustedLayering;
                    _.forEach([
                        "u",
                        "d"
                    ], function(vert) {
                        adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
                        _.forEach([
                            "l",
                            "r"
                        ], function(horiz) {
                            if (horiz === "r") adjustedLayering = _.map(adjustedLayering, function(inner) {
                                return _.values(inner).reverse();
                            });
                            var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
                            var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
                            var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === "r");
                            if (horiz === "r") xs = _.mapValues(xs, function(x) {
                                return -x;
                            });
                            xss[vert + horiz] = xs;
                        });
                    });
                    var smallestWidth = findSmallestWidthAlignment(g, xss);
                    alignCoordinates(xss, smallestWidth);
                    return balance(xss, g.graph().align);
                }
                function sep(nodeSep, edgeSep, reverseSep) {
                    return function(g, v, w) {
                        var vLabel = g.node(v);
                        var wLabel = g.node(w);
                        var sum = 0;
                        var delta;
                        sum += vLabel.width / 2;
                        if (_.has(vLabel, "labelpos")) switch(vLabel.labelpos.toLowerCase()){
                            case "l":
                                delta = -vLabel.width / 2;
                                break;
                            case "r":
                                delta = vLabel.width / 2;
                                break;
                        }
                        if (delta) sum += reverseSep ? delta : -delta;
                        delta = 0;
                        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
                        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
                        sum += wLabel.width / 2;
                        if (_.has(wLabel, "labelpos")) switch(wLabel.labelpos.toLowerCase()){
                            case "l":
                                delta = wLabel.width / 2;
                                break;
                            case "r":
                                delta = -wLabel.width / 2;
                                break;
                        }
                        if (delta) sum += reverseSep ? delta : -delta;
                        delta = 0;
                        return sum;
                    };
                }
                function width(g, v) {
                    return g.node(v).width;
                }
            },
            {
                "../graphlib": 7,
                "../lodash": 10,
                "../util": 29
            }, 
        ],
        24: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                var util = require("../util");
                var positionX = require("./bk").positionX;
                module1.exports = position;
                function position(g) {
                    g = util.asNonCompoundGraph(g);
                    positionY(g);
                    _.forEach(positionX(g), function(x, v) {
                        g.node(v).x = x;
                    });
                }
                function positionY(g) {
                    var layering = util.buildLayerMatrix(g);
                    var rankSep = g.graph().ranksep;
                    var prevY = 0;
                    _.forEach(layering, function(layer) {
                        var maxHeight = _.max(_.map(layer, function(v) {
                            return g.node(v).height;
                        }));
                        _.forEach(layer, function(v) {
                            g.node(v).y = prevY + maxHeight / 2;
                        });
                        prevY += maxHeight + rankSep;
                    });
                }
            },
            {
                "../lodash": 10,
                "../util": 29,
                "./bk": 23
            }, 
        ],
        25: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                var Graph = require("../graphlib").Graph;
                var slack = require("./util").slack;
                module1.exports = feasibleTree;
                /*
                     * Constructs a spanning tree with tight edges and adjusted the input node's
                     * ranks to achieve this. A tight edge is one that is has a length that matches
                     * its "minlen" attribute.
                     *
                     * The basic structure for this function is derived from Gansner, et al., "A
                     * Technique for Drawing Directed Graphs."
                     *
                     * Pre-conditions:
                     *
                     *    1. Graph must be a DAG.
                     *    2. Graph must be connected.
                     *    3. Graph must have at least one node.
                     *    5. Graph nodes must have been previously assigned a "rank" property that
                     *       respects the "minlen" property of incident edges.
                     *    6. Graph edges must have a "minlen" property.
                     *
                     * Post-conditions:
                     *
                     *    - Graph nodes will have their rank adjusted to ensure that all edges are
                     *      tight.
                     *
                     * Returns a tree (undirected graph) that is constructed using only "tight"
                     * edges.
                     */ function feasibleTree(g) {
                    var t = new Graph({
                        directed: false
                    });
                    // Choose arbitrary node from which to start our tree
                    var start = g.nodes()[0];
                    var size = g.nodeCount();
                    t.setNode(start, {});
                    var edge, delta;
                    while(tightTree(t, g) < size){
                        edge = findMinSlackEdge(t, g);
                        delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
                        shiftRanks(t, g, delta);
                    }
                    return t;
                }
                /*
                     * Finds a maximal tree of tight edges and returns the number of nodes in the
                     * tree.
                     */ function tightTree(t, g) {
                    function dfs(v) {
                        _.forEach(g.nodeEdges(v), function(e) {
                            var edgeV = e.v, w = v === edgeV ? e.w : edgeV;
                            if (!t.hasNode(w) && !slack(g, e)) {
                                t.setNode(w, {});
                                t.setEdge(v, w, {});
                                dfs(w);
                            }
                        });
                    }
                    _.forEach(t.nodes(), dfs);
                    return t.nodeCount();
                }
                /*
                     * Finds the edge with the smallest slack that is incident on tree and returns
                     * it.
                     */ function findMinSlackEdge(t, g) {
                    return _.minBy(g.edges(), function(e) {
                        if (t.hasNode(e.v) !== t.hasNode(e.w)) return slack(g, e);
                    });
                }
                function shiftRanks(t, g, delta) {
                    _.forEach(t.nodes(), function(v) {
                        g.node(v).rank += delta;
                    });
                }
            },
            {
                "../graphlib": 7,
                "../lodash": 10,
                "./util": 28
            }, 
        ],
        26: [
            function(require, module1, exports) {
                "use strict";
                var rankUtil = require("./util");
                var longestPath = rankUtil.longestPath;
                var feasibleTree = require("./feasible-tree");
                var networkSimplex = require("./network-simplex");
                module1.exports = rank;
                /*
                     * Assigns a rank to each node in the input graph that respects the "minlen"
                     * constraint specified on edges between nodes.
                     *
                     * This basic structure is derived from Gansner, et al., "A Technique for
                     * Drawing Directed Graphs."
                     *
                     * Pre-conditions:
                     *
                     *    1. Graph must be a connected DAG
                     *    2. Graph nodes must be objects
                     *    3. Graph edges must have "weight" and "minlen" attributes
                     *
                     * Post-conditions:
                     *
                     *    1. Graph nodes will have a "rank" attribute based on the results of the
                     *       algorithm. Ranks can start at any index (including negative), we'll
                     *       fix them up later.
                     */ function rank(g) {
                    switch(g.graph().ranker){
                        case "network-simplex":
                            networkSimplexRanker(g);
                            break;
                        case "tight-tree":
                            tightTreeRanker(g);
                            break;
                        case "longest-path":
                            longestPathRanker(g);
                            break;
                        default:
                            networkSimplexRanker(g);
                    }
                }
                // A fast and simple ranker, but results are far from optimal.
                var longestPathRanker = longestPath;
                function tightTreeRanker(g) {
                    longestPath(g);
                    feasibleTree(g);
                }
                function networkSimplexRanker(g) {
                    networkSimplex(g);
                }
            },
            {
                "./feasible-tree": 25,
                "./network-simplex": 27,
                "./util": 28
            }, 
        ],
        27: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                var feasibleTree = require("./feasible-tree");
                var slack = require("./util").slack;
                var initRank = require("./util").longestPath;
                var preorder = require("../graphlib").alg.preorder;
                var postorder = require("../graphlib").alg.postorder;
                var simplify = require("../util").simplify;
                module1.exports = networkSimplex;
                // Expose some internals for testing purposes
                networkSimplex.initLowLimValues = initLowLimValues;
                networkSimplex.initCutValues = initCutValues;
                networkSimplex.calcCutValue = calcCutValue;
                networkSimplex.leaveEdge = leaveEdge;
                networkSimplex.enterEdge = enterEdge;
                networkSimplex.exchangeEdges = exchangeEdges;
                /*
                     * The network simplex algorithm assigns ranks to each node in the input graph
                     * and iteratively improves the ranking to reduce the length of edges.
                     *
                     * Preconditions:
                     *
                     *    1. The input graph must be a DAG.
                     *    2. All nodes in the graph must have an object value.
                     *    3. All edges in the graph must have "minlen" and "weight" attributes.
                     *
                     * Postconditions:
                     *
                     *    1. All nodes in the graph will have an assigned "rank" attribute that has
                     *       been optimized by the network simplex algorithm. Ranks start at 0.
                     *
                     *
                     * A rough sketch of the algorithm is as follows:
                     *
                     *    1. Assign initial ranks to each node. We use the longest path algorithm,
                     *       which assigns ranks to the lowest position possible. In general this
                     *       leads to very wide bottom ranks and unnecessarily long edges.
                     *    2. Construct a feasible tight tree. A tight tree is one such that all
                     *       edges in the tree have no slack (difference between length of edge
                     *       and minlen for the edge). This by itself greatly improves the assigned
                     *       rankings by shorting edges.
                     *    3. Iteratively find edges that have negative cut values. Generally a
                     *       negative cut value indicates that the edge could be removed and a new
                     *       tree edge could be added to produce a more compact graph.
                     *
                     * Much of the algorithms here are derived from Gansner, et al., "A Technique
                     * for Drawing Directed Graphs." The structure of the file roughly follows the
                     * structure of the overall algorithm.
                     */ function networkSimplex(g) {
                    g = simplify(g);
                    initRank(g);
                    var t = feasibleTree(g);
                    initLowLimValues(t);
                    initCutValues(t, g);
                    var e, f;
                    while(e = leaveEdge(t)){
                        f = enterEdge(t, g, e);
                        exchangeEdges(t, g, e, f);
                    }
                }
                /*
                     * Initializes cut values for all edges in the tree.
                     */ function initCutValues(t, g) {
                    var vs = postorder(t, t.nodes());
                    vs = vs.slice(0, vs.length - 1);
                    _.forEach(vs, function(v) {
                        assignCutValue(t, g, v);
                    });
                }
                function assignCutValue(t, g, child) {
                    var childLab = t.node(child);
                    var parent = childLab.parent;
                    t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
                }
                /*
                     * Given the tight tree, its graph, and a child in the graph calculate and
                     * return the cut value for the edge between the child and its parent.
                     */ function calcCutValue(t, g, child) {
                    var childLab = t.node(child);
                    var parent = childLab.parent;
                    // True if the child is on the tail end of the edge in the directed graph
                    var childIsTail = true;
                    // The graph's view of the tree edge we're inspecting
                    var graphEdge = g.edge(child, parent);
                    // The accumulated cut value for the edge between this node and its parent
                    var cutValue = 0;
                    if (!graphEdge) {
                        childIsTail = false;
                        graphEdge = g.edge(parent, child);
                    }
                    cutValue = graphEdge.weight;
                    _.forEach(g.nodeEdges(child), function(e) {
                        var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
                        if (other !== parent) {
                            var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
                            cutValue += pointsToHead ? otherWeight : -otherWeight;
                            if (isTreeEdge(t, child, other)) {
                                var otherCutValue = t.edge(child, other).cutvalue;
                                cutValue += pointsToHead ? -otherCutValue : otherCutValue;
                            }
                        }
                    });
                    return cutValue;
                }
                function initLowLimValues(tree, root) {
                    if (arguments.length < 2) root = tree.nodes()[0];
                    dfsAssignLowLim(tree, {}, 1, root);
                }
                function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
                    var low = nextLim;
                    var label = tree.node(v);
                    visited[v] = true;
                    _.forEach(tree.neighbors(v), function(w) {
                        if (!_.has(visited, w)) nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
                    });
                    label.low = low;
                    label.lim = nextLim++;
                    if (parent) label.parent = parent;
                    else // TODO should be able to remove this when we incrementally update low lim
                    delete label.parent;
                    return nextLim;
                }
                function leaveEdge(tree) {
                    return _.find(tree.edges(), function(e) {
                        return tree.edge(e).cutvalue < 0;
                    });
                }
                function enterEdge(t, g, edge) {
                    var v = edge.v;
                    var w = edge.w;
                    // For the rest of this function we assume that v is the tail and w is the
                    // head, so if we don't have this edge in the graph we should flip it to
                    // match the correct orientation.
                    if (!g.hasEdge(v, w)) {
                        v = edge.w;
                        w = edge.v;
                    }
                    var vLabel = t.node(v);
                    var wLabel = t.node(w);
                    var tailLabel = vLabel;
                    var flip = false;
                    // If the root is in the tail of the edge then we need to flip the logic that
                    // checks for the head and tail nodes in the candidates function below.
                    if (vLabel.lim > wLabel.lim) {
                        tailLabel = wLabel;
                        flip = true;
                    }
                    var candidates = _.filter(g.edges(), function(edge) {
                        return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);
                    });
                    return _.minBy(candidates, function(edge) {
                        return slack(g, edge);
                    });
                }
                function exchangeEdges(t, g, e, f) {
                    var v = e.v;
                    var w = e.w;
                    t.removeEdge(v, w);
                    t.setEdge(f.v, f.w, {});
                    initLowLimValues(t);
                    initCutValues(t, g);
                    updateRanks(t, g);
                }
                function updateRanks(t, g) {
                    var root = _.find(t.nodes(), function(v) {
                        return !g.node(v).parent;
                    });
                    var vs = preorder(t, root);
                    vs = vs.slice(1);
                    _.forEach(vs, function(v) {
                        var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
                        if (!edge) {
                            edge = g.edge(parent, v);
                            flipped = true;
                        }
                        g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
                    });
                }
                /*
                     * Returns true if the edge is in the tree.
                     */ function isTreeEdge(tree, u, v) {
                    return tree.hasEdge(u, v);
                }
                /*
                     * Returns true if the specified node is descendant of the root node per the
                     * assigned low and lim attributes in the tree.
                     */ function isDescendant(tree, vLabel, rootLabel) {
                    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
                }
            },
            {
                "../graphlib": 7,
                "../lodash": 10,
                "../util": 29,
                "./feasible-tree": 25,
                "./util": 28
            }, 
        ],
        28: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("../lodash");
                module1.exports = {
                    longestPath: longestPath,
                    slack: slack
                };
                /*
                     * Initializes ranks for the input graph using the longest path algorithm. This
                     * algorithm scales well and is fast in practice, it yields rather poor
                     * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
                     * ranks wide and leaving edges longer than necessary. However, due to its
                     * speed, this algorithm is good for getting an initial ranking that can be fed
                     * into other algorithms.
                     *
                     * This algorithm does not normalize layers because it will be used by other
                     * algorithms in most cases. If using this algorithm directly, be sure to
                     * run normalize at the end.
                     *
                     * Pre-conditions:
                     *
                     *    1. Input graph is a DAG.
                     *    2. Input graph node labels can be assigned properties.
                     *
                     * Post-conditions:
                     *
                     *    1. Each node will be assign an (unnormalized) "rank" property.
                     */ function longestPath(g) {
                    var visited = {};
                    function dfs(v) {
                        var label = g.node(v);
                        if (_.has(visited, v)) return label.rank;
                        visited[v] = true;
                        var rank = _.min(_.map(g.outEdges(v), function(e) {
                            return dfs(e.w) - g.edge(e).minlen;
                        }));
                        if (rank === Number.POSITIVE_INFINITY || rank === undefined || rank === null) // return value of _.map([null])
                        rank = 0;
                        return label.rank = rank;
                    }
                    _.forEach(g.sources(), dfs);
                }
                /*
                     * Returns the amount of slack for the given edge. The slack is defined as the
                     * difference between the length of the edge and its minimum length.
                     */ function slack(g, e) {
                    return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
                }
            },
            {
                "../lodash": 10
            }, 
        ],
        29: [
            function(require, module1, exports) {
                /* eslint "no-console": off */ "use strict";
                var _ = require("./lodash");
                var Graph = require("./graphlib").Graph;
                module1.exports = {
                    addDummyNode: addDummyNode,
                    simplify: simplify,
                    asNonCompoundGraph: asNonCompoundGraph,
                    successorWeights: successorWeights,
                    predecessorWeights: predecessorWeights,
                    intersectRect: intersectRect,
                    buildLayerMatrix: buildLayerMatrix,
                    normalizeRanks: normalizeRanks,
                    removeEmptyRanks: removeEmptyRanks,
                    addBorderNode: addBorderNode,
                    maxRank: maxRank,
                    partition: partition,
                    time: time,
                    notime: notime
                };
                /*
                     * Adds a dummy node to the graph and return v.
                     */ function addDummyNode(g, type, attrs, name) {
                    var v;
                    do v = _.uniqueId(name);
                    while (g.hasNode(v));
                    attrs.dummy = type;
                    g.setNode(v, attrs);
                    return v;
                }
                /*
                     * Returns a new graph with only simple edges. Handles aggregation of data
                     * associated with multi-edges.
                     */ function simplify(g) {
                    var simplified = new Graph().setGraph(g.graph());
                    _.forEach(g.nodes(), function(v) {
                        simplified.setNode(v, g.node(v));
                    });
                    _.forEach(g.edges(), function(e) {
                        var simpleLabel = simplified.edge(e.v, e.w) || {
                            weight: 0,
                            minlen: 1
                        };
                        var label = g.edge(e);
                        simplified.setEdge(e.v, e.w, {
                            weight: simpleLabel.weight + label.weight,
                            minlen: Math.max(simpleLabel.minlen, label.minlen)
                        });
                    });
                    return simplified;
                }
                function asNonCompoundGraph(g) {
                    var simplified = new Graph({
                        multigraph: g.isMultigraph()
                    }).setGraph(g.graph());
                    _.forEach(g.nodes(), function(v) {
                        if (!g.children(v).length) simplified.setNode(v, g.node(v));
                    });
                    _.forEach(g.edges(), function(e) {
                        simplified.setEdge(e, g.edge(e));
                    });
                    return simplified;
                }
                function successorWeights(g) {
                    var weightMap = _.map(g.nodes(), function(v) {
                        var sucs = {};
                        _.forEach(g.outEdges(v), function(e) {
                            sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
                        });
                        return sucs;
                    });
                    return _.zipObject(g.nodes(), weightMap);
                }
                function predecessorWeights(g) {
                    var weightMap = _.map(g.nodes(), function(v) {
                        var preds = {};
                        _.forEach(g.inEdges(v), function(e) {
                            preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
                        });
                        return preds;
                    });
                    return _.zipObject(g.nodes(), weightMap);
                }
                /*
                     * Finds where a line starting at point ({x, y}) would intersect a rectangle
                     * ({x, y, width, height}) if it were pointing at the rectangle's center.
                     */ function intersectRect(rect, point) {
                    var x = rect.x;
                    var y = rect.y;
                    // Rectangle intersection algorithm from:
                    // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
                    var dx = point.x - x;
                    var dy = point.y - y;
                    var w = rect.width / 2;
                    var h = rect.height / 2;
                    if (!dx && !dy) throw new Error("Not possible to find intersection inside of the rectangle");
                    var sx, sy;
                    if (Math.abs(dy) * w > Math.abs(dx) * h) {
                        // Intersection is top or bottom of rect.
                        if (dy < 0) h = -h;
                        sx = h * dx / dy;
                        sy = h;
                    } else {
                        // Intersection is left or right of rect.
                        if (dx < 0) w = -w;
                        sx = w;
                        sy = w * dy / dx;
                    }
                    return {
                        x: x + sx,
                        y: y + sy
                    };
                }
                /*
                     * Given a DAG with each node assigned "rank" and "order" properties, this
                     * function will produce a matrix with the ids of each node.
                     */ function buildLayerMatrix(g) {
                    var layering = _.map(_.range(maxRank(g) + 1), function() {
                        return [];
                    });
                    _.forEach(g.nodes(), function(v) {
                        var node = g.node(v);
                        var rank = node.rank;
                        if (!_.isUndefined(rank)) layering[rank][node.order] = v;
                    });
                    return layering;
                }
                /*
                     * Adjusts the ranks for all nodes in the graph such that all nodes v have
                     * rank(v) >= 0 and at least one node w has rank(w) = 0.
                     */ function normalizeRanks(g) {
                    var min = _.min(_.map(g.nodes(), function(v) {
                        return g.node(v).rank;
                    }));
                    _.forEach(g.nodes(), function(v) {
                        var node = g.node(v);
                        if (_.has(node, "rank")) node.rank -= min;
                    });
                }
                function removeEmptyRanks(g) {
                    // Ranks may not start at 0, so we need to offset them
                    var offset = _.min(_.map(g.nodes(), function(v) {
                        return g.node(v).rank;
                    }));
                    var layers = [];
                    _.forEach(g.nodes(), function(v) {
                        var rank = g.node(v).rank - offset;
                        if (!layers[rank]) layers[rank] = [];
                        layers[rank].push(v);
                    });
                    var delta = 0;
                    var nodeRankFactor = g.graph().nodeRankFactor;
                    _.forEach(layers, function(vs, i) {
                        if (_.isUndefined(vs) && i % nodeRankFactor !== 0) --delta;
                        else if (delta) _.forEach(vs, function(v) {
                            g.node(v).rank += delta;
                        });
                    });
                }
                function addBorderNode(g, prefix, rank, order) {
                    var node = {
                        width: 0,
                        height: 0
                    };
                    if (arguments.length >= 4) {
                        node.rank = rank;
                        node.order = order;
                    }
                    return addDummyNode(g, "border", node, prefix);
                }
                function maxRank(g) {
                    return _.max(_.map(g.nodes(), function(v) {
                        var rank = g.node(v).rank;
                        if (!_.isUndefined(rank)) return rank;
                    }));
                }
                /*
                     * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
                     * function returns true for an entry it goes into `lhs`. Otherwise it goes
                     * into `rhs.
                     */ function partition(collection, fn) {
                    var result = {
                        lhs: [],
                        rhs: []
                    };
                    _.forEach(collection, function(value) {
                        if (fn(value)) result.lhs.push(value);
                        else result.rhs.push(value);
                    });
                    return result;
                }
                /*
                     * Returns a new function that wraps `fn` with a timer. The wrapper logs the
                     * time it takes to execute the function.
                     */ function time(name, fn) {
                    var start = _.now();
                    try {
                        return fn();
                    } finally{
                        console.log(name + " time: " + (_.now() - start) + "ms");
                    }
                }
                function notime(name, fn) {
                    return fn();
                }
            },
            {
                "./graphlib": 7,
                "./lodash": 10
            }, 
        ],
        30: [
            function(require, module1, exports) {
                module1.exports = "0.8.5";
            },
            {}, 
        ],
        31: [
            function(require, module1, exports) {
                /**
                     * Copyright (c) 2014, Chris Pettitt
                     * All rights reserved.
                     *
                     * Redistribution and use in source and binary forms, with or without
                     * modification, are permitted provided that the following conditions are met:
                     *
                     * 1. Redistributions of source code must retain the above copyright notice, this
                     * list of conditions and the following disclaimer.
                     *
                     * 2. Redistributions in binary form must reproduce the above copyright notice,
                     * this list of conditions and the following disclaimer in the documentation
                     * and/or other materials provided with the distribution.
                     *
                     * 3. Neither the name of the copyright holder nor the names of its contributors
                     * may be used to endorse or promote products derived from this software without
                     * specific prior written permission.
                     *
                     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                     */ var lib = require("./lib");
                module1.exports = {
                    Graph: lib.Graph,
                    json: require("./lib/json"),
                    alg: require("./lib/alg"),
                    version: lib.version
                };
            },
            {
                "./lib": 47,
                "./lib/alg": 38,
                "./lib/json": 48
            }, 
        ],
        32: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = components;
                function components(g) {
                    var visited = {};
                    var cmpts = [];
                    var cmpt;
                    function dfs(v) {
                        if (_.has(visited, v)) return;
                        visited[v] = true;
                        cmpt.push(v);
                        _.each(g.successors(v), dfs);
                        _.each(g.predecessors(v), dfs);
                    }
                    _.each(g.nodes(), function(v) {
                        cmpt = [];
                        dfs(v);
                        if (cmpt.length) cmpts.push(cmpt);
                    });
                    return cmpts;
                }
            },
            {
                "../lodash": 49
            }, 
        ],
        33: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = dfs;
                /*
                     * A helper that preforms a pre- or post-order traversal on the input graph
                     * and returns the nodes in the order they were visited. If the graph is
                     * undirected then this algorithm will navigate using neighbors. If the graph
                     * is directed then this algorithm will navigate using successors.
                     *
                     * Order must be one of "pre" or "post".
                     */ function dfs(g, vs, order) {
                    if (!_.isArray(vs)) vs = [
                        vs
                    ];
                    var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
                    var acc = [];
                    var visited = {};
                    _.each(vs, function(v) {
                        if (!g.hasNode(v)) throw new Error("Graph does not have node: " + v);
                        doDfs(g, v, order === "post", visited, navigation, acc);
                    });
                    return acc;
                }
                function doDfs(g, v, postorder, visited, navigation, acc) {
                    if (!_.has(visited, v)) {
                        visited[v] = true;
                        if (!postorder) acc.push(v);
                        _.each(navigation(v), function(w) {
                            doDfs(g, w, postorder, visited, navigation, acc);
                        });
                        if (postorder) acc.push(v);
                    }
                }
            },
            {
                "../lodash": 49
            }, 
        ],
        34: [
            function(require, module1, exports) {
                var dijkstra = require("./dijkstra");
                var _ = require("../lodash");
                module1.exports = dijkstraAll;
                function dijkstraAll(g, weightFunc, edgeFunc) {
                    return _.transform(g.nodes(), function(acc, v) {
                        acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
                    }, {});
                }
            },
            {
                "../lodash": 49,
                "./dijkstra": 35
            }, 
        ],
        35: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                var PriorityQueue = require("../data/priority-queue");
                module1.exports = dijkstra;
                var DEFAULT_WEIGHT_FUNC = _.constant(1);
                function dijkstra(g, source, weightFn, edgeFn) {
                    return runDijkstra(g, String(source), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v) {
                        return g.outEdges(v);
                    });
                }
                function runDijkstra(g, source, weightFn, edgeFn) {
                    var results = {};
                    var pq = new PriorityQueue();
                    var v, vEntry;
                    var updateNeighbors = function(edge) {
                        var w = edge.v !== v ? edge.v : edge.w;
                        var wEntry = results[w];
                        var weight = weightFn(edge);
                        var distance = vEntry.distance + weight;
                        if (weight < 0) throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
                        if (distance < wEntry.distance) {
                            wEntry.distance = distance;
                            wEntry.predecessor = v;
                            pq.decrease(w, distance);
                        }
                    };
                    g.nodes().forEach(function(v) {
                        var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
                        results[v] = {
                            distance: distance
                        };
                        pq.add(v, distance);
                    });
                    while(pq.size() > 0){
                        v = pq.removeMin();
                        vEntry = results[v];
                        if (vEntry.distance === Number.POSITIVE_INFINITY) break;
                        edgeFn(v).forEach(updateNeighbors);
                    }
                    return results;
                }
            },
            {
                "../data/priority-queue": 45,
                "../lodash": 49
            }, 
        ],
        36: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                var tarjan = require("./tarjan");
                module1.exports = findCycles;
                function findCycles(g) {
                    return _.filter(tarjan(g), function(cmpt) {
                        return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
                    });
                }
            },
            {
                "../lodash": 49,
                "./tarjan": 43
            }, 
        ],
        37: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = floydWarshall;
                var DEFAULT_WEIGHT_FUNC = _.constant(1);
                function floydWarshall(g, weightFn, edgeFn) {
                    return runFloydWarshall(g, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v) {
                        return g.outEdges(v);
                    });
                }
                function runFloydWarshall(g, weightFn, edgeFn) {
                    var results = {};
                    var nodes = g.nodes();
                    nodes.forEach(function(v) {
                        results[v] = {};
                        results[v][v] = {
                            distance: 0
                        };
                        nodes.forEach(function(w) {
                            if (v !== w) results[v][w] = {
                                distance: Number.POSITIVE_INFINITY
                            };
                        });
                        edgeFn(v).forEach(function(edge) {
                            var w = edge.v === v ? edge.w : edge.v;
                            var d = weightFn(edge);
                            results[v][w] = {
                                distance: d,
                                predecessor: v
                            };
                        });
                    });
                    nodes.forEach(function(k) {
                        var rowK = results[k];
                        nodes.forEach(function(i) {
                            var rowI = results[i];
                            nodes.forEach(function(j) {
                                var ik = rowI[k];
                                var kj = rowK[j];
                                var ij = rowI[j];
                                var altDistance = ik.distance + kj.distance;
                                if (altDistance < ij.distance) {
                                    ij.distance = altDistance;
                                    ij.predecessor = kj.predecessor;
                                }
                            });
                        });
                    });
                    return results;
                }
            },
            {
                "../lodash": 49
            }, 
        ],
        38: [
            function(require, module1, exports) {
                module1.exports = {
                    components: require("./components"),
                    dijkstra: require("./dijkstra"),
                    dijkstraAll: require("./dijkstra-all"),
                    findCycles: require("./find-cycles"),
                    floydWarshall: require("./floyd-warshall"),
                    isAcyclic: require("./is-acyclic"),
                    postorder: require("./postorder"),
                    preorder: require("./preorder"),
                    prim: require("./prim"),
                    tarjan: require("./tarjan"),
                    topsort: require("./topsort")
                };
            },
            {
                "./components": 32,
                "./dijkstra": 35,
                "./dijkstra-all": 34,
                "./find-cycles": 36,
                "./floyd-warshall": 37,
                "./is-acyclic": 39,
                "./postorder": 40,
                "./preorder": 41,
                "./prim": 42,
                "./tarjan": 43,
                "./topsort": 44
            }, 
        ],
        39: [
            function(require, module1, exports) {
                var topsort = require("./topsort");
                module1.exports = isAcyclic;
                function isAcyclic(g) {
                    try {
                        topsort(g);
                    } catch (e) {
                        if (e instanceof topsort.CycleException) return false;
                        throw e;
                    }
                    return true;
                }
            },
            {
                "./topsort": 44
            }, 
        ],
        40: [
            function(require, module1, exports) {
                var dfs = require("./dfs");
                module1.exports = postorder;
                function postorder(g, vs) {
                    return dfs(g, vs, "post");
                }
            },
            {
                "./dfs": 33
            }, 
        ],
        41: [
            function(require, module1, exports) {
                var dfs = require("./dfs");
                module1.exports = preorder;
                function preorder(g, vs) {
                    return dfs(g, vs, "pre");
                }
            },
            {
                "./dfs": 33
            }, 
        ],
        42: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                var Graph = require("../graph");
                var PriorityQueue = require("../data/priority-queue");
                module1.exports = prim;
                function prim(g, weightFunc) {
                    var result = new Graph();
                    var parents = {};
                    var pq = new PriorityQueue();
                    var v;
                    function updateNeighbors(edge) {
                        var w = edge.v === v ? edge.w : edge.v;
                        var pri = pq.priority(w);
                        if (pri !== undefined) {
                            var edgeWeight = weightFunc(edge);
                            if (edgeWeight < pri) {
                                parents[w] = v;
                                pq.decrease(w, edgeWeight);
                            }
                        }
                    }
                    if (g.nodeCount() === 0) return result;
                    _.each(g.nodes(), function(v) {
                        pq.add(v, Number.POSITIVE_INFINITY);
                        result.setNode(v);
                    });
                    // Start from an arbitrary node
                    pq.decrease(g.nodes()[0], 0);
                    var init = false;
                    while(pq.size() > 0){
                        v = pq.removeMin();
                        if (_.has(parents, v)) result.setEdge(v, parents[v]);
                        else if (init) throw new Error("Input graph is not connected: " + g);
                        else init = true;
                        g.nodeEdges(v).forEach(updateNeighbors);
                    }
                    return result;
                }
            },
            {
                "../data/priority-queue": 45,
                "../graph": 46,
                "../lodash": 49
            }, 
        ],
        43: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = tarjan;
                function tarjan(g) {
                    var index = 0;
                    var stack = [];
                    var visited = {}; // node id -> { onStack, lowlink, index }
                    var results = [];
                    function dfs(v) {
                        var entry = visited[v] = {
                            onStack: true,
                            lowlink: index,
                            index: index++
                        };
                        stack.push(v);
                        g.successors(v).forEach(function(w) {
                            if (!_.has(visited, w)) {
                                dfs(w);
                                entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
                            } else if (visited[w].onStack) entry.lowlink = Math.min(entry.lowlink, visited[w].index);
                        });
                        if (entry.lowlink === entry.index) {
                            var cmpt = [];
                            var w;
                            do {
                                w = stack.pop();
                                visited[w].onStack = false;
                                cmpt.push(w);
                            }while (v !== w);
                            results.push(cmpt);
                        }
                    }
                    g.nodes().forEach(function(v) {
                        if (!_.has(visited, v)) dfs(v);
                    });
                    return results;
                }
            },
            {
                "../lodash": 49
            }, 
        ],
        44: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = topsort;
                topsort.CycleException = CycleException;
                function topsort(g) {
                    var visited = {};
                    var stack = {};
                    var results = [];
                    function visit(node) {
                        if (_.has(stack, node)) throw new CycleException();
                        if (!_.has(visited, node)) {
                            stack[node] = true;
                            visited[node] = true;
                            _.each(g.predecessors(node), visit);
                            delete stack[node];
                            results.push(node);
                        }
                    }
                    _.each(g.sinks(), visit);
                    if (_.size(visited) !== g.nodeCount()) throw new CycleException();
                    return results;
                }
                function CycleException() {}
                CycleException.prototype = new Error(); // must be an instance of Error to pass testing
            },
            {
                "../lodash": 49
            }, 
        ],
        45: [
            function(require, module1, exports) {
                var _ = require("../lodash");
                module1.exports = PriorityQueue;
                /**
                     * A min-priority queue data structure. This algorithm is derived from Cormen,
                     * et al., "Introduction to Algorithms". The basic idea of a min-priority
                     * queue is that you can efficiently (in O(1) time) get the smallest key in
                     * the queue. Adding and removing elements takes O(log n) time. A key can
                     * have its priority decreased in O(log n) time.
                     */ function PriorityQueue() {
                    this._arr = [];
                    this._keyIndices = {};
                }
                /**
                     * Returns the number of elements in the queue. Takes `O(1)` time.
                     */ PriorityQueue.prototype.size = function() {
                    return this._arr.length;
                };
                /**
                     * Returns the keys that are in the queue. Takes `O(n)` time.
                     */ PriorityQueue.prototype.keys = function() {
                    return this._arr.map(function(x) {
                        return x.key;
                    });
                };
                /**
                     * Returns `true` if **key** is in the queue and `false` if not.
                     */ PriorityQueue.prototype.has = function(key) {
                    return _.has(this._keyIndices, key);
                };
                /**
                     * Returns the priority for **key**. If **key** is not present in the queue
                     * then this function returns `undefined`. Takes `O(1)` time.
                     *
                     * @param {Object} key
                     */ PriorityQueue.prototype.priority = function(key) {
                    var index = this._keyIndices[key];
                    if (index !== undefined) return this._arr[index].priority;
                };
                /**
                     * Returns the key for the minimum element in this queue. If the queue is
                     * empty this function throws an Error. Takes `O(1)` time.
                     */ PriorityQueue.prototype.min = function() {
                    if (this.size() === 0) throw new Error("Queue underflow");
                    return this._arr[0].key;
                };
                /**
                     * Inserts a new key into the priority queue. If the key already exists in
                     * the queue this function returns `false`; otherwise it will return `true`.
                     * Takes `O(n)` time.
                     *
                     * @param {Object} key the key to add
                     * @param {Number} priority the initial priority for the key
                     */ PriorityQueue.prototype.add = function(key, priority) {
                    var keyIndices = this._keyIndices;
                    key = String(key);
                    if (!_.has(keyIndices, key)) {
                        var arr = this._arr;
                        var index = arr.length;
                        keyIndices[key] = index;
                        arr.push({
                            key: key,
                            priority: priority
                        });
                        this._decrease(index);
                        return true;
                    }
                    return false;
                };
                /**
                     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
                     */ PriorityQueue.prototype.removeMin = function() {
                    this._swap(0, this._arr.length - 1);
                    var min = this._arr.pop();
                    delete this._keyIndices[min.key];
                    this._heapify(0);
                    return min.key;
                };
                /**
                     * Decreases the priority for **key** to **priority**. If the new priority is
                     * greater than the previous priority, this function will throw an Error.
                     *
                     * @param {Object} key the key for which to raise priority
                     * @param {Number} priority the new priority for the key
                     */ PriorityQueue.prototype.decrease = function(key, priority) {
                    var index = this._keyIndices[key];
                    if (priority > this._arr[index].priority) throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
                    this._arr[index].priority = priority;
                    this._decrease(index);
                };
                PriorityQueue.prototype._heapify = function(i) {
                    var arr = this._arr;
                    var l = 2 * i;
                    var r = l + 1;
                    var largest = i;
                    if (l < arr.length) {
                        largest = arr[l].priority < arr[largest].priority ? l : largest;
                        if (r < arr.length) largest = arr[r].priority < arr[largest].priority ? r : largest;
                        if (largest !== i) {
                            this._swap(i, largest);
                            this._heapify(largest);
                        }
                    }
                };
                PriorityQueue.prototype._decrease = function(index) {
                    var arr = this._arr;
                    var priority = arr[index].priority;
                    var parent;
                    while(index !== 0){
                        parent = index >> 1;
                        if (arr[parent].priority < priority) break;
                        this._swap(index, parent);
                        index = parent;
                    }
                };
                PriorityQueue.prototype._swap = function(i, j) {
                    var arr = this._arr;
                    var keyIndices = this._keyIndices;
                    var origArrI = arr[i];
                    var origArrJ = arr[j];
                    arr[i] = origArrJ;
                    arr[j] = origArrI;
                    keyIndices[origArrJ.key] = i;
                    keyIndices[origArrI.key] = j;
                };
            },
            {
                "../lodash": 49
            }, 
        ],
        46: [
            function(require, module1, exports) {
                "use strict";
                var _ = require("./lodash");
                module1.exports = Graph;
                var DEFAULT_EDGE_NAME = "\0";
                var GRAPH_NODE = "\0";
                var EDGE_KEY_DELIM = "\x01";
                // Implementation notes:
                //
                //  * Node id query functions should return string ids for the nodes
                //  * Edge id query functions should return an "edgeObj", edge object, that is
                //    composed of enough information to uniquely identify an edge: {v, w, name}.
                //  * Internally we use an "edgeId", a stringified form of the edgeObj, to
                //    reference edges. This is because we need a performant way to look these
                //    edges up and, object properties, which have string keys, are the closest
                //    we're going to get to a performant hashtable in JavaScript.
                function Graph(opts) {
                    this._isDirected = _.has(opts, "directed") ? opts.directed : true;
                    this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
                    this._isCompound = _.has(opts, "compound") ? opts.compound : false;
                    // Label for the graph itself
                    this._label = undefined;
                    // Defaults to be set when creating a new node
                    this._defaultNodeLabelFn = _.constant(undefined);
                    // Defaults to be set when creating a new edge
                    this._defaultEdgeLabelFn = _.constant(undefined);
                    // v -> label
                    this._nodes = {};
                    if (this._isCompound) {
                        // v -> parent
                        this._parent = {};
                        // v -> children
                        this._children = {};
                        this._children[GRAPH_NODE] = {};
                    }
                    // v -> edgeObj
                    this._in = {};
                    // u -> v -> Number
                    this._preds = {};
                    // v -> edgeObj
                    this._out = {};
                    // v -> w -> Number
                    this._sucs = {};
                    // e -> edgeObj
                    this._edgeObjs = {};
                    // e -> label
                    this._edgeLabels = {};
                }
                /* Number of nodes in the graph. Should only be changed by the implementation. */ Graph.prototype._nodeCount = 0;
                /* Number of edges in the graph. Should only be changed by the implementation. */ Graph.prototype._edgeCount = 0;
                /* === Graph functions ========= */ Graph.prototype.isDirected = function() {
                    return this._isDirected;
                };
                Graph.prototype.isMultigraph = function() {
                    return this._isMultigraph;
                };
                Graph.prototype.isCompound = function() {
                    return this._isCompound;
                };
                Graph.prototype.setGraph = function(label) {
                    this._label = label;
                    return this;
                };
                Graph.prototype.graph = function() {
                    return this._label;
                };
                /* === Node functions ========== */ Graph.prototype.setDefaultNodeLabel = function(newDefault) {
                    if (!_.isFunction(newDefault)) newDefault = _.constant(newDefault);
                    this._defaultNodeLabelFn = newDefault;
                    return this;
                };
                Graph.prototype.nodeCount = function() {
                    return this._nodeCount;
                };
                Graph.prototype.nodes = function() {
                    return _.keys(this._nodes);
                };
                Graph.prototype.sources = function() {
                    var self1 = this;
                    return _.filter(this.nodes(), function(v) {
                        return _.isEmpty(self1._in[v]);
                    });
                };
                Graph.prototype.sinks = function() {
                    var self1 = this;
                    return _.filter(this.nodes(), function(v) {
                        return _.isEmpty(self1._out[v]);
                    });
                };
                Graph.prototype.setNodes = function(vs, value) {
                    var args = arguments;
                    var self1 = this;
                    _.each(vs, function(v) {
                        if (args.length > 1) self1.setNode(v, value);
                        else self1.setNode(v);
                    });
                    return this;
                };
                Graph.prototype.setNode = function(v, value) {
                    if (_.has(this._nodes, v)) {
                        if (arguments.length > 1) this._nodes[v] = value;
                        return this;
                    }
                    this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
                    if (this._isCompound) {
                        this._parent[v] = GRAPH_NODE;
                        this._children[v] = {};
                        this._children[GRAPH_NODE][v] = true;
                    }
                    this._in[v] = {};
                    this._preds[v] = {};
                    this._out[v] = {};
                    this._sucs[v] = {};
                    ++this._nodeCount;
                    return this;
                };
                Graph.prototype.node = function(v) {
                    return this._nodes[v];
                };
                Graph.prototype.hasNode = function(v) {
                    return _.has(this._nodes, v);
                };
                Graph.prototype.removeNode = function(v) {
                    var self1 = this;
                    if (_.has(this._nodes, v)) {
                        var removeEdge = function(e) {
                            self1.removeEdge(self1._edgeObjs[e]);
                        };
                        delete this._nodes[v];
                        if (this._isCompound) {
                            this._removeFromParentsChildList(v);
                            delete this._parent[v];
                            _.each(this.children(v), function(child) {
                                self1.setParent(child);
                            });
                            delete this._children[v];
                        }
                        _.each(_.keys(this._in[v]), removeEdge);
                        delete this._in[v];
                        delete this._preds[v];
                        _.each(_.keys(this._out[v]), removeEdge);
                        delete this._out[v];
                        delete this._sucs[v];
                        --this._nodeCount;
                    }
                    return this;
                };
                Graph.prototype.setParent = function(v, parent) {
                    if (!this._isCompound) throw new Error("Cannot set parent in a non-compound graph");
                    if (_.isUndefined(parent)) parent = GRAPH_NODE;
                    else {
                        // Coerce parent to string
                        parent += "";
                        for(var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)){
                            if (ancestor === v) throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
                        }
                        this.setNode(parent);
                    }
                    this.setNode(v);
                    this._removeFromParentsChildList(v);
                    this._parent[v] = parent;
                    this._children[parent][v] = true;
                    return this;
                };
                Graph.prototype._removeFromParentsChildList = function(v) {
                    delete this._children[this._parent[v]][v];
                };
                Graph.prototype.parent = function(v) {
                    if (this._isCompound) {
                        var parent = this._parent[v];
                        if (parent !== GRAPH_NODE) return parent;
                    }
                };
                Graph.prototype.children = function(v) {
                    if (_.isUndefined(v)) v = GRAPH_NODE;
                    if (this._isCompound) {
                        var children = this._children[v];
                        if (children) return _.keys(children);
                    } else if (v === GRAPH_NODE) return this.nodes();
                    else if (this.hasNode(v)) return [];
                };
                Graph.prototype.predecessors = function(v) {
                    var predsV = this._preds[v];
                    if (predsV) return _.keys(predsV);
                };
                Graph.prototype.successors = function(v) {
                    var sucsV = this._sucs[v];
                    if (sucsV) return _.keys(sucsV);
                };
                Graph.prototype.neighbors = function(v) {
                    var preds = this.predecessors(v);
                    if (preds) return _.union(preds, this.successors(v));
                };
                Graph.prototype.isLeaf = function(v) {
                    var neighbors;
                    if (this.isDirected()) neighbors = this.successors(v);
                    else neighbors = this.neighbors(v);
                    return neighbors.length === 0;
                };
                Graph.prototype.filterNodes = function(filter) {
                    var copy = new this.constructor({
                        directed: this._isDirected,
                        multigraph: this._isMultigraph,
                        compound: this._isCompound
                    });
                    copy.setGraph(this.graph());
                    var self1 = this;
                    _.each(this._nodes, function(value, v) {
                        if (filter(v)) copy.setNode(v, value);
                    });
                    _.each(this._edgeObjs, function(e) {
                        if (copy.hasNode(e.v) && copy.hasNode(e.w)) copy.setEdge(e, self1.edge(e));
                    });
                    var parents = {};
                    function findParent(v) {
                        var parent = self1.parent(v);
                        if (parent === undefined || copy.hasNode(parent)) {
                            parents[v] = parent;
                            return parent;
                        } else if (parent in parents) return parents[parent];
                        else return findParent(parent);
                    }
                    if (this._isCompound) _.each(copy.nodes(), function(v) {
                        copy.setParent(v, findParent(v));
                    });
                    return copy;
                };
                /* === Edge functions ========== */ Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
                    if (!_.isFunction(newDefault)) newDefault = _.constant(newDefault);
                    this._defaultEdgeLabelFn = newDefault;
                    return this;
                };
                Graph.prototype.edgeCount = function() {
                    return this._edgeCount;
                };
                Graph.prototype.edges = function() {
                    return _.values(this._edgeObjs);
                };
                Graph.prototype.setPath = function(vs, value) {
                    var self1 = this;
                    var args = arguments;
                    _.reduce(vs, function(v, w) {
                        if (args.length > 1) self1.setEdge(v, w, value);
                        else self1.setEdge(v, w);
                        return w;
                    });
                    return this;
                };
                /*
                     * setEdge(v, w, [value, [name]])
                     * setEdge({ v, w, [name] }, [value])
                     */ Graph.prototype.setEdge = function() {
                    var v, w, name, value;
                    var valueSpecified = false;
                    var arg0 = arguments[0];
                    if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
                        v = arg0.v;
                        w = arg0.w;
                        name = arg0.name;
                        if (arguments.length === 2) {
                            value = arguments[1];
                            valueSpecified = true;
                        }
                    } else {
                        v = arg0;
                        w = arguments[1];
                        name = arguments[3];
                        if (arguments.length > 2) {
                            value = arguments[2];
                            valueSpecified = true;
                        }
                    }
                    v = "" + v;
                    w = "" + w;
                    if (!_.isUndefined(name)) name = "" + name;
                    var e = edgeArgsToId(this._isDirected, v, w, name);
                    if (_.has(this._edgeLabels, e)) {
                        if (valueSpecified) this._edgeLabels[e] = value;
                        return this;
                    }
                    if (!_.isUndefined(name) && !this._isMultigraph) throw new Error("Cannot set a named edge when isMultigraph = false");
                    // It didn't exist, so we need to create it.
                    // First ensure the nodes exist.
                    this.setNode(v);
                    this.setNode(w);
                    this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
                    var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
                    // Ensure we add undirected edges in a consistent way.
                    v = edgeObj.v;
                    w = edgeObj.w;
                    Object.freeze(edgeObj);
                    this._edgeObjs[e] = edgeObj;
                    incrementOrInitEntry(this._preds[w], v);
                    incrementOrInitEntry(this._sucs[v], w);
                    this._in[w][e] = edgeObj;
                    this._out[v][e] = edgeObj;
                    this._edgeCount++;
                    return this;
                };
                Graph.prototype.edge = function(v, w, name) {
                    var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
                    return this._edgeLabels[e];
                };
                Graph.prototype.hasEdge = function(v, w, name) {
                    var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
                    return _.has(this._edgeLabels, e);
                };
                Graph.prototype.removeEdge = function(v, w, name) {
                    var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
                    var edge = this._edgeObjs[e];
                    if (edge) {
                        v = edge.v;
                        w = edge.w;
                        delete this._edgeLabels[e];
                        delete this._edgeObjs[e];
                        decrementOrRemoveEntry(this._preds[w], v);
                        decrementOrRemoveEntry(this._sucs[v], w);
                        delete this._in[w][e];
                        delete this._out[v][e];
                        this._edgeCount--;
                    }
                    return this;
                };
                Graph.prototype.inEdges = function(v, u) {
                    var inV = this._in[v];
                    if (inV) {
                        var edges = _.values(inV);
                        if (!u) return edges;
                        return _.filter(edges, function(edge) {
                            return edge.v === u;
                        });
                    }
                };
                Graph.prototype.outEdges = function(v, w) {
                    var outV = this._out[v];
                    if (outV) {
                        var edges = _.values(outV);
                        if (!w) return edges;
                        return _.filter(edges, function(edge) {
                            return edge.w === w;
                        });
                    }
                };
                Graph.prototype.nodeEdges = function(v, w) {
                    var inEdges = this.inEdges(v, w);
                    if (inEdges) return inEdges.concat(this.outEdges(v, w));
                };
                function incrementOrInitEntry(map, k) {
                    if (map[k]) map[k]++;
                    else map[k] = 1;
                }
                function decrementOrRemoveEntry(map, k) {
                    if (!--map[k]) delete map[k];
                }
                function edgeArgsToId(isDirected, v_, w_, name) {
                    var v = "" + v_;
                    var w = "" + w_;
                    if (!isDirected && v > w) {
                        var tmp = v;
                        v = w;
                        w = tmp;
                    }
                    return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
                }
                function edgeArgsToObj(isDirected, v_, w_, name) {
                    var v = "" + v_;
                    var w = "" + w_;
                    if (!isDirected && v > w) {
                        var tmp = v;
                        v = w;
                        w = tmp;
                    }
                    var edgeObj = {
                        v: v,
                        w: w
                    };
                    if (name) edgeObj.name = name;
                    return edgeObj;
                }
                function edgeObjToId(isDirected, edgeObj) {
                    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
                }
            },
            {
                "./lodash": 49
            }, 
        ],
        47: [
            function(require, module1, exports) {
                // Includes only the "core" of graphlib
                module1.exports = {
                    Graph: require("./graph"),
                    version: require("./version")
                };
            },
            {
                "./graph": 46,
                "./version": 50
            }, 
        ],
        48: [
            function(require, module1, exports) {
                var _ = require("./lodash");
                var Graph = require("./graph");
                module1.exports = {
                    write: write,
                    read: read
                };
                function write(g) {
                    var json = {
                        options: {
                            directed: g.isDirected(),
                            multigraph: g.isMultigraph(),
                            compound: g.isCompound()
                        },
                        nodes: writeNodes(g),
                        edges: writeEdges(g)
                    };
                    if (!_.isUndefined(g.graph())) json.value = _.clone(g.graph());
                    return json;
                }
                function writeNodes(g) {
                    return _.map(g.nodes(), function(v) {
                        var nodeValue = g.node(v);
                        var parent = g.parent(v);
                        var node = {
                            v: v
                        };
                        if (!_.isUndefined(nodeValue)) node.value = nodeValue;
                        if (!_.isUndefined(parent)) node.parent = parent;
                        return node;
                    });
                }
                function writeEdges(g) {
                    return _.map(g.edges(), function(e) {
                        var edgeValue = g.edge(e);
                        var edge = {
                            v: e.v,
                            w: e.w
                        };
                        if (!_.isUndefined(e.name)) edge.name = e.name;
                        if (!_.isUndefined(edgeValue)) edge.value = edgeValue;
                        return edge;
                    });
                }
                function read(json) {
                    var g = new Graph(json.options).setGraph(json.value);
                    _.each(json.nodes, function(entry) {
                        g.setNode(entry.v, entry.value);
                        if (entry.parent) g.setParent(entry.v, entry.parent);
                    });
                    _.each(json.edges, function(entry) {
                        g.setEdge({
                            v: entry.v,
                            w: entry.w,
                            name: entry.name
                        }, entry.value);
                    });
                    return g;
                }
            },
            {
                "./graph": 46,
                "./lodash": 49
            }, 
        ],
        49: [
            function(require, module1, exports) {
                /* global window */ var lodash;
                if (typeof require === "function") try {
                    lodash = {
                        clone: require("lodash/clone"),
                        constant: require("lodash/constant"),
                        each: require("lodash/each"),
                        filter: require("lodash/filter"),
                        has: require("lodash/has"),
                        isArray: require("lodash/isArray"),
                        isEmpty: require("lodash/isEmpty"),
                        isFunction: require("lodash/isFunction"),
                        isUndefined: require("lodash/isUndefined"),
                        keys: require("lodash/keys"),
                        map: require("lodash/map"),
                        reduce: require("lodash/reduce"),
                        size: require("lodash/size"),
                        transform: require("lodash/transform"),
                        union: require("lodash/union"),
                        values: require("lodash/values")
                    };
                } catch (e) {
                // continue regardless of error
                }
                if (!lodash) lodash = window._;
                module1.exports = lodash;
            },
            {
                "lodash/clone": 226,
                "lodash/constant": 228,
                "lodash/each": 230,
                "lodash/filter": 232,
                "lodash/has": 239,
                "lodash/isArray": 243,
                "lodash/isEmpty": 247,
                "lodash/isFunction": 248,
                "lodash/isUndefined": 258,
                "lodash/keys": 259,
                "lodash/map": 262,
                "lodash/reduce": 274,
                "lodash/size": 275,
                "lodash/transform": 284,
                "lodash/union": 285,
                "lodash/values": 287
            }, 
        ],
        50: [
            function(require, module1, exports) {
                module1.exports = "2.1.8";
            },
            {}, 
        ],
        51: [
            function(require, module1, exports) {
                var getNative = require("./_getNative"), root = require("./_root");
                /* Built-in method references that are verified to be native. */ var DataView = getNative(root, "DataView");
                module1.exports = DataView;
            },
            {
                "./_getNative": 163,
                "./_root": 208
            }, 
        ],
        52: [
            function(require, module1, exports) {
                var hashClear = require("./_hashClear"), hashDelete = require("./_hashDelete"), hashGet = require("./_hashGet"), hashHas = require("./_hashHas"), hashSet = require("./_hashSet");
                /**
                     * Creates a hash object.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */ function Hash(entries) {
                    var index = -1, length = entries == null ? 0 : entries.length;
                    this.clear();
                    while(++index < length){
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }
                // Add methods to `Hash`.
                Hash.prototype.clear = hashClear;
                Hash.prototype["delete"] = hashDelete;
                Hash.prototype.get = hashGet;
                Hash.prototype.has = hashHas;
                Hash.prototype.set = hashSet;
                module1.exports = Hash;
            },
            {
                "./_hashClear": 172,
                "./_hashDelete": 173,
                "./_hashGet": 174,
                "./_hashHas": 175,
                "./_hashSet": 176
            }, 
        ],
        53: [
            function(require, module1, exports) {
                var listCacheClear = require("./_listCacheClear"), listCacheDelete = require("./_listCacheDelete"), listCacheGet = require("./_listCacheGet"), listCacheHas = require("./_listCacheHas"), listCacheSet = require("./_listCacheSet");
                /**
                     * Creates an list cache object.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */ function ListCache(entries) {
                    var index = -1, length = entries == null ? 0 : entries.length;
                    this.clear();
                    while(++index < length){
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }
                // Add methods to `ListCache`.
                ListCache.prototype.clear = listCacheClear;
                ListCache.prototype["delete"] = listCacheDelete;
                ListCache.prototype.get = listCacheGet;
                ListCache.prototype.has = listCacheHas;
                ListCache.prototype.set = listCacheSet;
                module1.exports = ListCache;
            },
            {
                "./_listCacheClear": 188,
                "./_listCacheDelete": 189,
                "./_listCacheGet": 190,
                "./_listCacheHas": 191,
                "./_listCacheSet": 192
            }, 
        ],
        54: [
            function(require, module1, exports) {
                var getNative = require("./_getNative"), root = require("./_root");
                /* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map");
                module1.exports = Map;
            },
            {
                "./_getNative": 163,
                "./_root": 208
            }, 
        ],
        55: [
            function(require, module1, exports) {
                var mapCacheClear = require("./_mapCacheClear"), mapCacheDelete = require("./_mapCacheDelete"), mapCacheGet = require("./_mapCacheGet"), mapCacheHas = require("./_mapCacheHas"), mapCacheSet = require("./_mapCacheSet");
                /**
                     * Creates a map cache object to store key-value pairs.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */ function MapCache(entries) {
                    var index = -1, length = entries == null ? 0 : entries.length;
                    this.clear();
                    while(++index < length){
                        var entry = entries[index];
                        this.set(entry[0], entry[1]);
                    }
                }
                // Add methods to `MapCache`.
                MapCache.prototype.clear = mapCacheClear;
                MapCache.prototype["delete"] = mapCacheDelete;
                MapCache.prototype.get = mapCacheGet;
                MapCache.prototype.has = mapCacheHas;
                MapCache.prototype.set = mapCacheSet;
                module1.exports = MapCache;
            },
            {
                "./_mapCacheClear": 193,
                "./_mapCacheDelete": 194,
                "./_mapCacheGet": 195,
                "./_mapCacheHas": 196,
                "./_mapCacheSet": 197
            }, 
        ],
        56: [
            function(require, module1, exports) {
                var getNative = require("./_getNative"), root = require("./_root");
                /* Built-in method references that are verified to be native. */ var Promise = getNative(root, "Promise");
                module1.exports = Promise;
            },
            {
                "./_getNative": 163,
                "./_root": 208
            }, 
        ],
        57: [
            function(require, module1, exports) {
                var getNative = require("./_getNative"), root = require("./_root");
                /* Built-in method references that are verified to be native. */ var Set = getNative(root, "Set");
                module1.exports = Set;
            },
            {
                "./_getNative": 163,
                "./_root": 208
            }, 
        ],
        58: [
            function(require, module1, exports) {
                var MapCache = require("./_MapCache"), setCacheAdd = require("./_setCacheAdd"), setCacheHas = require("./_setCacheHas");
                /**
                     *
                     * Creates an array cache object to store unique values.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [values] The values to cache.
                     */ function SetCache(values) {
                    var index = -1, length = values == null ? 0 : values.length;
                    this.__data__ = new MapCache();
                    while(++index < length)this.add(values[index]);
                }
                // Add methods to `SetCache`.
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                SetCache.prototype.has = setCacheHas;
                module1.exports = SetCache;
            },
            {
                "./_MapCache": 55,
                "./_setCacheAdd": 210,
                "./_setCacheHas": 211
            }, 
        ],
        59: [
            function(require, module1, exports) {
                var ListCache = require("./_ListCache"), stackClear = require("./_stackClear"), stackDelete = require("./_stackDelete"), stackGet = require("./_stackGet"), stackHas = require("./_stackHas"), stackSet = require("./_stackSet");
                /**
                     * Creates a stack cache object to store key-value pairs.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */ function Stack(entries) {
                    var data = this.__data__ = new ListCache(entries);
                    this.size = data.size;
                }
                // Add methods to `Stack`.
                Stack.prototype.clear = stackClear;
                Stack.prototype["delete"] = stackDelete;
                Stack.prototype.get = stackGet;
                Stack.prototype.has = stackHas;
                Stack.prototype.set = stackSet;
                module1.exports = Stack;
            },
            {
                "./_ListCache": 53,
                "./_stackClear": 215,
                "./_stackDelete": 216,
                "./_stackGet": 217,
                "./_stackHas": 218,
                "./_stackSet": 219
            }, 
        ],
        60: [
            function(require, module1, exports) {
                var root = require("./_root");
                /** Built-in value references. */ var Symbol = root.Symbol;
                module1.exports = Symbol;
            },
            {
                "./_root": 208
            }, 
        ],
        61: [
            function(require, module1, exports) {
                var root = require("./_root");
                /** Built-in value references. */ var Uint8Array = root.Uint8Array;
                module1.exports = Uint8Array;
            },
            {
                "./_root": 208
            }, 
        ],
        62: [
            function(require, module1, exports) {
                var getNative = require("./_getNative"), root = require("./_root");
                /* Built-in method references that are verified to be native. */ var WeakMap = getNative(root, "WeakMap");
                module1.exports = WeakMap;
            },
            {
                "./_getNative": 163,
                "./_root": 208
            }, 
        ],
        63: [
            function(require, module1, exports) {
                /**
                     * A faster alternative to `Function#apply`, this function invokes `func`
                     * with the `this` binding of `thisArg` and the arguments of `args`.
                     *
                     * @private
                     * @param {Function} func The function to invoke.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} args The arguments to invoke `func` with.
                     * @returns {*} Returns the result of `func`.
                     */ function apply(func, thisArg, args) {
                    switch(args.length){
                        case 0:
                            return func.call(thisArg);
                        case 1:
                            return func.call(thisArg, args[0]);
                        case 2:
                            return func.call(thisArg, args[0], args[1]);
                        case 3:
                            return func.call(thisArg, args[0], args[1], args[2]);
                    }
                    return func.apply(thisArg, args);
                }
                module1.exports = apply;
            },
            {}, 
        ],
        64: [
            function(require, module1, exports) {
                /**
                     * A specialized version of `_.forEach` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */ function arrayEach(array, iteratee) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        if (iteratee(array[index], index, array) === false) break;
                    }
                    return array;
                }
                module1.exports = arrayEach;
            },
            {}, 
        ],
        65: [
            function(require, module1, exports) {
                /**
                     * A specialized version of `_.filter` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */ function arrayFilter(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                    while(++index < length){
                        var value = array[index];
                        if (predicate(value, index, array)) result[resIndex++] = value;
                    }
                    return result;
                }
                module1.exports = arrayFilter;
            },
            {}, 
        ],
        66: [
            function(require, module1, exports) {
                var baseIndexOf = require("./_baseIndexOf");
                /**
                     * A specialized version of `_.includes` for arrays without support for
                     * specifying an index to search from.
                     *
                     * @private
                     * @param {Array} [array] The array to inspect.
                     * @param {*} target The value to search for.
                     * @returns {boolean} Returns `true` if `target` is found, else `false`.
                     */ function arrayIncludes(array, value) {
                    var length = array == null ? 0 : array.length;
                    return !!length && baseIndexOf(array, value, 0) > -1;
                }
                module1.exports = arrayIncludes;
            },
            {
                "./_baseIndexOf": 95
            }, 
        ],
        67: [
            function(require, module1, exports) {
                /**
                     * This function is like `arrayIncludes` except that it accepts a comparator.
                     *
                     * @private
                     * @param {Array} [array] The array to inspect.
                     * @param {*} target The value to search for.
                     * @param {Function} comparator The comparator invoked per element.
                     * @returns {boolean} Returns `true` if `target` is found, else `false`.
                     */ function arrayIncludesWith(array, value, comparator) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        if (comparator(value, array[index])) return true;
                    }
                    return false;
                }
                module1.exports = arrayIncludesWith;
            },
            {}, 
        ],
        68: [
            function(require, module1, exports) {
                var baseTimes = require("./_baseTimes"), isArguments = require("./isArguments"), isArray = require("./isArray"), isBuffer = require("./isBuffer"), isIndex = require("./_isIndex"), isTypedArray = require("./isTypedArray");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Creates an array of the enumerable property names of the array-like `value`.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @param {boolean} inherited Specify returning inherited property names.
                     * @returns {Array} Returns the array of property names.
                     */ function arrayLikeKeys(value, inherited) {
                    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                    isIndex(key, length)))) result.push(key);
                    return result;
                }
                module1.exports = arrayLikeKeys;
            },
            {
                "./_baseTimes": 125,
                "./_isIndex": 181,
                "./isArguments": 242,
                "./isArray": 243,
                "./isBuffer": 246,
                "./isTypedArray": 257
            }, 
        ],
        69: [
            function(require, module1, exports) {
                /**
                     * A specialized version of `_.map` for arrays without support for iteratee
                     * shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */ function arrayMap(array, iteratee) {
                    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                    while(++index < length)result[index] = iteratee(array[index], index, array);
                    return result;
                }
                module1.exports = arrayMap;
            },
            {}, 
        ],
        70: [
            function(require, module1, exports) {
                /**
                     * Appends the elements of `values` to `array`.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {Array} values The values to append.
                     * @returns {Array} Returns `array`.
                     */ function arrayPush(array, values) {
                    var index = -1, length = values.length, offset = array.length;
                    while(++index < length)array[offset + index] = values[index];
                    return array;
                }
                module1.exports = arrayPush;
            },
            {}, 
        ],
        71: [
            function(require, module1, exports) {
                /**
                     * A specialized version of `_.reduce` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initAccum] Specify using the first element of `array` as
                     *  the initial value.
                     * @returns {*} Returns the accumulated value.
                     */ function arrayReduce(array, iteratee, accumulator, initAccum) {
                    var index = -1, length = array == null ? 0 : array.length;
                    if (initAccum && length) accumulator = array[++index];
                    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
                    return accumulator;
                }
                module1.exports = arrayReduce;
            },
            {}, 
        ],
        72: [
            function(require, module1, exports) {
                /**
                     * A specialized version of `_.some` for arrays without support for iteratee
                     * shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */ function arraySome(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        if (predicate(array[index], index, array)) return true;
                    }
                    return false;
                }
                module1.exports = arraySome;
            },
            {}, 
        ],
        73: [
            function(require, module1, exports) {
                var baseProperty = require("./_baseProperty");
                /**
                     * Gets the size of an ASCII `string`.
                     *
                     * @private
                     * @param {string} string The string inspect.
                     * @returns {number} Returns the string size.
                     */ var asciiSize = baseProperty("length");
                module1.exports = asciiSize;
            },
            {
                "./_baseProperty": 117
            }, 
        ],
        74: [
            function(require, module1, exports) {
                var baseAssignValue = require("./_baseAssignValue"), eq = require("./eq");
                /**
                     * This function is like `assignValue` except that it doesn't assign
                     * `undefined` values.
                     *
                     * @private
                     * @param {Object} object The object to modify.
                     * @param {string} key The key of the property to assign.
                     * @param {*} value The value to assign.
                     */ function assignMergeValue(object, key, value) {
                    if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) baseAssignValue(object, key, value);
                }
                module1.exports = assignMergeValue;
            },
            {
                "./_baseAssignValue": 79,
                "./eq": 231
            }, 
        ],
        75: [
            function(require, module1, exports) {
                var baseAssignValue = require("./_baseAssignValue"), eq = require("./eq");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Assigns `value` to `key` of `object` if the existing value is not equivalent
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @private
                     * @param {Object} object The object to modify.
                     * @param {string} key The key of the property to assign.
                     * @param {*} value The value to assign.
                     */ function assignValue(object, key, value) {
                    var objValue = object[key];
                    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) baseAssignValue(object, key, value);
                }
                module1.exports = assignValue;
            },
            {
                "./_baseAssignValue": 79,
                "./eq": 231
            }, 
        ],
        76: [
            function(require, module1, exports) {
                var eq = require("./eq");
                /**
                     * Gets the index at which the `key` is found in `array` of key-value pairs.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} key The key to search for.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */ function assocIndexOf(array, key) {
                    var length = array.length;
                    while(length--){
                        if (eq(array[length][0], key)) return length;
                    }
                    return -1;
                }
                module1.exports = assocIndexOf;
            },
            {
                "./eq": 231
            }, 
        ],
        77: [
            function(require, module1, exports) {
                var copyObject = require("./_copyObject"), keys = require("./keys");
                /**
                     * The base implementation of `_.assign` without support for multiple sources
                     * or `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @returns {Object} Returns `object`.
                     */ function baseAssign(object, source) {
                    return object && copyObject(source, keys(source), object);
                }
                module1.exports = baseAssign;
            },
            {
                "./_copyObject": 143,
                "./keys": 259
            }, 
        ],
        78: [
            function(require, module1, exports) {
                var copyObject = require("./_copyObject"), keysIn1 = require("./keysIn");
                /**
                     * The base implementation of `_.assignIn` without support for multiple sources
                     * or `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @returns {Object} Returns `object`.
                     */ function baseAssignIn(object, source) {
                    return object && copyObject(source, keysIn1(source), object);
                }
                module1.exports = baseAssignIn;
            },
            {
                "./_copyObject": 143,
                "./keysIn": 260
            }, 
        ],
        79: [
            function(require, module1, exports) {
                var defineProperty = require("./_defineProperty");
                /**
                     * The base implementation of `assignValue` and `assignMergeValue` without
                     * value checks.
                     *
                     * @private
                     * @param {Object} object The object to modify.
                     * @param {string} key The key of the property to assign.
                     * @param {*} value The value to assign.
                     */ function baseAssignValue(object, key, value) {
                    if (key == "__proto__" && defineProperty) defineProperty(object, key, {
                        configurable: true,
                        enumerable: true,
                        value: value,
                        writable: true
                    });
                    else object[key] = value;
                }
                module1.exports = baseAssignValue;
            },
            {
                "./_defineProperty": 153
            }, 
        ],
        80: [
            function(require, module1, exports) {
                var Stack = require("./_Stack"), arrayEach = require("./_arrayEach"), assignValue = require("./_assignValue"), baseAssign = require("./_baseAssign"), baseAssignIn = require("./_baseAssignIn"), cloneBuffer = require("./_cloneBuffer"), copyArray = require("./_copyArray"), copySymbols = require("./_copySymbols"), copySymbolsIn = require("./_copySymbolsIn"), getAllKeys = require("./_getAllKeys"), getAllKeysIn = require("./_getAllKeysIn"), getTag = require("./_getTag"), initCloneArray = require("./_initCloneArray"), initCloneByTag = require("./_initCloneByTag"), initCloneObject = require("./_initCloneObject"), isArray = require("./isArray"), isBuffer = require("./isBuffer"), isMap = require("./isMap"), isObject = require("./isObject"), isSet = require("./isSet"), keys = require("./keys");
                /** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
                /** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
                var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
                /** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
                /**
                     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                     * traversed objects.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} bitmask The bitmask flags.
                     *  1 - Deep clone
                     *  2 - Flatten inherited properties
                     *  4 - Clone symbols
                     * @param {Function} [customizer] The function to customize cloning.
                     * @param {string} [key] The key of `value`.
                     * @param {Object} [object] The parent object of `value`.
                     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                     * @returns {*} Returns the cloned value.
                     */ function baseClone(value, bitmask, customizer, key, object, stack) {
                    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                    if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
                    if (result !== undefined) return result;
                    if (!isObject(value)) return value;
                    var isArr = isArray(value);
                    if (isArr) {
                        result = initCloneArray(value);
                        if (!isDeep) return copyArray(value, result);
                    } else {
                        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                        if (isBuffer(value)) return cloneBuffer(value, isDeep);
                        if (tag == objectTag || tag == argsTag || isFunc && !object) {
                            result = isFlat || isFunc ? {} : initCloneObject(value);
                            if (!isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                        } else {
                            if (!cloneableTags[tag]) return object ? value : {};
                            result = initCloneByTag(value, tag, isDeep);
                        }
                    }
                    // Check for circular references and return its corresponding clone.
                    stack || (stack = new Stack());
                    var stacked = stack.get(value);
                    if (stacked) return stacked;
                    stack.set(value, result);
                    if (isSet(value)) value.forEach(function(subValue) {
                        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                    });
                    else if (isMap(value)) value.forEach(function(subValue, key) {
                        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                    });
                    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                    var props = isArr ? undefined : keysFunc(value);
                    arrayEach(props || value, function(subValue, key) {
                        if (props) {
                            key = subValue;
                            subValue = value[key];
                        }
                        // Recursively populate clone (susceptible to call stack limits).
                        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                    });
                    return result;
                }
                module1.exports = baseClone;
            },
            {
                "./_Stack": 59,
                "./_arrayEach": 64,
                "./_assignValue": 75,
                "./_baseAssign": 77,
                "./_baseAssignIn": 78,
                "./_cloneBuffer": 135,
                "./_copyArray": 142,
                "./_copySymbols": 144,
                "./_copySymbolsIn": 145,
                "./_getAllKeys": 159,
                "./_getAllKeysIn": 160,
                "./_getTag": 168,
                "./_initCloneArray": 177,
                "./_initCloneByTag": 178,
                "./_initCloneObject": 179,
                "./isArray": 243,
                "./isBuffer": 246,
                "./isMap": 250,
                "./isObject": 251,
                "./isSet": 254,
                "./keys": 259
            }, 
        ],
        81: [
            function(require, module1, exports) {
                var isObject = require("./isObject");
                /** Built-in value references. */ var objectCreate = Object.create;
                /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} proto The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */ var baseCreate = function() {
                    function object() {}
                    return function(proto) {
                        if (!isObject(proto)) return {};
                        if (objectCreate) return objectCreate(proto);
                        object.prototype = proto;
                        var result = new object();
                        object.prototype = undefined;
                        return result;
                    };
                }();
                module1.exports = baseCreate;
            },
            {
                "./isObject": 251
            }, 
        ],
        82: [
            function(require, module1, exports) {
                var baseForOwn = require("./_baseForOwn"), createBaseEach = require("./_createBaseEach");
                /**
                     * The base implementation of `_.forEach` without support for iteratee shorthands.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array|Object} Returns `collection`.
                     */ var baseEach = createBaseEach(baseForOwn);
                module1.exports = baseEach;
            },
            {
                "./_baseForOwn": 88,
                "./_createBaseEach": 148
            }, 
        ],
        83: [
            function(require, module1, exports) {
                var isSymbol = require("./isSymbol");
                /**
                     * The base implementation of methods like `_.max` and `_.min` which accepts a
                     * `comparator` to determine the extremum value.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The iteratee invoked per iteration.
                     * @param {Function} comparator The comparator used to compare values.
                     * @returns {*} Returns the extremum value.
                     */ function baseExtremum(array, iteratee, comparator) {
                    var index = -1, length = array.length;
                    while(++index < length){
                        var value = array[index], current = iteratee(value);
                        if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
                    }
                    return result;
                }
                module1.exports = baseExtremum;
            },
            {
                "./isSymbol": 256
            }, 
        ],
        84: [
            function(require, module1, exports) {
                var baseEach = require("./_baseEach");
                /**
                     * The base implementation of `_.filter` without support for iteratee shorthands.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */ function baseFilter(collection, predicate) {
                    var result = [];
                    baseEach(collection, function(value, index, collection) {
                        if (predicate(value, index, collection)) result.push(value);
                    });
                    return result;
                }
                module1.exports = baseFilter;
            },
            {
                "./_baseEach": 82
            }, 
        ],
        85: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.findIndex` and `_.findLastIndex` without
                     * support for iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {number} fromIndex The index to search from.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
                    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                    while(fromRight ? index-- : ++index < length){
                        if (predicate(array[index], index, array)) return index;
                    }
                    return -1;
                }
                module1.exports = baseFindIndex;
            },
            {}, 
        ],
        86: [
            function(require, module1, exports) {
                var arrayPush = require("./_arrayPush"), isFlattenable = require("./_isFlattenable");
                /**
                     * The base implementation of `_.flatten` with support for restricting flattening.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {number} depth The maximum recursion depth.
                     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
                     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
                     * @param {Array} [result=[]] The initial result value.
                     * @returns {Array} Returns the new flattened array.
                     */ function baseFlatten(array, depth, predicate, isStrict, result) {
                    var index = -1, length = array.length;
                    predicate || (predicate = isFlattenable);
                    result || (result = []);
                    while(++index < length){
                        var value = array[index];
                        if (depth > 0 && predicate(value)) {
                            if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
                            baseFlatten(value, depth - 1, predicate, isStrict, result);
                            else arrayPush(result, value);
                        } else if (!isStrict) result[result.length] = value;
                    }
                    return result;
                }
                module1.exports = baseFlatten;
            },
            {
                "./_arrayPush": 70,
                "./_isFlattenable": 180
            }, 
        ],
        87: [
            function(require, module1, exports) {
                var createBaseFor = require("./_createBaseFor");
                /**
                     * The base implementation of `baseForOwn` which iterates over `object`
                     * properties returned by `keysFunc` and invokes `iteratee` for each property.
                     * Iteratee functions may exit iteration early by explicitly returning `false`.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @returns {Object} Returns `object`.
                     */ var baseFor = createBaseFor();
                module1.exports = baseFor;
            },
            {
                "./_createBaseFor": 149
            }, 
        ],
        88: [
            function(require, module1, exports) {
                var baseFor = require("./_baseFor"), keys = require("./keys");
                /**
                     * The base implementation of `_.forOwn` without support for iteratee shorthands.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */ function baseForOwn(object, iteratee) {
                    return object && baseFor(object, iteratee, keys);
                }
                module1.exports = baseForOwn;
            },
            {
                "./_baseFor": 87,
                "./keys": 259
            }, 
        ],
        89: [
            function(require, module1, exports) {
                var castPath = require("./_castPath"), toKey = require("./_toKey");
                /**
                     * The base implementation of `_.get` without support for default values.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to get.
                     * @returns {*} Returns the resolved value.
                     */ function baseGet(object, path) {
                    path = castPath(path, object);
                    var index = 0, length = path.length;
                    while(object != null && index < length)object = object[toKey(path[index++])];
                    return index && index == length ? object : undefined;
                }
                module1.exports = baseGet;
            },
            {
                "./_castPath": 133,
                "./_toKey": 223
            }, 
        ],
        90: [
            function(require, module1, exports) {
                var arrayPush = require("./_arrayPush"), isArray = require("./isArray");
                /**
                     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                     * symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @param {Function} symbolsFunc The function to get the symbols of `object`.
                     * @returns {Array} Returns the array of property names and symbols.
                     */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                    var result = keysFunc(object);
                    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                }
                module1.exports = baseGetAllKeys;
            },
            {
                "./_arrayPush": 70,
                "./isArray": 243
            }, 
        ],
        91: [
            function(require, module1, exports) {
                var Symbol = require("./_Symbol"), getRawTag = require("./_getRawTag"), objectToString = require("./_objectToString");
                /** `Object#toString` result references. */ var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
                /** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
                /**
                     * The base implementation of `getTag` without fallbacks for buggy environments.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @returns {string} Returns the `toStringTag`.
                     */ function baseGetTag(value) {
                    if (value == null) return value === undefined ? undefinedTag : nullTag;
                    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
                }
                module1.exports = baseGetTag;
            },
            {
                "./_Symbol": 60,
                "./_getRawTag": 165,
                "./_objectToString": 205
            }, 
        ],
        92: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.gt` which doesn't coerce arguments.
                     *
                     * @private
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is greater than `other`,
                     *  else `false`.
                     */ function baseGt(value, other) {
                    return value > other;
                }
                module1.exports = baseGt;
            },
            {}, 
        ],
        93: [
            function(require, module1, exports) {
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * The base implementation of `_.has` without support for deep paths.
                     *
                     * @private
                     * @param {Object} [object] The object to query.
                     * @param {Array|string} key The key to check.
                     * @returns {boolean} Returns `true` if `key` exists, else `false`.
                     */ function baseHas(object, key) {
                    return object != null && hasOwnProperty.call(object, key);
                }
                module1.exports = baseHas;
            },
            {}, 
        ],
        94: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.hasIn` without support for deep paths.
                     *
                     * @private
                     * @param {Object} [object] The object to query.
                     * @param {Array|string} key The key to check.
                     * @returns {boolean} Returns `true` if `key` exists, else `false`.
                     */ function baseHasIn(object, key) {
                    return object != null && key in Object(object);
                }
                module1.exports = baseHasIn;
            },
            {}, 
        ],
        95: [
            function(require, module1, exports) {
                var baseFindIndex = require("./_baseFindIndex"), baseIsNaN = require("./_baseIsNaN"), strictIndexOf = require("./_strictIndexOf");
                /**
                     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */ function baseIndexOf(array, value, fromIndex) {
                    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
                }
                module1.exports = baseIndexOf;
            },
            {
                "./_baseFindIndex": 85,
                "./_baseIsNaN": 101,
                "./_strictIndexOf": 220
            }, 
        ],
        96: [
            function(require, module1, exports) {
                var baseGetTag = require("./_baseGetTag"), isObjectLike = require("./isObjectLike");
                /** `Object#toString` result references. */ var argsTag = "[object Arguments]";
                /**
                     * The base implementation of `_.isArguments`.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                     */ function baseIsArguments(value) {
                    return isObjectLike(value) && baseGetTag(value) == argsTag;
                }
                module1.exports = baseIsArguments;
            },
            {
                "./_baseGetTag": 91,
                "./isObjectLike": 252
            }, 
        ],
        97: [
            function(require, module1, exports) {
                var baseIsEqualDeep = require("./_baseIsEqualDeep"), isObjectLike = require("./isObjectLike");
                /**
                     * The base implementation of `_.isEqual` which supports partial comparisons
                     * and tracks traversed objects.
                     *
                     * @private
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @param {boolean} bitmask The bitmask flags.
                     *  1 - Unordered comparison
                     *  2 - Partial comparison
                     * @param {Function} [customizer] The function to customize comparisons.
                     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     */ function baseIsEqual(value, other, bitmask, customizer, stack) {
                    if (value === other) return true;
                    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
                    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                }
                module1.exports = baseIsEqual;
            },
            {
                "./_baseIsEqualDeep": 98,
                "./isObjectLike": 252
            }, 
        ],
        98: [
            function(require, module1, exports) {
                var Stack = require("./_Stack"), equalArrays = require("./_equalArrays"), equalByTag = require("./_equalByTag"), equalObjects = require("./_equalObjects"), getTag = require("./_getTag"), isArray = require("./isArray"), isBuffer = require("./isBuffer"), isTypedArray = require("./isTypedArray");
                /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
                /** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * A specialized version of `baseIsEqual` for arrays and objects which performs
                     * deep comparisons and tracks traversed objects enabling objects with circular
                     * references to be compared.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                     * @param {Function} customizer The function to customize comparisons.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                    objTag = objTag == argsTag ? objectTag : objTag;
                    othTag = othTag == argsTag ? objectTag : othTag;
                    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                    if (isSameTag && isBuffer(object)) {
                        if (!isBuffer(other)) return false;
                        objIsArr = true;
                        objIsObj = false;
                    }
                    if (isSameTag && !objIsObj) {
                        stack || (stack = new Stack());
                        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                    }
                    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                        if (objIsWrapped || othIsWrapped) {
                            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                            stack || (stack = new Stack());
                            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                        }
                    }
                    if (!isSameTag) return false;
                    stack || (stack = new Stack());
                    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                }
                module1.exports = baseIsEqualDeep;
            },
            {
                "./_Stack": 59,
                "./_equalArrays": 154,
                "./_equalByTag": 155,
                "./_equalObjects": 156,
                "./_getTag": 168,
                "./isArray": 243,
                "./isBuffer": 246,
                "./isTypedArray": 257
            }, 
        ],
        99: [
            function(require, module1, exports) {
                var getTag = require("./_getTag"), isObjectLike = require("./isObjectLike");
                /** `Object#toString` result references. */ var mapTag = "[object Map]";
                /**
                     * The base implementation of `_.isMap` without Node.js optimizations.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                     */ function baseIsMap(value) {
                    return isObjectLike(value) && getTag(value) == mapTag;
                }
                module1.exports = baseIsMap;
            },
            {
                "./_getTag": 168,
                "./isObjectLike": 252
            }, 
        ],
        100: [
            function(require, module1, exports) {
                var Stack = require("./_Stack"), baseIsEqual = require("./_baseIsEqual");
                /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                /**
                     * The base implementation of `_.isMatch` without support for iteratee shorthands.
                     *
                     * @private
                     * @param {Object} object The object to inspect.
                     * @param {Object} source The object of property values to match.
                     * @param {Array} matchData The property names, values, and compare flags to match.
                     * @param {Function} [customizer] The function to customize comparisons.
                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                     */ function baseIsMatch(object, source, matchData, customizer) {
                    var index = matchData.length, length = index, noCustomizer = !customizer;
                    if (object == null) return !length;
                    object = Object(object);
                    while(index--){
                        var data = matchData[index];
                        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
                    }
                    while(++index < length){
                        data = matchData[index];
                        var key = data[0], objValue = object[key], srcValue = data[1];
                        if (noCustomizer && data[2]) {
                            if (objValue === undefined && !(key in object)) return false;
                        } else {
                            var stack = new Stack();
                            if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                            if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return false;
                        }
                    }
                    return true;
                }
                module1.exports = baseIsMatch;
            },
            {
                "./_Stack": 59,
                "./_baseIsEqual": 97
            }, 
        ],
        101: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.isNaN` without support for number objects.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                     */ function baseIsNaN(value) {
                    return value !== value;
                }
                module1.exports = baseIsNaN;
            },
            {}, 
        ],
        102: [
            function(require, module1, exports) {
                var isFunction = require("./isFunction"), isMasked = require("./_isMasked"), isObject = require("./isObject"), toSource = require("./_toSource");
                /**
                     * Used to match `RegExp`
                     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                     */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
                /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
                /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                /**
                     * The base implementation of `_.isNative` without bad shim checks.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a native function,
                     *  else `false`.
                     */ function baseIsNative(value) {
                    if (!isObject(value) || isMasked(value)) return false;
                    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                    return pattern.test(toSource(value));
                }
                module1.exports = baseIsNative;
            },
            {
                "./_isMasked": 185,
                "./_toSource": 224,
                "./isFunction": 248,
                "./isObject": 251
            }, 
        ],
        103: [
            function(require, module1, exports) {
                var getTag = require("./_getTag"), isObjectLike = require("./isObjectLike");
                /** `Object#toString` result references. */ var setTag = "[object Set]";
                /**
                     * The base implementation of `_.isSet` without Node.js optimizations.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                     */ function baseIsSet(value) {
                    return isObjectLike(value) && getTag(value) == setTag;
                }
                module1.exports = baseIsSet;
            },
            {
                "./_getTag": 168,
                "./isObjectLike": 252
            }, 
        ],
        104: [
            function(require, module1, exports) {
                var baseGetTag = require("./_baseGetTag"), isLength = require("./isLength"), isObjectLike = require("./isObjectLike");
                /** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
                var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
                /** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
                /**
                     * The base implementation of `_.isTypedArray` without Node.js optimizations.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                     */ function baseIsTypedArray(value) {
                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                }
                module1.exports = baseIsTypedArray;
            },
            {
                "./_baseGetTag": 91,
                "./isLength": 249,
                "./isObjectLike": 252
            }, 
        ],
        105: [
            function(require, module1, exports) {
                var baseMatches = require("./_baseMatches"), baseMatchesProperty = require("./_baseMatchesProperty"), identity = require("./identity"), isArray = require("./isArray"), property = require("./property");
                /**
                     * The base implementation of `_.iteratee`.
                     *
                     * @private
                     * @param {*} [value=_.identity] The value to convert to an iteratee.
                     * @returns {Function} Returns the iteratee.
                     */ function baseIteratee(value) {
                    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                    if (typeof value == "function") return value;
                    if (value == null) return identity;
                    if (typeof value == "object") return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                    return property(value);
                }
                module1.exports = baseIteratee;
            },
            {
                "./_baseMatches": 110,
                "./_baseMatchesProperty": 111,
                "./identity": 241,
                "./isArray": 243,
                "./property": 272
            }, 
        ],
        106: [
            function(require, module1, exports) {
                var isPrototype = require("./_isPrototype"), nativeKeys = require("./_nativeKeys");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */ function baseKeys(object) {
                    if (!isPrototype(object)) return nativeKeys(object);
                    var result = [];
                    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
                    return result;
                }
                module1.exports = baseKeys;
            },
            {
                "./_isPrototype": 186,
                "./_nativeKeys": 202
            }, 
        ],
        107: [
            function(require, module1, exports) {
                var isObject = require("./isObject"), isPrototype = require("./_isPrototype"), nativeKeysIn = require("./_nativeKeysIn");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */ function baseKeysIn(object) {
                    if (!isObject(object)) return nativeKeysIn(object);
                    var isProto = isPrototype(object), result = [];
                    for(var key in object)if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
                    return result;
                }
                module1.exports = baseKeysIn;
            },
            {
                "./_isPrototype": 186,
                "./_nativeKeysIn": 203,
                "./isObject": 251
            }, 
        ],
        108: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.lt` which doesn't coerce arguments.
                     *
                     * @private
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is less than `other`,
                     *  else `false`.
                     */ function baseLt(value, other) {
                    return value < other;
                }
                module1.exports = baseLt;
            },
            {}, 
        ],
        109: [
            function(require, module1, exports) {
                var baseEach = require("./_baseEach"), isArrayLike = require("./isArrayLike");
                /**
                     * The base implementation of `_.map` without support for iteratee shorthands.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */ function baseMap(collection, iteratee) {
                    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                    baseEach(collection, function(value, key, collection) {
                        result[++index] = iteratee(value, key, collection);
                    });
                    return result;
                }
                module1.exports = baseMap;
            },
            {
                "./_baseEach": 82,
                "./isArrayLike": 244
            }, 
        ],
        110: [
            function(require, module1, exports) {
                var baseIsMatch = require("./_baseIsMatch"), getMatchData = require("./_getMatchData"), matchesStrictComparable = require("./_matchesStrictComparable");
                /**
                     * The base implementation of `_.matches` which doesn't clone `source`.
                     *
                     * @private
                     * @param {Object} source The object of property values to match.
                     * @returns {Function} Returns the new spec function.
                     */ function baseMatches(source) {
                    var matchData = getMatchData(source);
                    if (matchData.length == 1 && matchData[0][2]) return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                    return function(object) {
                        return object === source || baseIsMatch(object, source, matchData);
                    };
                }
                module1.exports = baseMatches;
            },
            {
                "./_baseIsMatch": 100,
                "./_getMatchData": 162,
                "./_matchesStrictComparable": 199
            }, 
        ],
        111: [
            function(require, module1, exports) {
                var baseIsEqual = require("./_baseIsEqual"), get = require("./get"), hasIn = require("./hasIn"), isKey = require("./_isKey"), isStrictComparable = require("./_isStrictComparable"), matchesStrictComparable = require("./_matchesStrictComparable"), toKey = require("./_toKey");
                /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                /**
                     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
                     *
                     * @private
                     * @param {string} path The path of the property to get.
                     * @param {*} srcValue The value to match.
                     * @returns {Function} Returns the new spec function.
                     */ function baseMatchesProperty(path, srcValue) {
                    if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);
                    return function(object) {
                        var objValue = get(object, path);
                        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                    };
                }
                module1.exports = baseMatchesProperty;
            },
            {
                "./_baseIsEqual": 97,
                "./_isKey": 183,
                "./_isStrictComparable": 187,
                "./_matchesStrictComparable": 199,
                "./_toKey": 223,
                "./get": 238,
                "./hasIn": 240
            }, 
        ],
        112: [
            function(require, module1, exports) {
                var Stack = require("./_Stack"), assignMergeValue = require("./_assignMergeValue"), baseFor = require("./_baseFor"), baseMergeDeep = require("./_baseMergeDeep"), isObject = require("./isObject"), keysIn1 = require("./keysIn"), safeGet = require("./_safeGet");
                /**
                     * The base implementation of `_.merge` without support for multiple sources.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {number} srcIndex The index of `source`.
                     * @param {Function} [customizer] The function to customize merged values.
                     * @param {Object} [stack] Tracks traversed source values and their merged
                     *  counterparts.
                     */ function baseMerge(object, source, srcIndex, customizer, stack) {
                    if (object === source) return;
                    baseFor(source, function(srcValue, key) {
                        stack || (stack = new Stack());
                        if (isObject(srcValue)) baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                        else {
                            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                            if (newValue === undefined) newValue = srcValue;
                            assignMergeValue(object, key, newValue);
                        }
                    }, keysIn1);
                }
                module1.exports = baseMerge;
            },
            {
                "./_Stack": 59,
                "./_assignMergeValue": 74,
                "./_baseFor": 87,
                "./_baseMergeDeep": 113,
                "./_safeGet": 209,
                "./isObject": 251,
                "./keysIn": 260
            }, 
        ],
        113: [
            function(require, module1, exports) {
                var assignMergeValue = require("./_assignMergeValue"), cloneBuffer = require("./_cloneBuffer"), cloneTypedArray = require("./_cloneTypedArray"), copyArray = require("./_copyArray"), initCloneObject = require("./_initCloneObject"), isArguments = require("./isArguments"), isArray = require("./isArray"), isArrayLikeObject = require("./isArrayLikeObject"), isBuffer = require("./isBuffer"), isFunction = require("./isFunction"), isObject = require("./isObject"), isPlainObject = require("./isPlainObject"), isTypedArray = require("./isTypedArray"), safeGet = require("./_safeGet"), toPlainObject = require("./toPlainObject");
                /**
                     * A specialized version of `baseMerge` for arrays and objects which performs
                     * deep merges and tracks traversed objects enabling objects with circular
                     * references to be merged.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {string} key The key of the value to merge.
                     * @param {number} srcIndex The index of `source`.
                     * @param {Function} mergeFunc The function to merge values.
                     * @param {Function} [customizer] The function to customize assigned values.
                     * @param {Object} [stack] Tracks traversed source values and their merged
                     *  counterparts.
                     */ function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                    if (stacked) {
                        assignMergeValue(object, key, stacked);
                        return;
                    }
                    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
                    var isCommon = newValue === undefined;
                    if (isCommon) {
                        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                        newValue = srcValue;
                        if (isArr || isBuff || isTyped) {
                            if (isArray(objValue)) newValue = objValue;
                            else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue);
                            else if (isBuff) {
                                isCommon = false;
                                newValue = cloneBuffer(srcValue, true);
                            } else if (isTyped) {
                                isCommon = false;
                                newValue = cloneTypedArray(srcValue, true);
                            } else newValue = [];
                        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                            newValue = objValue;
                            if (isArguments(objValue)) newValue = toPlainObject(objValue);
                            else if (!isObject(objValue) || isFunction(objValue)) newValue = initCloneObject(srcValue);
                        } else isCommon = false;
                    }
                    if (isCommon) {
                        // Recursively merge objects and arrays (susceptible to call stack limits).
                        stack.set(srcValue, newValue);
                        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                        stack["delete"](srcValue);
                    }
                    assignMergeValue(object, key, newValue);
                }
                module1.exports = baseMergeDeep;
            },
            {
                "./_assignMergeValue": 74,
                "./_cloneBuffer": 135,
                "./_cloneTypedArray": 139,
                "./_copyArray": 142,
                "./_initCloneObject": 179,
                "./_safeGet": 209,
                "./isArguments": 242,
                "./isArray": 243,
                "./isArrayLikeObject": 245,
                "./isBuffer": 246,
                "./isFunction": 248,
                "./isObject": 251,
                "./isPlainObject": 253,
                "./isTypedArray": 257,
                "./toPlainObject": 282
            }, 
        ],
        114: [
            function(require, module1, exports) {
                var arrayMap = require("./_arrayMap"), baseIteratee = require("./_baseIteratee"), baseMap = require("./_baseMap"), baseSortBy = require("./_baseSortBy"), baseUnary = require("./_baseUnary"), compareMultiple = require("./_compareMultiple"), identity = require("./identity");
                /**
                     * The base implementation of `_.orderBy` without param guards.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                     * @param {string[]} orders The sort orders of `iteratees`.
                     * @returns {Array} Returns the new sorted array.
                     */ function baseOrderBy(collection, iteratees, orders) {
                    var index = -1;
                    iteratees = arrayMap(iteratees.length ? iteratees : [
                        identity
                    ], baseUnary(baseIteratee));
                    var result = baseMap(collection, function(value, key, collection) {
                        var criteria = arrayMap(iteratees, function(iteratee) {
                            return iteratee(value);
                        });
                        return {
                            criteria: criteria,
                            index: ++index,
                            value: value
                        };
                    });
                    return baseSortBy(result, function(object, other) {
                        return compareMultiple(object, other, orders);
                    });
                }
                module1.exports = baseOrderBy;
            },
            {
                "./_arrayMap": 69,
                "./_baseIteratee": 105,
                "./_baseMap": 109,
                "./_baseSortBy": 124,
                "./_baseUnary": 127,
                "./_compareMultiple": 141,
                "./identity": 241
            }, 
        ],
        115: [
            function(require, module1, exports) {
                var basePickBy = require("./_basePickBy"), hasIn = require("./hasIn");
                /**
                     * The base implementation of `_.pick` without support for individual
                     * property identifiers.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {string[]} paths The property paths to pick.
                     * @returns {Object} Returns the new object.
                     */ function basePick(object, paths) {
                    return basePickBy(object, paths, function(value, path) {
                        return hasIn(object, path);
                    });
                }
                module1.exports = basePick;
            },
            {
                "./_basePickBy": 116,
                "./hasIn": 240
            }, 
        ],
        116: [
            function(require, module1, exports) {
                var baseGet = require("./_baseGet"), baseSet = require("./_baseSet"), castPath = require("./_castPath");
                /**
                     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {string[]} paths The property paths to pick.
                     * @param {Function} predicate The function invoked per property.
                     * @returns {Object} Returns the new object.
                     */ function basePickBy(object, paths, predicate) {
                    var index = -1, length = paths.length, result = {};
                    while(++index < length){
                        var path = paths[index], value = baseGet(object, path);
                        if (predicate(value, path)) baseSet(result, castPath(path, object), value);
                    }
                    return result;
                }
                module1.exports = basePickBy;
            },
            {
                "./_baseGet": 89,
                "./_baseSet": 122,
                "./_castPath": 133
            }, 
        ],
        117: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.property` without support for deep paths.
                     *
                     * @private
                     * @param {string} key The key of the property to get.
                     * @returns {Function} Returns the new accessor function.
                     */ function baseProperty(key) {
                    return function(object) {
                        return object == null ? undefined : object[key];
                    };
                }
                module1.exports = baseProperty;
            },
            {}, 
        ],
        118: [
            function(require, module1, exports) {
                var baseGet = require("./_baseGet");
                /**
                     * A specialized version of `baseProperty` which supports deep paths.
                     *
                     * @private
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new accessor function.
                     */ function basePropertyDeep(path) {
                    return function(object) {
                        return baseGet(object, path);
                    };
                }
                module1.exports = basePropertyDeep;
            },
            {
                "./_baseGet": 89
            }, 
        ],
        119: [
            function(require, module1, exports) {
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeCeil = Math.ceil, nativeMax = Math.max;
                /**
                     * The base implementation of `_.range` and `_.rangeRight` which doesn't
                     * coerce arguments.
                     *
                     * @private
                     * @param {number} start The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} step The value to increment or decrement by.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Array} Returns the range of numbers.
                     */ function baseRange(start, end, step, fromRight) {
                    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                    while(length--){
                        result[fromRight ? length : ++index] = start;
                        start += step;
                    }
                    return result;
                }
                module1.exports = baseRange;
            },
            {}, 
        ],
        120: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.reduce` and `_.reduceRight`, without support
                     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} accumulator The initial value.
                     * @param {boolean} initAccum Specify using the first or last element of
                     *  `collection` as the initial value.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the accumulated value.
                     */ function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                    eachFunc(collection, function(value, index, collection) {
                        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
                    });
                    return accumulator;
                }
                module1.exports = baseReduce;
            },
            {}, 
        ],
        121: [
            function(require, module1, exports) {
                var identity = require("./identity"), overRest = require("./_overRest"), setToString = require("./_setToString");
                /**
                     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
                     *
                     * @private
                     * @param {Function} func The function to apply a rest parameter to.
                     * @param {number} [start=func.length-1] The start position of the rest parameter.
                     * @returns {Function} Returns the new function.
                     */ function baseRest(func, start) {
                    return setToString(overRest(func, start, identity), func + "");
                }
                module1.exports = baseRest;
            },
            {
                "./_overRest": 207,
                "./_setToString": 213,
                "./identity": 241
            }, 
        ],
        122: [
            function(require, module1, exports) {
                var assignValue = require("./_assignValue"), castPath = require("./_castPath"), isIndex = require("./_isIndex"), isObject = require("./isObject"), toKey = require("./_toKey");
                /**
                     * The base implementation of `_.set`.
                     *
                     * @private
                     * @param {Object} object The object to modify.
                     * @param {Array|string} path The path of the property to set.
                     * @param {*} value The value to set.
                     * @param {Function} [customizer] The function to customize path creation.
                     * @returns {Object} Returns `object`.
                     */ function baseSet(object, path, value, customizer) {
                    if (!isObject(object)) return object;
                    path = castPath(path, object);
                    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                    while(nested != null && ++index < length){
                        var key = toKey(path[index]), newValue = value;
                        if (index != lastIndex) {
                            var objValue = nested[key];
                            newValue = customizer ? customizer(objValue, key, nested) : undefined;
                            if (newValue === undefined) newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                        }
                        assignValue(nested, key, newValue);
                        nested = nested[key];
                    }
                    return object;
                }
                module1.exports = baseSet;
            },
            {
                "./_assignValue": 75,
                "./_castPath": 133,
                "./_isIndex": 181,
                "./_toKey": 223,
                "./isObject": 251
            }, 
        ],
        123: [
            function(require, module1, exports) {
                var constant = require("./constant"), defineProperty = require("./_defineProperty"), identity = require("./identity");
                /**
                     * The base implementation of `setToString` without support for hot loop shorting.
                     *
                     * @private
                     * @param {Function} func The function to modify.
                     * @param {Function} string The `toString` result.
                     * @returns {Function} Returns `func`.
                     */ var baseSetToString = !defineProperty ? identity : function(func, string) {
                    return defineProperty(func, "toString", {
                        configurable: true,
                        enumerable: false,
                        value: constant(string),
                        writable: true
                    });
                };
                module1.exports = baseSetToString;
            },
            {
                "./_defineProperty": 153,
                "./constant": 228,
                "./identity": 241
            }, 
        ],
        124: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.sortBy` which uses `comparer` to define the
                     * sort order of `array` and replaces criteria objects with their corresponding
                     * values.
                     *
                     * @private
                     * @param {Array} array The array to sort.
                     * @param {Function} comparer The function to define sort order.
                     * @returns {Array} Returns `array`.
                     */ function baseSortBy(array, comparer) {
                    var length = array.length;
                    array.sort(comparer);
                    while(length--)array[length] = array[length].value;
                    return array;
                }
                module1.exports = baseSortBy;
            },
            {}, 
        ],
        125: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.times` without support for iteratee shorthands
                     * or max array length checks.
                     *
                     * @private
                     * @param {number} n The number of times to invoke `iteratee`.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the array of results.
                     */ function baseTimes(n, iteratee) {
                    var index = -1, result = Array(n);
                    while(++index < n)result[index] = iteratee(index);
                    return result;
                }
                module1.exports = baseTimes;
            },
            {}, 
        ],
        126: [
            function(require, module1, exports) {
                var Symbol = require("./_Symbol"), arrayMap = require("./_arrayMap"), isArray = require("./isArray"), isSymbol = require("./isSymbol");
                /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
                /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
                /**
                     * The base implementation of `_.toString` which doesn't convert nullish
                     * values to empty strings.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {string} Returns the string.
                     */ function baseToString(value) {
                    // Exit early for strings to avoid a performance hit in some environments.
                    if (typeof value == "string") return value;
                    if (isArray(value)) // Recursively convert values (susceptible to call stack limits).
                    return arrayMap(value, baseToString) + "";
                    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
                    var result = value + "";
                    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
                }
                module1.exports = baseToString;
            },
            {
                "./_Symbol": 60,
                "./_arrayMap": 69,
                "./isArray": 243,
                "./isSymbol": 256
            }, 
        ],
        127: [
            function(require, module1, exports) {
                /**
                     * The base implementation of `_.unary` without support for storing metadata.
                     *
                     * @private
                     * @param {Function} func The function to cap arguments for.
                     * @returns {Function} Returns the new capped function.
                     */ function baseUnary(func) {
                    return function(value) {
                        return func(value);
                    };
                }
                module1.exports = baseUnary;
            },
            {}, 
        ],
        128: [
            function(require, module1, exports) {
                var SetCache = require("./_SetCache"), arrayIncludes = require("./_arrayIncludes"), arrayIncludesWith = require("./_arrayIncludesWith"), cacheHas = require("./_cacheHas"), createSet = require("./_createSet"), setToArray = require("./_setToArray");
                /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
                /**
                     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Function} [iteratee] The iteratee invoked per element.
                     * @param {Function} [comparator] The comparator invoked per element.
                     * @returns {Array} Returns the new duplicate free array.
                     */ function baseUniq(array, iteratee, comparator) {
                    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
                    if (comparator) {
                        isCommon = false;
                        includes = arrayIncludesWith;
                    } else if (length >= LARGE_ARRAY_SIZE) {
                        var set = iteratee ? null : createSet(array);
                        if (set) return setToArray(set);
                        isCommon = false;
                        includes = cacheHas;
                        seen = new SetCache();
                    } else seen = iteratee ? [] : result;
                    outer: while(++index < length){
                        var value = array[index], computed = iteratee ? iteratee(value) : value;
                        value = comparator || value !== 0 ? value : 0;
                        if (isCommon && computed === computed) {
                            var seenIndex = seen.length;
                            while(seenIndex--){
                                if (seen[seenIndex] === computed) continue outer;
                            }
                            if (iteratee) seen.push(computed);
                            result.push(value);
                        } else if (!includes(seen, computed, comparator)) {
                            if (seen !== result) seen.push(computed);
                            result.push(value);
                        }
                    }
                    return result;
                }
                module1.exports = baseUniq;
            },
            {
                "./_SetCache": 58,
                "./_arrayIncludes": 66,
                "./_arrayIncludesWith": 67,
                "./_cacheHas": 131,
                "./_createSet": 152,
                "./_setToArray": 212
            }, 
        ],
        129: [
            function(require, module1, exports) {
                var arrayMap = require("./_arrayMap");
                /**
                     * The base implementation of `_.values` and `_.valuesIn` which creates an
                     * array of `object` property values corresponding to the property names
                     * of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the array of property values.
                     */ function baseValues(object, props) {
                    return arrayMap(props, function(key) {
                        return object[key];
                    });
                }
                module1.exports = baseValues;
            },
            {
                "./_arrayMap": 69
            }, 
        ],
        130: [
            function(require, module1, exports) {
                /**
                     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
                     *
                     * @private
                     * @param {Array} props The property identifiers.
                     * @param {Array} values The property values.
                     * @param {Function} assignFunc The function to assign values.
                     * @returns {Object} Returns the new object.
                     */ function baseZipObject(props, values, assignFunc) {
                    var index = -1, length = props.length, valsLength = values.length, result = {};
                    while(++index < length){
                        var value = index < valsLength ? values[index] : undefined;
                        assignFunc(result, props[index], value);
                    }
                    return result;
                }
                module1.exports = baseZipObject;
            },
            {}, 
        ],
        131: [
            function(require, module1, exports) {
                /**
                     * Checks if a `cache` value for `key` exists.
                     *
                     * @private
                     * @param {Object} cache The cache to query.
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */ function cacheHas(cache, key) {
                    return cache.has(key);
                }
                module1.exports = cacheHas;
            },
            {}, 
        ],
        132: [
            function(require, module1, exports) {
                var identity = require("./identity");
                /**
                     * Casts `value` to `identity` if it's not a function.
                     *
                     * @private
                     * @param {*} value The value to inspect.
                     * @returns {Function} Returns cast function.
                     */ function castFunction(value) {
                    return typeof value == "function" ? value : identity;
                }
                module1.exports = castFunction;
            },
            {
                "./identity": 241
            }, 
        ],
        133: [
            function(require, module1, exports) {
                var isArray = require("./isArray"), isKey = require("./_isKey"), stringToPath = require("./_stringToPath"), toString = require("./toString");
                /**
                     * Casts `value` to a path array if it's not one.
                     *
                     * @private
                     * @param {*} value The value to inspect.
                     * @param {Object} [object] The object to query keys on.
                     * @returns {Array} Returns the cast property path array.
                     */ function castPath(value, object) {
                    if (isArray(value)) return value;
                    return isKey(value, object) ? [
                        value
                    ] : stringToPath(toString(value));
                }
                module1.exports = castPath;
            },
            {
                "./_isKey": 183,
                "./_stringToPath": 222,
                "./isArray": 243,
                "./toString": 283
            }, 
        ],
        134: [
            function(require, module1, exports) {
                var Uint8Array = require("./_Uint8Array");
                /**
                     * Creates a clone of `arrayBuffer`.
                     *
                     * @private
                     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                     * @returns {ArrayBuffer} Returns the cloned array buffer.
                     */ function cloneArrayBuffer(arrayBuffer) {
                    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                    return result;
                }
                module1.exports = cloneArrayBuffer;
            },
            {
                "./_Uint8Array": 61
            }, 
        ],
        135: [
            function(require, module1, exports) {
                var root = require("./_root");
                /** Detect free variable `exports`. */ var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
                /** Detect free variable `module`. */ var freeModule = freeExports && typeof module1 == "object" && module1 && !module1.nodeType && module1;
                /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
                /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
                /**
                     * Creates a clone of  `buffer`.
                     *
                     * @private
                     * @param {Buffer} buffer The buffer to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Buffer} Returns the cloned buffer.
                     */ function cloneBuffer(buffer, isDeep) {
                    if (isDeep) return buffer.slice();
                    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                    buffer.copy(result);
                    return result;
                }
                module1.exports = cloneBuffer;
            },
            {
                "./_root": 208
            }, 
        ],
        136: [
            function(require, module1, exports) {
                var cloneArrayBuffer = require("./_cloneArrayBuffer");
                /**
                     * Creates a clone of `dataView`.
                     *
                     * @private
                     * @param {Object} dataView The data view to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the cloned data view.
                     */ function cloneDataView(dataView, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }
                module1.exports = cloneDataView;
            },
            {
                "./_cloneArrayBuffer": 134
            }, 
        ],
        137: [
            function(require, module1, exports) {
                /** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
                /**
                     * Creates a clone of `regexp`.
                     *
                     * @private
                     * @param {Object} regexp The regexp to clone.
                     * @returns {Object} Returns the cloned regexp.
                     */ function cloneRegExp(regexp) {
                    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                    result.lastIndex = regexp.lastIndex;
                    return result;
                }
                module1.exports = cloneRegExp;
            },
            {}, 
        ],
        138: [
            function(require, module1, exports) {
                var Symbol = require("./_Symbol");
                /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
                /**
                     * Creates a clone of the `symbol` object.
                     *
                     * @private
                     * @param {Object} symbol The symbol object to clone.
                     * @returns {Object} Returns the cloned symbol object.
                     */ function cloneSymbol(symbol) {
                    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                }
                module1.exports = cloneSymbol;
            },
            {
                "./_Symbol": 60
            }, 
        ],
        139: [
            function(require, module1, exports) {
                var cloneArrayBuffer = require("./_cloneArrayBuffer");
                /**
                     * Creates a clone of `typedArray`.
                     *
                     * @private
                     * @param {Object} typedArray The typed array to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the cloned typed array.
                     */ function cloneTypedArray(typedArray, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }
                module1.exports = cloneTypedArray;
            },
            {
                "./_cloneArrayBuffer": 134
            }, 
        ],
        140: [
            function(require, module1, exports) {
                var isSymbol = require("./isSymbol");
                /**
                     * Compares values to sort them in ascending order.
                     *
                     * @private
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {number} Returns the sort order indicator for `value`.
                     */ function compareAscending(value, other) {
                    if (value !== other) {
                        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
                        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
                    }
                    return 0;
                }
                module1.exports = compareAscending;
            },
            {
                "./isSymbol": 256
            }, 
        ],
        141: [
            function(require, module1, exports) {
                var compareAscending = require("./_compareAscending");
                /**
                     * Used by `_.orderBy` to compare multiple properties of a value to another
                     * and stable sort them.
                     *
                     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
                     * specify an order of "desc" for descending or "asc" for ascending sort order
                     * of corresponding values.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {boolean[]|string[]} orders The order to sort by for each property.
                     * @returns {number} Returns the sort order indicator for `object`.
                     */ function compareMultiple(object, other, orders) {
                    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                    while(++index < length){
                        var result = compareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength) return result;
                            var order = orders[index];
                            return result * (order == "desc" ? -1 : 1);
                        }
                    }
                    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                    // that causes it, under certain circumstances, to provide the same value for
                    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                    // for more details.
                    //
                    // This also ensures a stable sort in V8 and other engines.
                    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                    return object.index - other.index;
                }
                module1.exports = compareMultiple;
            },
            {
                "./_compareAscending": 140
            }, 
        ],
        142: [
            function(require, module1, exports) {
                /**
                     * Copies the values of `source` to `array`.
                     *
                     * @private
                     * @param {Array} source The array to copy values from.
                     * @param {Array} [array=[]] The array to copy values to.
                     * @returns {Array} Returns `array`.
                     */ function copyArray(source, array) {
                    var index = -1, length = source.length;
                    array || (array = Array(length));
                    while(++index < length)array[index] = source[index];
                    return array;
                }
                module1.exports = copyArray;
            },
            {}, 
        ],
        143: [
            function(require, module1, exports) {
                var assignValue = require("./_assignValue"), baseAssignValue = require("./_baseAssignValue");
                /**
                     * Copies properties of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy properties from.
                     * @param {Array} props The property identifiers to copy.
                     * @param {Object} [object={}] The object to copy properties to.
                     * @param {Function} [customizer] The function to customize copied values.
                     * @returns {Object} Returns `object`.
                     */ function copyObject(source, props, object, customizer) {
                    var isNew = !object;
                    object || (object = {});
                    var index = -1, length = props.length;
                    while(++index < length){
                        var key = props[index];
                        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                        if (newValue === undefined) newValue = source[key];
                        if (isNew) baseAssignValue(object, key, newValue);
                        else assignValue(object, key, newValue);
                    }
                    return object;
                }
                module1.exports = copyObject;
            },
            {
                "./_assignValue": 75,
                "./_baseAssignValue": 79
            }, 
        ],
        144: [
            function(require, module1, exports) {
                var copyObject = require("./_copyObject"), getSymbols = require("./_getSymbols");
                /**
                     * Copies own symbols of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy symbols from.
                     * @param {Object} [object={}] The object to copy symbols to.
                     * @returns {Object} Returns `object`.
                     */ function copySymbols(source, object) {
                    return copyObject(source, getSymbols(source), object);
                }
                module1.exports = copySymbols;
            },
            {
                "./_copyObject": 143,
                "./_getSymbols": 166
            }, 
        ],
        145: [
            function(require, module1, exports) {
                var copyObject = require("./_copyObject"), getSymbolsIn = require("./_getSymbolsIn");
                /**
                     * Copies own and inherited symbols of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy symbols from.
                     * @param {Object} [object={}] The object to copy symbols to.
                     * @returns {Object} Returns `object`.
                     */ function copySymbolsIn(source, object) {
                    return copyObject(source, getSymbolsIn(source), object);
                }
                module1.exports = copySymbolsIn;
            },
            {
                "./_copyObject": 143,
                "./_getSymbolsIn": 167
            }, 
        ],
        146: [
            function(require, module1, exports) {
                var root = require("./_root");
                /** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
                module1.exports = coreJsData;
            },
            {
                "./_root": 208
            }, 
        ],
        147: [
            function(require, module1, exports) {
                var baseRest = require("./_baseRest"), isIterateeCall = require("./_isIterateeCall");
                /**
                     * Creates a function like `_.assign`.
                     *
                     * @private
                     * @param {Function} assigner The function to assign values.
                     * @returns {Function} Returns the new assigner function.
                     */ function createAssigner(assigner) {
                    return baseRest(function(object, sources) {
                        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                            customizer = length < 3 ? undefined : customizer;
                            length = 1;
                        }
                        object = Object(object);
                        while(++index < length){
                            var source = sources[index];
                            if (source) assigner(object, source, index, customizer);
                        }
                        return object;
                    });
                }
                module1.exports = createAssigner;
            },
            {
                "./_baseRest": 121,
                "./_isIterateeCall": 182
            }, 
        ],
        148: [
            function(require, module1, exports) {
                var isArrayLike = require("./isArrayLike");
                /**
                     * Creates a `baseEach` or `baseEachRight` function.
                     *
                     * @private
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */ function createBaseEach(eachFunc, fromRight) {
                    return function(collection, iteratee) {
                        if (collection == null) return collection;
                        if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
                        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                        while(fromRight ? index-- : ++index < length){
                            if (iteratee(iterable[index], index, iterable) === false) break;
                        }
                        return collection;
                    };
                }
                module1.exports = createBaseEach;
            },
            {
                "./isArrayLike": 244
            }, 
        ],
        149: [
            function(require, module1, exports) {
                /**
                     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */ function createBaseFor(fromRight) {
                    return function(object, iteratee, keysFunc) {
                        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                        while(length--){
                            var key = props[fromRight ? length : ++index];
                            if (iteratee(iterable[key], key, iterable) === false) break;
                        }
                        return object;
                    };
                }
                module1.exports = createBaseFor;
            },
            {}, 
        ],
        150: [
            function(require, module1, exports) {
                var baseIteratee = require("./_baseIteratee"), isArrayLike = require("./isArrayLike"), keys = require("./keys");
                /**
                     * Creates a `_.find` or `_.findLast` function.
                     *
                     * @private
                     * @param {Function} findIndexFunc The function to find the collection index.
                     * @returns {Function} Returns the new find function.
                     */ function createFind(findIndexFunc) {
                    return function(collection, predicate, fromIndex) {
                        var iterable = Object(collection);
                        if (!isArrayLike(collection)) {
                            var iteratee = baseIteratee(predicate, 3);
                            collection = keys(collection);
                            predicate = function(key) {
                                return iteratee(iterable[key], key, iterable);
                            };
                        }
                        var index = findIndexFunc(collection, predicate, fromIndex);
                        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                    };
                }
                module1.exports = createFind;
            },
            {
                "./_baseIteratee": 105,
                "./isArrayLike": 244,
                "./keys": 259
            }, 
        ],
        151: [
            function(require, module1, exports) {
                var baseRange = require("./_baseRange"), isIterateeCall = require("./_isIterateeCall"), toFinite = require("./toFinite");
                /**
                     * Creates a `_.range` or `_.rangeRight` function.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new range function.
                     */ function createRange(fromRight) {
                    return function(start, end, step) {
                        if (step && typeof step != "number" && isIterateeCall(start, end, step)) end = step = undefined;
                        // Ensure the sign of `-0` is preserved.
                        start = toFinite(start);
                        if (end === undefined) {
                            end = start;
                            start = 0;
                        } else end = toFinite(end);
                        step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
                        return baseRange(start, end, step, fromRight);
                    };
                }
                module1.exports = createRange;
            },
            {
                "./_baseRange": 119,
                "./_isIterateeCall": 182,
                "./toFinite": 279
            }, 
        ],
        152: [
            function(require, module1, exports) {
                var Set = require("./_Set"), noop = require("./noop"), setToArray = require("./_setToArray");
                /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
                /**
                     * Creates a set object of `values`.
                     *
                     * @private
                     * @param {Array} values The values to add to the set.
                     * @returns {Object} Returns the new set.
                     */ var createSet = !(Set && 1 / setToArray(new Set([
                    ,
                    -0
                ]))[1] == INFINITY) ? noop : function(values) {
                    return new Set(values);
                };
                module1.exports = createSet;
            },
            {
                "./_Set": 57,
                "./_setToArray": 212,
                "./noop": 269
            }, 
        ],
        153: [
            function(require, module1, exports) {
                var getNative = require("./_getNative");
                var defineProperty = function() {
                    try {
                        var func = getNative(Object, "defineProperty");
                        func({}, "", {});
                        return func;
                    } catch (e) {}
                }();
                module1.exports = defineProperty;
            },
            {
                "./_getNative": 163
            }, 
        ],
        154: [
            function(require, module1, exports) {
                var SetCache = require("./_SetCache"), arraySome = require("./_arraySome"), cacheHas = require("./_cacheHas");
                /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                /**
                     * A specialized version of `baseIsEqualDeep` for arrays with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Array} array The array to compare.
                     * @param {Array} other The other array to compare.
                     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                     * @param {Function} customizer The function to customize comparisons.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Object} stack Tracks traversed `array` and `other` objects.
                     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                     */ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
                    // Assume cyclic values are equal.
                    var stacked = stack.get(array);
                    if (stacked && stack.get(other)) return stacked == other;
                    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
                    stack.set(array, other);
                    stack.set(other, array);
                    // Ignore non-index properties.
                    while(++index < arrLength){
                        var arrValue = array[index], othValue = other[index];
                        if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                        if (compared !== undefined) {
                            if (compared) continue;
                            result = false;
                            break;
                        }
                        // Recursively compare arrays (susceptible to call stack limits).
                        if (seen) {
                            if (!arraySome(other, function(othValue, othIndex) {
                                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                            })) {
                                result = false;
                                break;
                            }
                        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                            result = false;
                            break;
                        }
                    }
                    stack["delete"](array);
                    stack["delete"](other);
                    return result;
                }
                module1.exports = equalArrays;
            },
            {
                "./_SetCache": 58,
                "./_arraySome": 72,
                "./_cacheHas": 131
            }, 
        ],
        155: [
            function(require, module1, exports) {
                var Symbol = require("./_Symbol"), Uint8Array = require("./_Uint8Array"), eq = require("./eq"), equalArrays = require("./_equalArrays"), mapToArray = require("./_mapToArray"), setToArray = require("./_setToArray");
                /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                /** `Object#toString` result references. */ var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
                var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
                /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
                /**
                     * A specialized version of `baseIsEqualDeep` for comparing objects of
                     * the same `toStringTag`.
                     *
                     * **Note:** This function only supports comparing values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {string} tag The `toStringTag` of the objects to compare.
                     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                     * @param {Function} customizer The function to customize comparisons.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Object} stack Tracks traversed `object` and `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                    switch(tag){
                        case dataViewTag:
                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
                            object = object.buffer;
                            other = other.buffer;
                        case arrayBufferTag:
                            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) return false;
                            return true;
                        case boolTag:
                        case dateTag:
                        case numberTag:
                            // Coerce booleans to `1` or `0` and dates to milliseconds.
                            // Invalid dates are coerced to `NaN`.
                            return eq(+object, +other);
                        case errorTag:
                            return object.name == other.name && object.message == other.message;
                        case regexpTag:
                        case stringTag:
                            // Coerce regexes to strings and treat strings, primitives and objects,
                            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                            // for more details.
                            return object == other + "";
                        case mapTag:
                            var convert = mapToArray;
                        case setTag:
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                            convert || (convert = setToArray);
                            if (object.size != other.size && !isPartial) return false;
                            // Assume cyclic values are equal.
                            var stacked = stack.get(object);
                            if (stacked) return stacked == other;
                            bitmask |= COMPARE_UNORDERED_FLAG;
                            // Recursively compare objects (susceptible to call stack limits).
                            stack.set(object, other);
                            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                            stack["delete"](object);
                            return result;
                        case symbolTag:
                            if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }
                    return false;
                }
                module1.exports = equalByTag;
            },
            {
                "./_Symbol": 60,
                "./_Uint8Array": 61,
                "./_equalArrays": 154,
                "./_mapToArray": 198,
                "./_setToArray": 212,
                "./eq": 231
            }, 
        ],
        156: [
            function(require, module1, exports) {
                var getAllKeys = require("./_getAllKeys");
                /** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * A specialized version of `baseIsEqualDeep` for objects with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                     * @param {Function} customizer The function to customize comparisons.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Object} stack Tracks traversed `object` and `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                    if (objLength != othLength && !isPartial) return false;
                    var index = objLength;
                    while(index--){
                        var key = objProps[index];
                        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
                    }
                    // Assume cyclic values are equal.
                    var stacked = stack.get(object);
                    if (stacked && stack.get(other)) return stacked == other;
                    var result = true;
                    stack.set(object, other);
                    stack.set(other, object);
                    var skipCtor = isPartial;
                    while(++index < objLength){
                        key = objProps[index];
                        var objValue = object[key], othValue = other[key];
                        if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                        // Recursively compare objects (susceptible to call stack limits).
                        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                            result = false;
                            break;
                        }
                        skipCtor || (skipCtor = key == "constructor");
                    }
                    if (result && !skipCtor) {
                        var objCtor = object.constructor, othCtor = other.constructor;
                        // Non `Object` object instances with different constructors are not equal.
                        if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
                    }
                    stack["delete"](object);
                    stack["delete"](other);
                    return result;
                }
                module1.exports = equalObjects;
            },
            {
                "./_getAllKeys": 159
            }, 
        ],
        157: [
            function(require, module1, exports) {
                var flatten = require("./flatten"), overRest = require("./_overRest"), setToString = require("./_setToString");
                /**
                     * A specialized version of `baseRest` which flattens the rest array.
                     *
                     * @private
                     * @param {Function} func The function to apply a rest parameter to.
                     * @returns {Function} Returns the new function.
                     */ function flatRest(func) {
                    return setToString(overRest(func, undefined, flatten), func + "");
                }
                module1.exports = flatRest;
            },
            {
                "./_overRest": 207,
                "./_setToString": 213,
                "./flatten": 235
            }, 
        ],
        158: [
            function(require, module1, exports) {
                (function(global) {
                    /** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
                    module1.exports = freeGlobal;
                }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
            },
            {}, 
        ],
        159: [
            function(require, module1, exports) {
                var baseGetAllKeys = require("./_baseGetAllKeys"), getSymbols = require("./_getSymbols"), keys = require("./keys");
                /**
                     * Creates an array of own enumerable property names and symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names and symbols.
                     */ function getAllKeys(object) {
                    return baseGetAllKeys(object, keys, getSymbols);
                }
                module1.exports = getAllKeys;
            },
            {
                "./_baseGetAllKeys": 90,
                "./_getSymbols": 166,
                "./keys": 259
            }, 
        ],
        160: [
            function(require, module1, exports) {
                var baseGetAllKeys = require("./_baseGetAllKeys"), getSymbolsIn = require("./_getSymbolsIn"), keysIn1 = require("./keysIn");
                /**
                     * Creates an array of own and inherited enumerable property names and
                     * symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names and symbols.
                     */ function getAllKeysIn(object) {
                    return baseGetAllKeys(object, keysIn1, getSymbolsIn);
                }
                module1.exports = getAllKeysIn;
            },
            {
                "./_baseGetAllKeys": 90,
                "./_getSymbolsIn": 167,
                "./keysIn": 260
            }, 
        ],
        161: [
            function(require, module1, exports) {
                var isKeyable = require("./_isKeyable");
                /**
                     * Gets the data for `map`.
                     *
                     * @private
                     * @param {Object} map The map to query.
                     * @param {string} key The reference key.
                     * @returns {*} Returns the map data.
                     */ function getMapData(map, key) {
                    var data = map.__data__;
                    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                }
                module1.exports = getMapData;
            },
            {
                "./_isKeyable": 184
            }, 
        ],
        162: [
            function(require, module1, exports) {
                var isStrictComparable = require("./_isStrictComparable"), keys = require("./keys");
                /**
                     * Gets the property names, values, and compare flags of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the match data of `object`.
                     */ function getMatchData(object) {
                    var result = keys(object), length = result.length;
                    while(length--){
                        var key = result[length], value = object[key];
                        result[length] = [
                            key,
                            value,
                            isStrictComparable(value), 
                        ];
                    }
                    return result;
                }
                module1.exports = getMatchData;
            },
            {
                "./_isStrictComparable": 187,
                "./keys": 259
            }, 
        ],
        163: [
            function(require, module1, exports) {
                var baseIsNative = require("./_baseIsNative"), getValue = require("./_getValue");
                /**
                     * Gets the native function at `key` of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {string} key The key of the method to get.
                     * @returns {*} Returns the function if it's native, else `undefined`.
                     */ function getNative(object, key) {
                    var value = getValue(object, key);
                    return baseIsNative(value) ? value : undefined;
                }
                module1.exports = getNative;
            },
            {
                "./_baseIsNative": 102,
                "./_getValue": 169
            }, 
        ],
        164: [
            function(require, module1, exports) {
                var overArg = require("./_overArg");
                /** Built-in value references. */ var getPrototype = overArg(Object.getPrototypeOf, Object);
                module1.exports = getPrototype;
            },
            {
                "./_overArg": 206
            }, 
        ],
        165: [
            function(require, module1, exports) {
                var Symbol = require("./_Symbol");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Used to resolve the
                     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                     * of values.
                     */ var nativeObjectToString = objectProto.toString;
                /** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
                /**
                     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @returns {string} Returns the raw `toStringTag`.
                     */ function getRawTag(value) {
                    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                    try {
                        value[symToStringTag] = undefined;
                        var unmasked = true;
                    } catch (e) {}
                    var result = nativeObjectToString.call(value);
                    if (unmasked) {
                        if (isOwn) value[symToStringTag] = tag;
                        else delete value[symToStringTag];
                    }
                    return result;
                }
                module1.exports = getRawTag;
            },
            {
                "./_Symbol": 60
            }, 
        ],
        166: [
            function(require, module1, exports) {
                var arrayFilter = require("./_arrayFilter"), stubArray = require("./stubArray");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;
                /**
                     * Creates an array of the own enumerable symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of symbols.
                     */ var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                    if (object == null) return [];
                    object = Object(object);
                    return arrayFilter(nativeGetSymbols(object), function(symbol) {
                        return propertyIsEnumerable.call(object, symbol);
                    });
                };
                module1.exports = getSymbols;
            },
            {
                "./_arrayFilter": 65,
                "./stubArray": 277
            }, 
        ],
        167: [
            function(require, module1, exports) {
                var arrayPush = require("./_arrayPush"), getPrototype = require("./_getPrototype"), getSymbols = require("./_getSymbols"), stubArray = require("./stubArray");
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;
                /**
                     * Creates an array of the own and inherited enumerable symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of symbols.
                     */ var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                    var result = [];
                    while(object){
                        arrayPush(result, getSymbols(object));
                        object = getPrototype(object);
                    }
                    return result;
                };
                module1.exports = getSymbolsIn;
            },
            {
                "./_arrayPush": 70,
                "./_getPrototype": 164,
                "./_getSymbols": 166,
                "./stubArray": 277
            }, 
        ],
        168: [
            function(require, module1, exports) {
                var DataView = require("./_DataView"), Map = require("./_Map"), Promise = require("./_Promise"), Set = require("./_Set"), WeakMap = require("./_WeakMap"), baseGetTag = require("./_baseGetTag"), toSource = require("./_toSource");
                /** `Object#toString` result references. */ var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
                var dataViewTag = "[object DataView]";
                /** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
                /**
                     * Gets the `toStringTag` of `value`.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @returns {string} Returns the `toStringTag`.
                     */ var getTag = baseGetTag;
                // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
                if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) getTag = function(value) {
                    var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
                    if (ctorString) switch(ctorString){
                        case dataViewCtorString:
                            return dataViewTag;
                        case mapCtorString:
                            return mapTag;
                        case promiseCtorString:
                            return promiseTag;
                        case setCtorString:
                            return setTag;
                        case weakMapCtorString:
                            return weakMapTag;
                    }
                    return result;
                };
                module1.exports = getTag;
            },
            {
                "./_DataView": 51,
                "./_Map": 54,
                "./_Promise": 56,
                "./_Set": 57,
                "./_WeakMap": 62,
                "./_baseGetTag": 91,
                "./_toSource": 224
            }, 
        ],
        169: [
            function(require, module1, exports) {
                /**
                     * Gets the value at `key` of `object`.
                     *
                     * @private
                     * @param {Object} [object] The object to query.
                     * @param {string} key The key of the property to get.
                     * @returns {*} Returns the property value.
                     */ function getValue(object, key) {
                    return object == null ? undefined : object[key];
                }
                module1.exports = getValue;
            },
            {}, 
        ],
        170: [
            function(require, module1, exports) {
                var castPath = require("./_castPath"), isArguments = require("./isArguments"), isArray = require("./isArray"), isIndex = require("./_isIndex"), isLength = require("./isLength"), toKey = require("./_toKey");
                /**
                     * Checks if `path` exists on `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path to check.
                     * @param {Function} hasFunc The function to check properties.
                     * @returns {boolean} Returns `true` if `path` exists, else `false`.
                     */ function hasPath(object, path, hasFunc) {
                    path = castPath(path, object);
                    var index = -1, length = path.length, result = false;
                    while(++index < length){
                        var key = toKey(path[index]);
                        if (!(result = object != null && hasFunc(object, key))) break;
                        object = object[key];
                    }
                    if (result || ++index != length) return result;
                    length = object == null ? 0 : object.length;
                    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
                }
                module1.exports = hasPath;
            },
            {
                "./_castPath": 133,
                "./_isIndex": 181,
                "./_toKey": 223,
                "./isArguments": 242,
                "./isArray": 243,
                "./isLength": 249
            }, 
        ],
        171: [
            function(require, module1, exports) {
                /** Used to compose unicode character classes. */ var rsAstralRange = "\ud800-\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
                /** Used to compose unicode capture groups. */ var rsZWJ = "\\u200d";
                /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
                /**
                     * Checks if `string` contains Unicode symbols.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
                     */ function hasUnicode(string) {
                    return reHasUnicode.test(string);
                }
                module1.exports = hasUnicode;
            },
            {}, 
        ],
        172: [
            function(require, module1, exports) {
                var nativeCreate = require("./_nativeCreate");
                /**
                     * Removes all key-value entries from the hash.
                     *
                     * @private
                     * @name clear
                     * @memberOf Hash
                     */ function hashClear() {
                    this.__data__ = nativeCreate ? nativeCreate(null) : {};
                    this.size = 0;
                }
                module1.exports = hashClear;
            },
            {
                "./_nativeCreate": 201
            }, 
        ],
        173: [
            function(require, module1, exports) {
                /**
                     * Removes `key` and its value from the hash.
                     *
                     * @private
                     * @name delete
                     * @memberOf Hash
                     * @param {Object} hash The hash to modify.
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */ function hashDelete(key) {
                    var result = this.has(key) && delete this.__data__[key];
                    this.size -= result ? 1 : 0;
                    return result;
                }
                module1.exports = hashDelete;
            },
            {}, 
        ],
        174: [
            function(require, module1, exports) {
                var nativeCreate = require("./_nativeCreate");
                /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Gets the hash value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf Hash
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */ function hashGet(key) {
                    var data = this.__data__;
                    if (nativeCreate) {
                        var result = data[key];
                        return result === HASH_UNDEFINED ? undefined : result;
                    }
                    return hasOwnProperty.call(data, key) ? data[key] : undefined;
                }
                module1.exports = hashGet;
            },
            {
                "./_nativeCreate": 201
            }, 
        ],
        175: [
            function(require, module1, exports) {
                var nativeCreate = require("./_nativeCreate");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Checks if a hash value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf Hash
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */ function hashHas(key) {
                    var data = this.__data__;
                    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
                }
                module1.exports = hashHas;
            },
            {
                "./_nativeCreate": 201
            }, 
        ],
        176: [
            function(require, module1, exports) {
                var nativeCreate = require("./_nativeCreate");
                /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
                /**
                     * Sets the hash `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf Hash
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the hash instance.
                     */ function hashSet(key, value) {
                    var data = this.__data__;
                    this.size += this.has(key) ? 0 : 1;
                    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                    return this;
                }
                module1.exports = hashSet;
            },
            {
                "./_nativeCreate": 201
            }, 
        ],
        177: [
            function(require, module1, exports) {
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Initializes an array clone.
                     *
                     * @private
                     * @param {Array} array The array to clone.
                     * @returns {Array} Returns the initialized clone.
                     */ function initCloneArray(array) {
                    var length = array.length, result = new array.constructor(length);
                    // Add properties assigned by `RegExp#exec`.
                    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                        result.index = array.index;
                        result.input = array.input;
                    }
                    return result;
                }
                module1.exports = initCloneArray;
            },
            {}, 
        ],
        178: [
            function(require, module1, exports) {
                var cloneArrayBuffer = require("./_cloneArrayBuffer"), cloneDataView = require("./_cloneDataView"), cloneRegExp = require("./_cloneRegExp"), cloneSymbol = require("./_cloneSymbol"), cloneTypedArray = require("./_cloneTypedArray");
                /** `Object#toString` result references. */ var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
                var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
                /**
                     * Initializes an object clone based on its `toStringTag`.
                     *
                     * **Note:** This function only supports cloning values with tags of
                     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @param {string} tag The `toStringTag` of the object to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the initialized clone.
                     */ function initCloneByTag(object, tag, isDeep) {
                    var Ctor = object.constructor;
                    switch(tag){
                        case arrayBufferTag:
                            return cloneArrayBuffer(object);
                        case boolTag:
                        case dateTag:
                            return new Ctor(+object);
                        case dataViewTag:
                            return cloneDataView(object, isDeep);
                        case float32Tag:
                        case float64Tag:
                        case int8Tag:
                        case int16Tag:
                        case int32Tag:
                        case uint8Tag:
                        case uint8ClampedTag:
                        case uint16Tag:
                        case uint32Tag:
                            return cloneTypedArray(object, isDeep);
                        case mapTag:
                            return new Ctor();
                        case numberTag:
                        case stringTag:
                            return new Ctor(object);
                        case regexpTag:
                            return cloneRegExp(object);
                        case setTag:
                            return new Ctor();
                        case symbolTag:
                            return cloneSymbol(object);
                    }
                }
                module1.exports = initCloneByTag;
            },
            {
                "./_cloneArrayBuffer": 134,
                "./_cloneDataView": 136,
                "./_cloneRegExp": 137,
                "./_cloneSymbol": 138,
                "./_cloneTypedArray": 139
            }, 
        ],
        179: [
            function(require, module1, exports) {
                var baseCreate = require("./_baseCreate"), getPrototype = require("./_getPrototype"), isPrototype = require("./_isPrototype");
                /**
                     * Initializes an object clone.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @returns {Object} Returns the initialized clone.
                     */ function initCloneObject(object) {
                    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
                }
                module1.exports = initCloneObject;
            },
            {
                "./_baseCreate": 81,
                "./_getPrototype": 164,
                "./_isPrototype": 186
            }, 
        ],
        180: [
            function(require, module1, exports) {
                var Symbol = require("./_Symbol"), isArguments = require("./isArguments"), isArray = require("./isArray");
                /** Built-in value references. */ var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
                /**
                     * Checks if `value` is a flattenable `arguments` object or array.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
                     */ function isFlattenable(value) {
                    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                }
                module1.exports = isFlattenable;
            },
            {
                "./_Symbol": 60,
                "./isArguments": 242,
                "./isArray": 243
            }, 
        ],
        181: [
            function(require, module1, exports) {
                /** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
                /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
                /**
                     * Checks if `value` is a valid array-like index.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                     */ function isIndex(value, length) {
                    var type = typeof value;
                    length = length == null ? MAX_SAFE_INTEGER : length;
                    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
                }
                module1.exports = isIndex;
            },
            {}, 
        ],
        182: [
            function(require, module1, exports) {
                var eq = require("./eq"), isArrayLike = require("./isArrayLike"), isIndex = require("./_isIndex"), isObject = require("./isObject");
                /**
                     * Checks if the given arguments are from an iteratee call.
                     *
                     * @private
                     * @param {*} value The potential iteratee value argument.
                     * @param {*} index The potential iteratee index or key argument.
                     * @param {*} object The potential iteratee object argument.
                     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
                     *  else `false`.
                     */ function isIterateeCall(value, index, object) {
                    if (!isObject(object)) return false;
                    var type = typeof index;
                    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) return eq(object[index], value);
                    return false;
                }
                module1.exports = isIterateeCall;
            },
            {
                "./_isIndex": 181,
                "./eq": 231,
                "./isArrayLike": 244,
                "./isObject": 251
            }, 
        ],
        183: [
            function(require, module1, exports) {
                var isArray = require("./isArray"), isSymbol = require("./isSymbol");
                /** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
                /**
                     * Checks if `value` is a property name and not a property path.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {Object} [object] The object to query keys on.
                     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                     */ function isKey(value, object) {
                    if (isArray(value)) return false;
                    var type = typeof value;
                    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) return true;
                    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
                }
                module1.exports = isKey;
            },
            {
                "./isArray": 243,
                "./isSymbol": 256
            }, 
        ],
        184: [
            function(require, module1, exports) {
                /**
                     * Checks if `value` is suitable for use as unique object key.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                     */ function isKeyable(value) {
                    var type = typeof value;
                    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
                }
                module1.exports = isKeyable;
            },
            {}, 
        ],
        185: [
            function(require, module1, exports) {
                var coreJsData = require("./_coreJsData");
                /** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
                    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                    return uid ? "Symbol(src)_1." + uid : "";
                }();
                /**
                     * Checks if `func` has its source masked.
                     *
                     * @private
                     * @param {Function} func The function to check.
                     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                     */ function isMasked(func) {
                    return !!maskSrcKey && maskSrcKey in func;
                }
                module1.exports = isMasked;
            },
            {
                "./_coreJsData": 146
            }, 
        ],
        186: [
            function(require, module1, exports) {
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /**
                     * Checks if `value` is likely a prototype object.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                     */ function isPrototype(value) {
                    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                    return value === proto;
                }
                module1.exports = isPrototype;
            },
            {}, 
        ],
        187: [
            function(require, module1, exports) {
                var isObject = require("./isObject");
                /**
                     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` if suitable for strict
                     *  equality comparisons, else `false`.
                     */ function isStrictComparable(value) {
                    return value === value && !isObject(value);
                }
                module1.exports = isStrictComparable;
            },
            {
                "./isObject": 251
            }, 
        ],
        188: [
            function(require, module1, exports) {
                /**
                     * Removes all key-value entries from the list cache.
                     *
                     * @private
                     * @name clear
                     * @memberOf ListCache
                     */ function listCacheClear() {
                    this.__data__ = [];
                    this.size = 0;
                }
                module1.exports = listCacheClear;
            },
            {}, 
        ],
        189: [
            function(require, module1, exports) {
                var assocIndexOf = require("./_assocIndexOf");
                /** Used for built-in method references. */ var arrayProto = Array.prototype;
                /** Built-in value references. */ var splice = arrayProto.splice;
                /**
                     * Removes `key` and its value from the list cache.
                     *
                     * @private
                     * @name delete
                     * @memberOf ListCache
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */ function listCacheDelete(key) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    if (index < 0) return false;
                    var lastIndex = data.length - 1;
                    if (index == lastIndex) data.pop();
                    else splice.call(data, index, 1);
                    --this.size;
                    return true;
                }
                module1.exports = listCacheDelete;
            },
            {
                "./_assocIndexOf": 76
            }, 
        ],
        190: [
            function(require, module1, exports) {
                var assocIndexOf = require("./_assocIndexOf");
                /**
                     * Gets the list cache value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf ListCache
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */ function listCacheGet(key) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    return index < 0 ? undefined : data[index][1];
                }
                module1.exports = listCacheGet;
            },
            {
                "./_assocIndexOf": 76
            }, 
        ],
        191: [
            function(require, module1, exports) {
                var assocIndexOf = require("./_assocIndexOf");
                /**
                     * Checks if a list cache value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf ListCache
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */ function listCacheHas(key) {
                    return assocIndexOf(this.__data__, key) > -1;
                }
                module1.exports = listCacheHas;
            },
            {
                "./_assocIndexOf": 76
            }, 
        ],
        192: [
            function(require, module1, exports) {
                var assocIndexOf = require("./_assocIndexOf");
                /**
                     * Sets the list cache `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf ListCache
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the list cache instance.
                     */ function listCacheSet(key, value) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    if (index < 0) {
                        ++this.size;
                        data.push([
                            key,
                            value
                        ]);
                    } else data[index][1] = value;
                    return this;
                }
                module1.exports = listCacheSet;
            },
            {
                "./_assocIndexOf": 76
            }, 
        ],
        193: [
            function(require, module1, exports) {
                var Hash = require("./_Hash"), ListCache = require("./_ListCache"), Map = require("./_Map");
                /**
                     * Removes all key-value entries from the map.
                     *
                     * @private
                     * @name clear
                     * @memberOf MapCache
                     */ function mapCacheClear() {
                    this.size = 0;
                    this.__data__ = {
                        hash: new Hash(),
                        map: new (Map || ListCache)(),
                        string: new Hash()
                    };
                }
                module1.exports = mapCacheClear;
            },
            {
                "./_Hash": 52,
                "./_ListCache": 53,
                "./_Map": 54
            }, 
        ],
        194: [
            function(require, module1, exports) {
                var getMapData = require("./_getMapData");
                /**
                     * Removes `key` and its value from the map.
                     *
                     * @private
                     * @name delete
                     * @memberOf MapCache
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */ function mapCacheDelete(key) {
                    var result = getMapData(this, key)["delete"](key);
                    this.size -= result ? 1 : 0;
                    return result;
                }
                module1.exports = mapCacheDelete;
            },
            {
                "./_getMapData": 161
            }, 
        ],
        195: [
            function(require, module1, exports) {
                var getMapData = require("./_getMapData");
                /**
                     * Gets the map value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf MapCache
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */ function mapCacheGet(key) {
                    return getMapData(this, key).get(key);
                }
                module1.exports = mapCacheGet;
            },
            {
                "./_getMapData": 161
            }, 
        ],
        196: [
            function(require, module1, exports) {
                var getMapData = require("./_getMapData");
                /**
                     * Checks if a map value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf MapCache
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */ function mapCacheHas(key) {
                    return getMapData(this, key).has(key);
                }
                module1.exports = mapCacheHas;
            },
            {
                "./_getMapData": 161
            }, 
        ],
        197: [
            function(require, module1, exports) {
                var getMapData = require("./_getMapData");
                /**
                     * Sets the map `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf MapCache
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the map cache instance.
                     */ function mapCacheSet(key, value) {
                    var data = getMapData(this, key), size = data.size;
                    data.set(key, value);
                    this.size += data.size == size ? 0 : 1;
                    return this;
                }
                module1.exports = mapCacheSet;
            },
            {
                "./_getMapData": 161
            }, 
        ],
        198: [
            function(require, module1, exports) {
                /**
                     * Converts `map` to its key-value pairs.
                     *
                     * @private
                     * @param {Object} map The map to convert.
                     * @returns {Array} Returns the key-value pairs.
                     */ function mapToArray(map) {
                    var index = -1, result = Array(map.size);
                    map.forEach(function(value, key) {
                        result[++index] = [
                            key,
                            value
                        ];
                    });
                    return result;
                }
                module1.exports = mapToArray;
            },
            {}, 
        ],
        199: [
            function(require, module1, exports) {
                /**
                     * A specialized version of `matchesProperty` for source values suitable
                     * for strict equality comparisons, i.e. `===`.
                     *
                     * @private
                     * @param {string} key The key of the property to get.
                     * @param {*} srcValue The value to match.
                     * @returns {Function} Returns the new spec function.
                     */ function matchesStrictComparable(key, srcValue) {
                    return function(object) {
                        if (object == null) return false;
                        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
                    };
                }
                module1.exports = matchesStrictComparable;
            },
            {}, 
        ],
        200: [
            function(require, module1, exports) {
                var memoize = require("./memoize");
                /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;
                /**
                     * A specialized version of `_.memoize` which clears the memoized function's
                     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
                     *
                     * @private
                     * @param {Function} func The function to have its output memoized.
                     * @returns {Function} Returns the new memoized function.
                     */ function memoizeCapped(func) {
                    var result = memoize(func, function(key) {
                        if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
                        return key;
                    });
                    var cache = result.cache;
                    return result;
                }
                module1.exports = memoizeCapped;
            },
            {
                "./memoize": 265
            }, 
        ],
        201: [
            function(require, module1, exports) {
                var getNative = require("./_getNative");
                /* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, "create");
                module1.exports = nativeCreate;
            },
            {
                "./_getNative": 163
            }, 
        ],
        202: [
            function(require, module1, exports) {
                var overArg = require("./_overArg");
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys = overArg(Object.keys, Object);
                module1.exports = nativeKeys;
            },
            {
                "./_overArg": 206
            }, 
        ],
        203: [
            function(require, module1, exports) {
                /**
                     * This function is like
                     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                     * except that it includes inherited enumerable properties.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */ function nativeKeysIn(object) {
                    var result = [];
                    if (object != null) for(var key in Object(object))result.push(key);
                    return result;
                }
                module1.exports = nativeKeysIn;
            },
            {}, 
        ],
        204: [
            function(require, module1, exports) {
                var freeGlobal = require("./_freeGlobal");
                /** Detect free variable `exports`. */ var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
                /** Detect free variable `module`. */ var freeModule = freeExports && typeof module1 == "object" && module1 && !module1.nodeType && module1;
                /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
                /** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
                /** Used to access faster Node.js helpers. */ var nodeUtil = function() {
                    try {
                        // Use `util.types` for Node.js 10+.
                        var types = freeModule && freeModule.require && freeModule.require("util").types;
                        if (types) return types;
                        // Legacy `process.binding('util')` for Node.js < 10.
                        return freeProcess && freeProcess.binding && freeProcess.binding("util");
                    } catch (e) {}
                }();
                module1.exports = nodeUtil;
            },
            {
                "./_freeGlobal": 158
            }, 
        ],
        205: [
            function(require, module1, exports) {
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /**
                     * Used to resolve the
                     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                     * of values.
                     */ var nativeObjectToString = objectProto.toString;
                /**
                     * Converts `value` to a string using `Object.prototype.toString`.
                     *
                     * @private
                     * @param {*} value The value to convert.
                     * @returns {string} Returns the converted string.
                     */ function objectToString(value) {
                    return nativeObjectToString.call(value);
                }
                module1.exports = objectToString;
            },
            {}, 
        ],
        206: [
            function(require, module1, exports) {
                /**
                     * Creates a unary function that invokes `func` with its argument transformed.
                     *
                     * @private
                     * @param {Function} func The function to wrap.
                     * @param {Function} transform The argument transform.
                     * @returns {Function} Returns the new function.
                     */ function overArg(func, transform) {
                    return function(arg) {
                        return func(transform(arg));
                    };
                }
                module1.exports = overArg;
            },
            {}, 
        ],
        207: [
            function(require, module1, exports) {
                var apply = require("./_apply");
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
                /**
                     * A specialized version of `baseRest` which transforms the rest array.
                     *
                     * @private
                     * @param {Function} func The function to apply a rest parameter to.
                     * @param {number} [start=func.length-1] The start position of the rest parameter.
                     * @param {Function} transform The rest array transform.
                     * @returns {Function} Returns the new function.
                     */ function overRest(func, start, transform) {
                    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
                    return function() {
                        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                        while(++index < length)array[index] = args[start + index];
                        index = -1;
                        var otherArgs = Array(start + 1);
                        while(++index < start)otherArgs[index] = args[index];
                        otherArgs[start] = transform(array);
                        return apply(func, this, otherArgs);
                    };
                }
                module1.exports = overRest;
            },
            {
                "./_apply": 63
            }, 
        ],
        208: [
            function(require, module1, exports) {
                var freeGlobal = require("./_freeGlobal");
                /** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
                /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
                module1.exports = root;
            },
            {
                "./_freeGlobal": 158
            }, 
        ],
        209: [
            function(require, module1, exports) {
                /**
                     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {string} key The key of the property to get.
                     * @returns {*} Returns the property value.
                     */ function safeGet(object, key) {
                    if (key === "constructor" && typeof object[key] === "function") return;
                    if (key == "__proto__") return;
                    return object[key];
                }
                module1.exports = safeGet;
            },
            {}, 
        ],
        210: [
            function(require, module1, exports) {
                /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
                /**
                     * Adds `value` to the array cache.
                     *
                     * @private
                     * @name add
                     * @memberOf SetCache
                     * @alias push
                     * @param {*} value The value to cache.
                     * @returns {Object} Returns the cache instance.
                     */ function setCacheAdd(value) {
                    this.__data__.set(value, HASH_UNDEFINED);
                    return this;
                }
                module1.exports = setCacheAdd;
            },
            {}, 
        ],
        211: [
            function(require, module1, exports) {
                /**
                     * Checks if `value` is in the array cache.
                     *
                     * @private
                     * @name has
                     * @memberOf SetCache
                     * @param {*} value The value to search for.
                     * @returns {number} Returns `true` if `value` is found, else `false`.
                     */ function setCacheHas(value) {
                    return this.__data__.has(value);
                }
                module1.exports = setCacheHas;
            },
            {}, 
        ],
        212: [
            function(require, module1, exports) {
                /**
                     * Converts `set` to an array of its values.
                     *
                     * @private
                     * @param {Object} set The set to convert.
                     * @returns {Array} Returns the values.
                     */ function setToArray(set) {
                    var index = -1, result = Array(set.size);
                    set.forEach(function(value) {
                        result[++index] = value;
                    });
                    return result;
                }
                module1.exports = setToArray;
            },
            {}, 
        ],
        213: [
            function(require, module1, exports) {
                var baseSetToString = require("./_baseSetToString"), shortOut = require("./_shortOut");
                /**
                     * Sets the `toString` method of `func` to return `string`.
                     *
                     * @private
                     * @param {Function} func The function to modify.
                     * @param {Function} string The `toString` result.
                     * @returns {Function} Returns `func`.
                     */ var setToString = shortOut(baseSetToString);
                module1.exports = setToString;
            },
            {
                "./_baseSetToString": 123,
                "./_shortOut": 214
            }, 
        ],
        214: [
            function(require, module1, exports) {
                /** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeNow = Date.now;
                /**
                     * Creates a function that'll short out and invoke `identity` instead
                     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
                     * milliseconds.
                     *
                     * @private
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new shortable function.
                     */ function shortOut(func) {
                    var count = 0, lastCalled = 0;
                    return function() {
                        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                        lastCalled = stamp;
                        if (remaining > 0) {
                            if (++count >= HOT_COUNT) return arguments[0];
                        } else count = 0;
                        return func.apply(undefined, arguments);
                    };
                }
                module1.exports = shortOut;
            },
            {}, 
        ],
        215: [
            function(require, module1, exports) {
                var ListCache = require("./_ListCache");
                /**
                     * Removes all key-value entries from the stack.
                     *
                     * @private
                     * @name clear
                     * @memberOf Stack
                     */ function stackClear() {
                    this.__data__ = new ListCache();
                    this.size = 0;
                }
                module1.exports = stackClear;
            },
            {
                "./_ListCache": 53
            }, 
        ],
        216: [
            function(require, module1, exports) {
                /**
                     * Removes `key` and its value from the stack.
                     *
                     * @private
                     * @name delete
                     * @memberOf Stack
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */ function stackDelete(key) {
                    var data = this.__data__, result = data["delete"](key);
                    this.size = data.size;
                    return result;
                }
                module1.exports = stackDelete;
            },
            {}, 
        ],
        217: [
            function(require, module1, exports) {
                /**
                     * Gets the stack value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf Stack
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */ function stackGet(key) {
                    return this.__data__.get(key);
                }
                module1.exports = stackGet;
            },
            {}, 
        ],
        218: [
            function(require, module1, exports) {
                /**
                     * Checks if a stack value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf Stack
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */ function stackHas(key) {
                    return this.__data__.has(key);
                }
                module1.exports = stackHas;
            },
            {}, 
        ],
        219: [
            function(require, module1, exports) {
                var ListCache = require("./_ListCache"), Map = require("./_Map"), MapCache = require("./_MapCache");
                /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
                /**
                     * Sets the stack `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf Stack
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the stack cache instance.
                     */ function stackSet(key, value) {
                    var data = this.__data__;
                    if (data instanceof ListCache) {
                        var pairs = data.__data__;
                        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                            pairs.push([
                                key,
                                value
                            ]);
                            this.size = ++data.size;
                            return this;
                        }
                        data = this.__data__ = new MapCache(pairs);
                    }
                    data.set(key, value);
                    this.size = data.size;
                    return this;
                }
                module1.exports = stackSet;
            },
            {
                "./_ListCache": 53,
                "./_Map": 54,
                "./_MapCache": 55
            }, 
        ],
        220: [
            function(require, module1, exports) {
                /**
                     * A specialized version of `_.indexOf` which performs strict equality
                     * comparisons of values, i.e. `===`.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */ function strictIndexOf(array, value, fromIndex) {
                    var index = fromIndex - 1, length = array.length;
                    while(++index < length){
                        if (array[index] === value) return index;
                    }
                    return -1;
                }
                module1.exports = strictIndexOf;
            },
            {}, 
        ],
        221: [
            function(require, module1, exports) {
                var asciiSize = require("./_asciiSize"), hasUnicode = require("./_hasUnicode"), unicodeSize = require("./_unicodeSize");
                /**
                     * Gets the number of symbols in `string`.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {number} Returns the string size.
                     */ function stringSize(string) {
                    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
                }
                module1.exports = stringSize;
            },
            {
                "./_asciiSize": 73,
                "./_hasUnicode": 171,
                "./_unicodeSize": 225
            }, 
        ],
        222: [
            function(require, module1, exports) {
                var memoizeCapped = require("./_memoizeCapped");
                /** Used to match property names within property paths. */ var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                /** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
                /**
                     * Converts `string` to a property path array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the property path array.
                     */ var stringToPath = memoizeCapped(function(string) {
                    var result = [];
                    if (string.charCodeAt(0) === 46 /* . */ ) result.push("");
                    string.replace(rePropName, function(match, number, quote, subString) {
                        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                    });
                    return result;
                });
                module1.exports = stringToPath;
            },
            {
                "./_memoizeCapped": 200
            }, 
        ],
        223: [
            function(require, module1, exports) {
                var isSymbol = require("./isSymbol");
                /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
                /**
                     * Converts `value` to a string key if it's not a string or symbol.
                     *
                     * @private
                     * @param {*} value The value to inspect.
                     * @returns {string|symbol} Returns the key.
                     */ function toKey(value) {
                    if (typeof value == "string" || isSymbol(value)) return value;
                    var result = value + "";
                    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
                }
                module1.exports = toKey;
            },
            {
                "./isSymbol": 256
            }, 
        ],
        224: [
            function(require, module1, exports) {
                /** Used for built-in method references. */ var funcProto = Function.prototype;
                /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
                /**
                     * Converts `func` to its source code.
                     *
                     * @private
                     * @param {Function} func The function to convert.
                     * @returns {string} Returns the source code.
                     */ function toSource(func) {
                    if (func != null) {
                        try {
                            return funcToString.call(func);
                        } catch (e) {}
                        try {
                            return func + "";
                        } catch (e1) {}
                    }
                    return "";
                }
                module1.exports = toSource;
            },
            {}, 
        ],
        225: [
            function(require, module1, exports) {
                /** Used to compose unicode character classes. */ var rsAstralRange = "\ud800-\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
                /** Used to compose unicode capture groups. */ var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\ud83c[\udffb-\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\ud83c[\udde6-\uddff]){2}", rsSurrPair = "[\ud800-\udbff][\udc00-\udfff]", rsZWJ = "\\u200d";
                /** Used to compose unicode regexes. */ var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [
                    rsNonAstral,
                    rsRegional,
                    rsSurrPair
                ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [
                    rsNonAstral + rsCombo + "?",
                    rsCombo,
                    rsRegional,
                    rsSurrPair,
                    rsAstral, 
                ].join("|") + ")";
                /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
                /**
                     * Gets the size of a Unicode `string`.
                     *
                     * @private
                     * @param {string} string The string inspect.
                     * @returns {number} Returns the string size.
                     */ function unicodeSize(string) {
                    var result = reUnicode.lastIndex = 0;
                    while(reUnicode.test(string))++result;
                    return result;
                }
                module1.exports = unicodeSize;
            },
            {}, 
        ],
        226: [
            function(require, module1, exports) {
                var baseClone = require("./_baseClone");
                /** Used to compose bitmasks for cloning. */ var CLONE_SYMBOLS_FLAG = 4;
                /**
                     * Creates a shallow clone of `value`.
                     *
                     * **Note:** This method is loosely based on the
                     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
                     * and supports cloning arrays, array buffers, booleans, date objects, maps,
                     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
                     * arrays. The own enumerable properties of `arguments` objects are cloned
                     * as plain objects. An empty object is returned for uncloneable values such
                     * as error objects, functions, DOM nodes, and WeakMaps.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to clone.
                     * @returns {*} Returns the cloned value.
                     * @see _.cloneDeep
                     * @example
                     *
                     * var objects = [{ 'a': 1 }, { 'b': 2 }];
                     *
                     * var shallow = _.clone(objects);
                     * console.log(shallow[0] === objects[0]);
                     * // => true
                     */ function clone(value) {
                    return baseClone(value, CLONE_SYMBOLS_FLAG);
                }
                module1.exports = clone;
            },
            {
                "./_baseClone": 80
            }, 
        ],
        227: [
            function(require, module1, exports) {
                var baseClone = require("./_baseClone");
                /** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
                /**
                     * This method is like `_.clone` except that it recursively clones `value`.
                     *
                     * @static
                     * @memberOf _
                     * @since 1.0.0
                     * @category Lang
                     * @param {*} value The value to recursively clone.
                     * @returns {*} Returns the deep cloned value.
                     * @see _.clone
                     * @example
                     *
                     * var objects = [{ 'a': 1 }, { 'b': 2 }];
                     *
                     * var deep = _.cloneDeep(objects);
                     * console.log(deep[0] === objects[0]);
                     * // => false
                     */ function cloneDeep(value) {
                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                }
                module1.exports = cloneDeep;
            },
            {
                "./_baseClone": 80
            }, 
        ],
        228: [
            function(require, module1, exports) {
                /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @since 2.4.0
                     * @category Util
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new constant function.
                     * @example
                     *
                     * var objects = _.times(2, _.constant({ 'a': 1 }));
                     *
                     * console.log(objects);
                     * // => [{ 'a': 1 }, { 'a': 1 }]
                     *
                     * console.log(objects[0] === objects[1]);
                     * // => true
                     */ function constant(value) {
                    return function() {
                        return value;
                    };
                }
                module1.exports = constant;
            },
            {}, 
        ],
        229: [
            function(require, module1, exports) {
                var baseRest = require("./_baseRest"), eq = require("./eq"), isIterateeCall = require("./_isIterateeCall"), keysIn1 = require("./keysIn");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Assigns own and inherited enumerable string keyed properties of source
                     * objects to the destination object for all destination properties that
                     * resolve to `undefined`. Source objects are applied from left to right.
                     * Once a property is set, additional values of the same property are ignored.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @see _.defaultsDeep
                     * @example
                     *
                     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                     * // => { 'a': 1, 'b': 2 }
                     */ var defaults = baseRest(function(object, sources) {
                    object = Object(object);
                    var index = -1;
                    var length = sources.length;
                    var guard = length > 2 ? sources[2] : undefined;
                    if (guard && isIterateeCall(sources[0], sources[1], guard)) length = 1;
                    while(++index < length){
                        var source = sources[index];
                        var props = keysIn1(source);
                        var propsIndex = -1;
                        var propsLength = props.length;
                        while(++propsIndex < propsLength){
                            var key = props[propsIndex];
                            var value = object[key];
                            if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) object[key] = source[key];
                        }
                    }
                    return object;
                });
                module1.exports = defaults;
            },
            {
                "./_baseRest": 121,
                "./_isIterateeCall": 182,
                "./eq": 231,
                "./keysIn": 260
            }, 
        ],
        230: [
            function(require, module1, exports) {
                module1.exports = require("./forEach");
            },
            {
                "./forEach": 236
            }, 
        ],
        231: [
            function(require, module1, exports) {
                /**
                     * Performs a
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                     * comparison between two values to determine if they are equivalent.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'a': 1 };
                     * var other = { 'a': 1 };
                     *
                     * _.eq(object, object);
                     * // => true
                     *
                     * _.eq(object, other);
                     * // => false
                     *
                     * _.eq('a', 'a');
                     * // => true
                     *
                     * _.eq('a', Object('a'));
                     * // => false
                     *
                     * _.eq(NaN, NaN);
                     * // => true
                     */ function eq(value, other) {
                    return value === other || value !== value && other !== other;
                }
                module1.exports = eq;
            },
            {}, 
        ],
        232: [
            function(require, module1, exports) {
                var arrayFilter = require("./_arrayFilter"), baseFilter = require("./_baseFilter"), baseIteratee = require("./_baseIteratee"), isArray = require("./isArray");
                /**
                     * Iterates over elements of `collection`, returning an array of all elements
                     * `predicate` returns truthy for. The predicate is invoked with three
                     * arguments: (value, index|key, collection).
                     *
                     * **Note:** Unlike `_.remove`, this method returns a new array.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Collection
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} [predicate=_.identity] The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     * @see _.reject
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * _.filter(users, function(o) { return !o.active; });
                     * // => objects for ['fred']
                     *
                     * // The `_.matches` iteratee shorthand.
                     * _.filter(users, { 'age': 36, 'active': true });
                     * // => objects for ['barney']
                     *
                     * // The `_.matchesProperty` iteratee shorthand.
                     * _.filter(users, ['active', false]);
                     * // => objects for ['fred']
                     *
                     * // The `_.property` iteratee shorthand.
                     * _.filter(users, 'active');
                     * // => objects for ['barney']
                     */ function filter(collection, predicate) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    return func(collection, baseIteratee(predicate, 3));
                }
                module1.exports = filter;
            },
            {
                "./_arrayFilter": 65,
                "./_baseFilter": 84,
                "./_baseIteratee": 105,
                "./isArray": 243
            }, 
        ],
        233: [
            function(require, module1, exports) {
                var createFind = require("./_createFind"), findIndex = require("./findIndex");
                /**
                     * Iterates over elements of `collection`, returning the first element
                     * `predicate` returns truthy for. The predicate is invoked with three
                     * arguments: (value, index|key, collection).
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Collection
                     * @param {Array|Object} collection The collection to inspect.
                     * @param {Function} [predicate=_.identity] The function invoked per iteration.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36, 'active': true },
                     *   { 'user': 'fred',    'age': 40, 'active': false },
                     *   { 'user': 'pebbles', 'age': 1,  'active': true }
                     * ];
                     *
                     * _.find(users, function(o) { return o.age < 40; });
                     * // => object for 'barney'
                     *
                     * // The `_.matches` iteratee shorthand.
                     * _.find(users, { 'age': 1, 'active': true });
                     * // => object for 'pebbles'
                     *
                     * // The `_.matchesProperty` iteratee shorthand.
                     * _.find(users, ['active', false]);
                     * // => object for 'fred'
                     *
                     * // The `_.property` iteratee shorthand.
                     * _.find(users, 'active');
                     * // => object for 'barney'
                     */ var find = createFind(findIndex);
                module1.exports = find;
            },
            {
                "./_createFind": 150,
                "./findIndex": 234
            }, 
        ],
        234: [
            function(require, module1, exports) {
                var baseFindIndex = require("./_baseFindIndex"), baseIteratee = require("./_baseIteratee"), toInteger = require("./toInteger");
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
                /**
                     * This method is like `_.find` except that it returns the index of the first
                     * element `predicate` returns truthy for instead of the element itself.
                     *
                     * @static
                     * @memberOf _
                     * @since 1.1.0
                     * @category Array
                     * @param {Array} array The array to inspect.
                     * @param {Function} [predicate=_.identity] The function invoked per iteration.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * _.findIndex(users, function(o) { return o.user == 'barney'; });
                     * // => 0
                     *
                     * // The `_.matches` iteratee shorthand.
                     * _.findIndex(users, { 'user': 'fred', 'active': false });
                     * // => 1
                     *
                     * // The `_.matchesProperty` iteratee shorthand.
                     * _.findIndex(users, ['active', false]);
                     * // => 0
                     *
                     * // The `_.property` iteratee shorthand.
                     * _.findIndex(users, 'active');
                     * // => 2
                     */ function findIndex(array, predicate, fromIndex) {
                    var length = array == null ? 0 : array.length;
                    if (!length) return -1;
                    var index = fromIndex == null ? 0 : toInteger(fromIndex);
                    if (index < 0) index = nativeMax(length + index, 0);
                    return baseFindIndex(array, baseIteratee(predicate, 3), index);
                }
                module1.exports = findIndex;
            },
            {
                "./_baseFindIndex": 85,
                "./_baseIteratee": 105,
                "./toInteger": 280
            }, 
        ],
        235: [
            function(require, module1, exports) {
                var baseFlatten = require("./_baseFlatten");
                /**
                     * Flattens `array` a single level deep.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Array
                     * @param {Array} array The array to flatten.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2, [3, [4]], 5]]);
                     * // => [1, 2, [3, [4]], 5]
                     */ function flatten(array) {
                    var length = array == null ? 0 : array.length;
                    return length ? baseFlatten(array, 1) : [];
                }
                module1.exports = flatten;
            },
            {
                "./_baseFlatten": 86
            }, 
        ],
        236: [
            function(require, module1, exports) {
                var arrayEach = require("./_arrayEach"), baseEach = require("./_baseEach"), castFunction = require("./_castFunction"), isArray = require("./isArray");
                /**
                     * Iterates over elements of `collection` and invokes `iteratee` for each element.
                     * The iteratee is invoked with three arguments: (value, index|key, collection).
                     * Iteratee functions may exit iteration early by explicitly returning `false`.
                     *
                     * **Note:** As with other "Collections" methods, objects with a "length"
                     * property are iterated like arrays. To avoid this behavior use `_.forIn`
                     * or `_.forOwn` for object iteration.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @alias each
                     * @category Collection
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @returns {Array|Object} Returns `collection`.
                     * @see _.forEachRight
                     * @example
                     *
                     * _.forEach([1, 2], function(value) {
                     *   console.log(value);
                     * });
                     * // => Logs `1` then `2`.
                     *
                     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                     */ function forEach(collection, iteratee) {
                    var func = isArray(collection) ? arrayEach : baseEach;
                    return func(collection, castFunction(iteratee));
                }
                module1.exports = forEach;
            },
            {
                "./_arrayEach": 64,
                "./_baseEach": 82,
                "./_castFunction": 132,
                "./isArray": 243
            }, 
        ],
        237: [
            function(require, module1, exports) {
                var baseFor = require("./_baseFor"), castFunction = require("./_castFunction"), keysIn1 = require("./keysIn");
                /**
                     * Iterates over own and inherited enumerable string keyed properties of an
                     * object and invokes `iteratee` for each property. The iteratee is invoked
                     * with three arguments: (value, key, object). Iteratee functions may exit
                     * iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.3.0
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     * @see _.forInRight
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forIn(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
                     */ function forIn(object, iteratee) {
                    return object == null ? object : baseFor(object, castFunction(iteratee), keysIn1);
                }
                module1.exports = forIn;
            },
            {
                "./_baseFor": 87,
                "./_castFunction": 132,
                "./keysIn": 260
            }, 
        ],
        238: [
            function(require, module1, exports) {
                var baseGet = require("./_baseGet");
                /**
                     * Gets the value at `path` of `object`. If the resolved value is
                     * `undefined`, the `defaultValue` is returned in its place.
                     *
                     * @static
                     * @memberOf _
                     * @since 3.7.0
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to get.
                     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                     *
                     * _.get(object, 'a[0].b.c');
                     * // => 3
                     *
                     * _.get(object, ['a', '0', 'b', 'c']);
                     * // => 3
                     *
                     * _.get(object, 'a.b.c', 'default');
                     * // => 'default'
                     */ function get(object, path, defaultValue) {
                    var result = object == null ? undefined : baseGet(object, path);
                    return result === undefined ? defaultValue : result;
                }
                module1.exports = get;
            },
            {
                "./_baseGet": 89
            }, 
        ],
        239: [
            function(require, module1, exports) {
                var baseHas = require("./_baseHas"), hasPath = require("./_hasPath");
                /**
                     * Checks if `path` is a direct property of `object`.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path to check.
                     * @returns {boolean} Returns `true` if `path` exists, else `false`.
                     * @example
                     *
                     * var object = { 'a': { 'b': 2 } };
                     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
                     *
                     * _.has(object, 'a');
                     * // => true
                     *
                     * _.has(object, 'a.b');
                     * // => true
                     *
                     * _.has(object, ['a', 'b']);
                     * // => true
                     *
                     * _.has(other, 'a');
                     * // => false
                     */ function has(object, path) {
                    return object != null && hasPath(object, path, baseHas);
                }
                module1.exports = has;
            },
            {
                "./_baseHas": 93,
                "./_hasPath": 170
            }, 
        ],
        240: [
            function(require, module1, exports) {
                var baseHasIn = require("./_baseHasIn"), hasPath = require("./_hasPath");
                /**
                     * Checks if `path` is a direct or inherited property of `object`.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path to check.
                     * @returns {boolean} Returns `true` if `path` exists, else `false`.
                     * @example
                     *
                     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
                     *
                     * _.hasIn(object, 'a');
                     * // => true
                     *
                     * _.hasIn(object, 'a.b');
                     * // => true
                     *
                     * _.hasIn(object, ['a', 'b']);
                     * // => true
                     *
                     * _.hasIn(object, 'b');
                     * // => false
                     */ function hasIn(object, path) {
                    return object != null && hasPath(object, path, baseHasIn);
                }
                module1.exports = hasIn;
            },
            {
                "./_baseHasIn": 94,
                "./_hasPath": 170
            }, 
        ],
        241: [
            function(require, module1, exports) {
                /**
                     * This method returns the first argument it receives.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Util
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'a': 1 };
                     *
                     * console.log(_.identity(object) === object);
                     * // => true
                     */ function identity(value) {
                    return value;
                }
                module1.exports = identity;
            },
            {}, 
        ],
        242: [
            function(require, module1, exports) {
                var baseIsArguments = require("./_baseIsArguments"), isObjectLike = require("./isObjectLike");
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
                /**
                     * Checks if `value` is likely an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                     *  else `false`.
                     * @example
                     *
                     * _.isArguments(function() { return arguments; }());
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */ var isArguments = baseIsArguments(function() {
                    return arguments;
                }()) ? baseIsArguments : function(value) {
                    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                };
                module1.exports = isArguments;
            },
            {
                "./_baseIsArguments": 96,
                "./isObjectLike": 252
            }, 
        ],
        243: [
            function(require, module1, exports) {
                /**
                     * Checks if `value` is classified as an `Array` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                     * @example
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     *
                     * _.isArray(document.body.children);
                     * // => false
                     *
                     * _.isArray('abc');
                     * // => false
                     *
                     * _.isArray(_.noop);
                     * // => false
                     */ var isArray = Array.isArray;
                module1.exports = isArray;
            },
            {}, 
        ],
        244: [
            function(require, module1, exports) {
                var isFunction = require("./isFunction"), isLength = require("./isLength");
                /**
                     * Checks if `value` is array-like. A value is considered array-like if it's
                     * not a function and has a `value.length` that's an integer greater than or
                     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                     * @example
                     *
                     * _.isArrayLike([1, 2, 3]);
                     * // => true
                     *
                     * _.isArrayLike(document.body.children);
                     * // => true
                     *
                     * _.isArrayLike('abc');
                     * // => true
                     *
                     * _.isArrayLike(_.noop);
                     * // => false
                     */ function isArrayLike(value) {
                    return value != null && isLength(value.length) && !isFunction(value);
                }
                module1.exports = isArrayLike;
            },
            {
                "./isFunction": 248,
                "./isLength": 249
            }, 
        ],
        245: [
            function(require, module1, exports) {
                var isArrayLike = require("./isArrayLike"), isObjectLike = require("./isObjectLike");
                /**
                     * This method is like `_.isArrayLike` except that it also checks if `value`
                     * is an object.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an array-like object,
                     *  else `false`.
                     * @example
                     *
                     * _.isArrayLikeObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isArrayLikeObject(document.body.children);
                     * // => true
                     *
                     * _.isArrayLikeObject('abc');
                     * // => false
                     *
                     * _.isArrayLikeObject(_.noop);
                     * // => false
                     */ function isArrayLikeObject(value) {
                    return isObjectLike(value) && isArrayLike(value);
                }
                module1.exports = isArrayLikeObject;
            },
            {
                "./isArrayLike": 244,
                "./isObjectLike": 252
            }, 
        ],
        246: [
            function(require, module1, exports) {
                var root = require("./_root"), stubFalse = require("./stubFalse");
                /** Detect free variable `exports`. */ var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
                /** Detect free variable `module`. */ var freeModule = freeExports && typeof module1 == "object" && module1 && !module1.nodeType && module1;
                /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
                /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined;
                /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
                /**
                     * Checks if `value` is a buffer.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.3.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                     * @example
                     *
                     * _.isBuffer(new Buffer(2));
                     * // => true
                     *
                     * _.isBuffer(new Uint8Array(2));
                     * // => false
                     */ var isBuffer = nativeIsBuffer || stubFalse;
                module1.exports = isBuffer;
            },
            {
                "./_root": 208,
                "./stubFalse": 278
            }, 
        ],
        247: [
            function(require, module1, exports) {
                var baseKeys = require("./_baseKeys"), getTag = require("./_getTag"), isArguments = require("./isArguments"), isArray = require("./isArray"), isArrayLike = require("./isArrayLike"), isBuffer = require("./isBuffer"), isPrototype = require("./_isPrototype"), isTypedArray = require("./isTypedArray");
                /** `Object#toString` result references. */ var mapTag = "[object Map]", setTag = "[object Set]";
                /** Used for built-in method references. */ var objectProto = Object.prototype;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /**
                     * Checks if `value` is an empty object, collection, map, or set.
                     *
                     * Objects are considered empty if they have no own enumerable string keyed
                     * properties.
                     *
                     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
                     * jQuery-like collections are considered empty if they have a `length` of `0`.
                     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                     * @example
                     *
                     * _.isEmpty(null);
                     * // => true
                     *
                     * _.isEmpty(true);
                     * // => true
                     *
                     * _.isEmpty(1);
                     * // => true
                     *
                     * _.isEmpty([1, 2, 3]);
                     * // => false
                     *
                     * _.isEmpty({ 'a': 1 });
                     * // => false
                     */ function isEmpty(value) {
                    if (value == null) return true;
                    if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
                    var tag = getTag(value);
                    if (tag == mapTag || tag == setTag) return !value.size;
                    if (isPrototype(value)) return !baseKeys(value).length;
                    for(var key in value){
                        if (hasOwnProperty.call(value, key)) return false;
                    }
                    return true;
                }
                module1.exports = isEmpty;
            },
            {
                "./_baseKeys": 106,
                "./_getTag": 168,
                "./_isPrototype": 186,
                "./isArguments": 242,
                "./isArray": 243,
                "./isArrayLike": 244,
                "./isBuffer": 246,
                "./isTypedArray": 257
            }, 
        ],
        248: [
            function(require, module1, exports) {
                var baseGetTag = require("./_baseGetTag"), isObject = require("./isObject");
                /** `Object#toString` result references. */ var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
                /**
                     * Checks if `value` is classified as a `Function` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     *
                     * _.isFunction(/abc/);
                     * // => false
                     */ function isFunction(value) {
                    if (!isObject(value)) return false;
                    // The use of `Object#toString` avoids issues with the `typeof` operator
                    // in Safari 9 which returns 'object' for typed arrays and other constructors.
                    var tag = baseGetTag(value);
                    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                }
                module1.exports = isFunction;
            },
            {
                "./_baseGetTag": 91,
                "./isObject": 251
            }, 
        ],
        249: [
            function(require, module1, exports) {
                /** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
                /**
                     * Checks if `value` is a valid array-like length.
                     *
                     * **Note:** This method is loosely based on
                     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                     * @example
                     *
                     * _.isLength(3);
                     * // => true
                     *
                     * _.isLength(Number.MIN_VALUE);
                     * // => false
                     *
                     * _.isLength(Infinity);
                     * // => false
                     *
                     * _.isLength('3');
                     * // => false
                     */ function isLength(value) {
                    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }
                module1.exports = isLength;
            },
            {}, 
        ],
        250: [
            function(require, module1, exports) {
                var baseIsMap = require("./_baseIsMap"), baseUnary = require("./_baseUnary"), nodeUtil = require("./_nodeUtil");
                /* Node.js helper references. */ var nodeIsMap = nodeUtil && nodeUtil.isMap;
                /**
                     * Checks if `value` is classified as a `Map` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.3.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                     * @example
                     *
                     * _.isMap(new Map);
                     * // => true
                     *
                     * _.isMap(new WeakMap);
                     * // => false
                     */ var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                module1.exports = isMap;
            },
            {
                "./_baseIsMap": 99,
                "./_baseUnary": 127,
                "./_nodeUtil": 204
            }, 
        ],
        251: [
            function(require, module1, exports) {
                /**
                     * Checks if `value` is the
                     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(_.noop);
                     * // => true
                     *
                     * _.isObject(null);
                     * // => false
                     */ function isObject(value) {
                    var type = typeof value;
                    return value != null && (type == "object" || type == "function");
                }
                module1.exports = isObject;
            },
            {}, 
        ],
        252: [
            function(require, module1, exports) {
                /**
                     * Checks if `value` is object-like. A value is object-like if it's not `null`
                     * and has a `typeof` result of "object".
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                     * @example
                     *
                     * _.isObjectLike({});
                     * // => true
                     *
                     * _.isObjectLike([1, 2, 3]);
                     * // => true
                     *
                     * _.isObjectLike(_.noop);
                     * // => false
                     *
                     * _.isObjectLike(null);
                     * // => false
                     */ function isObjectLike(value) {
                    return value != null && typeof value == "object";
                }
                module1.exports = isObjectLike;
            },
            {}, 
        ],
        253: [
            function(require, module1, exports) {
                var baseGetTag = require("./_baseGetTag"), getPrototype = require("./_getPrototype"), isObjectLike = require("./isObjectLike");
                /** `Object#toString` result references. */ var objectTag = "[object Object]";
                /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
                /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
                /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
                /** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);
                /**
                     * Checks if `value` is a plain object, that is, an object created by the
                     * `Object` constructor or one with a `[[Prototype]]` of `null`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.8.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     * }
                     *
                     * _.isPlainObject(new Foo);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     *
                     * _.isPlainObject(Object.create(null));
                     * // => true
                     */ function isPlainObject(value) {
                    if (!isObjectLike(value) || baseGetTag(value) != objectTag) return false;
                    var proto = getPrototype(value);
                    if (proto === null) return true;
                    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                }
                module1.exports = isPlainObject;
            },
            {
                "./_baseGetTag": 91,
                "./_getPrototype": 164,
                "./isObjectLike": 252
            }, 
        ],
        254: [
            function(require, module1, exports) {
                var baseIsSet = require("./_baseIsSet"), baseUnary = require("./_baseUnary"), nodeUtil = require("./_nodeUtil");
                /* Node.js helper references. */ var nodeIsSet = nodeUtil && nodeUtil.isSet;
                /**
                     * Checks if `value` is classified as a `Set` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.3.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                     * @example
                     *
                     * _.isSet(new Set);
                     * // => true
                     *
                     * _.isSet(new WeakSet);
                     * // => false
                     */ var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                module1.exports = isSet;
            },
            {
                "./_baseIsSet": 103,
                "./_baseUnary": 127,
                "./_nodeUtil": 204
            }, 
        ],
        255: [
            function(require, module1, exports) {
                var baseGetTag = require("./_baseGetTag"), isArray = require("./isArray"), isObjectLike = require("./isObjectLike");
                /** `Object#toString` result references. */ var stringTag = "[object String]";
                /**
                     * Checks if `value` is classified as a `String` primitive or object.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
                     * @example
                     *
                     * _.isString('abc');
                     * // => true
                     *
                     * _.isString(1);
                     * // => false
                     */ function isString(value) {
                    return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                }
                module1.exports = isString;
            },
            {
                "./_baseGetTag": 91,
                "./isArray": 243,
                "./isObjectLike": 252
            }, 
        ],
        256: [
            function(require, module1, exports) {
                var baseGetTag = require("./_baseGetTag"), isObjectLike = require("./isObjectLike");
                /** `Object#toString` result references. */ var symbolTag = "[object Symbol]";
                /**
                     * Checks if `value` is classified as a `Symbol` primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
                     * @example
                     *
                     * _.isSymbol(Symbol.iterator);
                     * // => true
                     *
                     * _.isSymbol('abc');
                     * // => false
                     */ function isSymbol(value) {
                    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
                }
                module1.exports = isSymbol;
            },
            {
                "./_baseGetTag": 91,
                "./isObjectLike": 252
            }, 
        ],
        257: [
            function(require, module1, exports) {
                var baseIsTypedArray = require("./_baseIsTypedArray"), baseUnary = require("./_baseUnary"), nodeUtil = require("./_nodeUtil");
                /* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
                /**
                     * Checks if `value` is classified as a typed array.
                     *
                     * @static
                     * @memberOf _
                     * @since 3.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                     * @example
                     *
                     * _.isTypedArray(new Uint8Array);
                     * // => true
                     *
                     * _.isTypedArray([]);
                     * // => false
                     */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                module1.exports = isTypedArray;
            },
            {
                "./_baseIsTypedArray": 104,
                "./_baseUnary": 127,
                "./_nodeUtil": 204
            }, 
        ],
        258: [
            function(require, module1, exports) {
                /**
                     * Checks if `value` is `undefined`.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                     * @example
                     *
                     * _.isUndefined(void 0);
                     * // => true
                     *
                     * _.isUndefined(null);
                     * // => false
                     */ function isUndefined(value) {
                    return value === undefined;
                }
                module1.exports = isUndefined;
            },
            {}, 
        ],
        259: [
            function(require, module1, exports) {
                var arrayLikeKeys = require("./_arrayLikeKeys"), baseKeys = require("./_baseKeys"), isArrayLike = require("./isArrayLike");
                /**
                     * Creates an array of the own enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects. See the
                     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                     * for more details.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keys(new Foo);
                     * // => ['a', 'b'] (iteration order is not guaranteed)
                     *
                     * _.keys('hi');
                     * // => ['0', '1']
                     */ function keys(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                }
                module1.exports = keys;
            },
            {
                "./_arrayLikeKeys": 68,
                "./_baseKeys": 106,
                "./isArrayLike": 244
            }, 
        ],
        260: [
            function(require, module1, exports) {
                var arrayLikeKeys = require("./_arrayLikeKeys"), baseKeysIn = require("./_baseKeysIn"), isArrayLike = require("./isArrayLike");
                /**
                     * Creates an array of the own and inherited enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @since 3.0.0
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keysIn(new Foo);
                     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                     */ function keysIn1(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                }
                module1.exports = keysIn1;
            },
            {
                "./_arrayLikeKeys": 68,
                "./_baseKeysIn": 107,
                "./isArrayLike": 244
            }, 
        ],
        261: [
            function(require, module1, exports) {
                /**
                     * Gets the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the last element of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     */ function last(array) {
                    var length = array == null ? 0 : array.length;
                    return length ? array[length - 1] : undefined;
                }
                module1.exports = last;
            },
            {}, 
        ],
        262: [
            function(require, module1, exports) {
                var arrayMap = require("./_arrayMap"), baseIteratee = require("./_baseIteratee"), baseMap = require("./_baseMap"), isArray = require("./isArray");
                /**
                     * Creates an array of values by running each element in `collection` thru
                     * `iteratee`. The iteratee is invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                     *
                     * The guarded methods are:
                     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
                     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
                     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
                     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Collection
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     * @example
                     *
                     * function square(n) {
                     *   return n * n;
                     * }
                     *
                     * _.map([4, 8], square);
                     * // => [16, 64]
                     *
                     * _.map({ 'a': 4, 'b': 8 }, square);
                     * // => [16, 64] (iteration order is not guaranteed)
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * // The `_.property` iteratee shorthand.
                     * _.map(users, 'user');
                     * // => ['barney', 'fred']
                     */ function map(collection, iteratee) {
                    var func = isArray(collection) ? arrayMap : baseMap;
                    return func(collection, baseIteratee(iteratee, 3));
                }
                module1.exports = map;
            },
            {
                "./_arrayMap": 69,
                "./_baseIteratee": 105,
                "./_baseMap": 109,
                "./isArray": 243
            }, 
        ],
        263: [
            function(require, module1, exports) {
                var baseAssignValue = require("./_baseAssignValue"), baseForOwn = require("./_baseForOwn"), baseIteratee = require("./_baseIteratee");
                /**
                     * Creates an object with the same keys as `object` and values generated
                     * by running each own enumerable string keyed property of `object` thru
                     * `iteratee`. The iteratee is invoked with three arguments:
                     * (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @since 2.4.0
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @returns {Object} Returns the new mapped object.
                     * @see _.mapKeys
                     * @example
                     *
                     * var users = {
                     *   'fred':    { 'user': 'fred',    'age': 40 },
                     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
                     * };
                     *
                     * _.mapValues(users, function(o) { return o.age; });
                     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                     *
                     * // The `_.property` iteratee shorthand.
                     * _.mapValues(users, 'age');
                     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                     */ function mapValues(object, iteratee) {
                    var result = {};
                    iteratee = baseIteratee(iteratee, 3);
                    baseForOwn(object, function(value, key, object) {
                        baseAssignValue(result, key, iteratee(value, key, object));
                    });
                    return result;
                }
                module1.exports = mapValues;
            },
            {
                "./_baseAssignValue": 79,
                "./_baseForOwn": 88,
                "./_baseIteratee": 105
            }, 
        ],
        264: [
            function(require, module1, exports) {
                var baseExtremum = require("./_baseExtremum"), baseGt = require("./_baseGt"), identity = require("./identity");
                /**
                     * Computes the maximum value of `array`. If `array` is empty or falsey,
                     * `undefined` is returned.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Math
                     * @param {Array} array The array to iterate over.
                     * @returns {*} Returns the maximum value.
                     * @example
                     *
                     * _.max([4, 2, 8, 6]);
                     * // => 8
                     *
                     * _.max([]);
                     * // => undefined
                     */ function max(array) {
                    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
                }
                module1.exports = max;
            },
            {
                "./_baseExtremum": 83,
                "./_baseGt": 92,
                "./identity": 241
            }, 
        ],
        265: [
            function(require, module1, exports) {
                var MapCache = require("./_MapCache");
                /** Error message constants. */ var FUNC_ERROR_TEXT = "Expected a function";
                /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided, it determines the cache key for storing the result based on the
                     * arguments provided to the memoized function. By default, the first argument
                     * provided to the memoized function is used as the map cache key. The `func`
                     * is invoked with the `this` binding of the memoized function.
                     *
                     * **Note:** The cache is exposed as the `cache` property on the memoized
                     * function. Its creation may be customized by replacing the `_.memoize.Cache`
                     * constructor with one whose instances implement the
                     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
                     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Function
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] The function to resolve the cache key.
                     * @returns {Function} Returns the new memoized function.
                     * @example
                     *
                     * var object = { 'a': 1, 'b': 2 };
                     * var other = { 'c': 3, 'd': 4 };
                     *
                     * var values = _.memoize(_.values);
                     * values(object);
                     * // => [1, 2]
                     *
                     * values(other);
                     * // => [3, 4]
                     *
                     * object.a = 2;
                     * values(object);
                     * // => [1, 2]
                     *
                     * // Modify the result cache.
                     * values.cache.set(object, ['a', 'b']);
                     * values(object);
                     * // => ['a', 'b']
                     *
                     * // Replace `_.memoize.Cache`.
                     * _.memoize.Cache = WeakMap;
                     */ function memoize(func, resolver) {
                    if (typeof func != "function" || resolver != null && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT);
                    var memoized = function() {
                        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                        if (cache.has(key)) return cache.get(key);
                        var result = func.apply(this, args);
                        memoized.cache = cache.set(key, result) || cache;
                        return result;
                    };
                    memoized.cache = new (memoize.Cache || MapCache)();
                    return memoized;
                }
                // Expose `MapCache`.
                memoize.Cache = MapCache;
                module1.exports = memoize;
            },
            {
                "./_MapCache": 55
            }, 
        ],
        266: [
            function(require, module1, exports) {
                var baseMerge = require("./_baseMerge"), createAssigner = require("./_createAssigner");
                /**
                     * This method is like `_.assign` except that it recursively merges own and
                     * inherited enumerable string keyed properties of source objects into the
                     * destination object. Source properties that resolve to `undefined` are
                     * skipped if a destination value exists. Array and plain object properties
                     * are merged recursively. Other objects and value types are overridden by
                     * assignment. Source objects are applied from left to right. Subsequent
                     * sources overwrite property assignments of previous sources.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.5.0
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var object = {
                     *   'a': [{ 'b': 2 }, { 'd': 4 }]
                     * };
                     *
                     * var other = {
                     *   'a': [{ 'c': 3 }, { 'e': 5 }]
                     * };
                     *
                     * _.merge(object, other);
                     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
                     */ var merge = createAssigner(function(object, source, srcIndex) {
                    baseMerge(object, source, srcIndex);
                });
                module1.exports = merge;
            },
            {
                "./_baseMerge": 112,
                "./_createAssigner": 147
            }, 
        ],
        267: [
            function(require, module1, exports) {
                var baseExtremum = require("./_baseExtremum"), baseLt = require("./_baseLt"), identity = require("./identity");
                /**
                     * Computes the minimum value of `array`. If `array` is empty or falsey,
                     * `undefined` is returned.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Math
                     * @param {Array} array The array to iterate over.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * _.min([4, 2, 8, 6]);
                     * // => 2
                     *
                     * _.min([]);
                     * // => undefined
                     */ function min(array) {
                    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
                }
                module1.exports = min;
            },
            {
                "./_baseExtremum": 83,
                "./_baseLt": 108,
                "./identity": 241
            }, 
        ],
        268: [
            function(require, module1, exports) {
                var baseExtremum = require("./_baseExtremum"), baseIteratee = require("./_baseIteratee"), baseLt = require("./_baseLt");
                /**
                     * This method is like `_.min` except that it accepts `iteratee` which is
                     * invoked for each element in `array` to generate the criterion by which
                     * the value is ranked. The iteratee is invoked with one argument: (value).
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Math
                     * @param {Array} array The array to iterate over.
                     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * var objects = [{ 'n': 1 }, { 'n': 2 }];
                     *
                     * _.minBy(objects, function(o) { return o.n; });
                     * // => { 'n': 1 }
                     *
                     * // The `_.property` iteratee shorthand.
                     * _.minBy(objects, 'n');
                     * // => { 'n': 1 }
                     */ function minBy(array, iteratee) {
                    return array && array.length ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt) : undefined;
                }
                module1.exports = minBy;
            },
            {
                "./_baseExtremum": 83,
                "./_baseIteratee": 105,
                "./_baseLt": 108
            }, 
        ],
        269: [
            function(require, module1, exports) {
                /**
                     * This method returns `undefined`.
                     *
                     * @static
                     * @memberOf _
                     * @since 2.3.0
                     * @category Util
                     * @example
                     *
                     * _.times(2, _.noop);
                     * // => [undefined, undefined]
                     */ function noop() {
                // No operation performed.
                }
                module1.exports = noop;
            },
            {}, 
        ],
        270: [
            function(require, module1, exports) {
                var root = require("./_root");
                /**
                     * Gets the timestamp of the number of milliseconds that have elapsed since
                     * the Unix epoch (1 January 1970 00:00:00 UTC).
                     *
                     * @static
                     * @memberOf _
                     * @since 2.4.0
                     * @category Date
                     * @returns {number} Returns the timestamp.
                     * @example
                     *
                     * _.defer(function(stamp) {
                     *   console.log(_.now() - stamp);
                     * }, _.now());
                     * // => Logs the number of milliseconds it took for the deferred invocation.
                     */ var now = function() {
                    return root.Date.now();
                };
                module1.exports = now;
            },
            {
                "./_root": 208
            }, 
        ],
        271: [
            function(require, module1, exports) {
                var basePick = require("./_basePick"), flatRest = require("./_flatRest");
                /**
                     * Creates an object composed of the picked `object` properties.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {...(string|string[])} [paths] The property paths to pick.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'a': 1, 'b': '2', 'c': 3 };
                     *
                     * _.pick(object, ['a', 'c']);
                     * // => { 'a': 1, 'c': 3 }
                     */ var pick = flatRest(function(object, paths) {
                    return object == null ? {} : basePick(object, paths);
                });
                module1.exports = pick;
            },
            {
                "./_basePick": 115,
                "./_flatRest": 157
            }, 
        ],
        272: [
            function(require, module1, exports) {
                var baseProperty = require("./_baseProperty"), basePropertyDeep = require("./_basePropertyDeep"), isKey = require("./_isKey"), toKey = require("./_toKey");
                /**
                     * Creates a function that returns the value at `path` of a given object.
                     *
                     * @static
                     * @memberOf _
                     * @since 2.4.0
                     * @category Util
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new accessor function.
                     * @example
                     *
                     * var objects = [
                     *   { 'a': { 'b': 2 } },
                     *   { 'a': { 'b': 1 } }
                     * ];
                     *
                     * _.map(objects, _.property('a.b'));
                     * // => [2, 1]
                     *
                     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
                     * // => [1, 2]
                     */ function property(path) {
                    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                }
                module1.exports = property;
            },
            {
                "./_baseProperty": 117,
                "./_basePropertyDeep": 118,
                "./_isKey": 183,
                "./_toKey": 223
            }, 
        ],
        273: [
            function(require, module1, exports) {
                var createRange = require("./_createRange");
                /**
                     * Creates an array of numbers (positive and/or negative) progressing from
                     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
                     * `start` is specified without an `end` or `step`. If `end` is not specified,
                     * it's set to `start` with `start` then set to `0`.
                     *
                     * **Note:** JavaScript follows the IEEE-754 standard for resolving
                     * floating-point values which can produce unexpected results.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Util
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} [step=1] The value to increment or decrement by.
                     * @returns {Array} Returns the range of numbers.
                     * @see _.inRange, _.rangeRight
                     * @example
                     *
                     * _.range(4);
                     * // => [0, 1, 2, 3]
                     *
                     * _.range(-4);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 5);
                     * // => [1, 2, 3, 4]
                     *
                     * _.range(0, 20, 5);
                     * // => [0, 5, 10, 15]
                     *
                     * _.range(0, -4, -1);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 4, 0);
                     * // => [1, 1, 1]
                     *
                     * _.range(0);
                     * // => []
                     */ var range = createRange();
                module1.exports = range;
            },
            {
                "./_createRange": 151
            }, 
        ],
        274: [
            function(require, module1, exports) {
                var arrayReduce = require("./_arrayReduce"), baseEach = require("./_baseEach"), baseIteratee = require("./_baseIteratee"), baseReduce = require("./_baseReduce"), isArray = require("./isArray");
                /**
                     * Reduces `collection` to a value which is the accumulated result of running
                     * each element in `collection` thru `iteratee`, where each successive
                     * invocation is supplied the return value of the previous. If `accumulator`
                     * is not given, the first element of `collection` is used as the initial
                     * value. The iteratee is invoked with four arguments:
                     * (accumulator, value, index|key, collection).
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.reduce`, `_.reduceRight`, and `_.transform`.
                     *
                     * The guarded methods are:
                     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
                     * and `sortBy`
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Collection
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @returns {*} Returns the accumulated value.
                     * @see _.reduceRight
                     * @example
                     *
                     * _.reduce([1, 2], function(sum, n) {
                     *   return sum + n;
                     * }, 0);
                     * // => 3
                     *
                     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                     *   (result[value] || (result[value] = [])).push(key);
                     *   return result;
                     * }, {});
                     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
                     */ function reduce(collection, iteratee, accumulator) {
                    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                    return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                }
                module1.exports = reduce;
            },
            {
                "./_arrayReduce": 71,
                "./_baseEach": 82,
                "./_baseIteratee": 105,
                "./_baseReduce": 120,
                "./isArray": 243
            }, 
        ],
        275: [
            function(require, module1, exports) {
                var baseKeys = require("./_baseKeys"), getTag = require("./_getTag"), isArrayLike = require("./isArrayLike"), isString = require("./isString"), stringSize = require("./_stringSize");
                /** `Object#toString` result references. */ var mapTag = "[object Map]", setTag = "[object Set]";
                /**
                     * Gets the size of `collection` by returning its length for array-like
                     * values or the number of own enumerable string keyed properties for objects.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to inspect.
                     * @returns {number} Returns the collection size.
                     * @example
                     *
                     * _.size([1, 2, 3]);
                     * // => 3
                     *
                     * _.size({ 'a': 1, 'b': 2 });
                     * // => 2
                     *
                     * _.size('pebbles');
                     * // => 7
                     */ function size(collection) {
                    if (collection == null) return 0;
                    if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
                    var tag = getTag(collection);
                    if (tag == mapTag || tag == setTag) return collection.size;
                    return baseKeys(collection).length;
                }
                module1.exports = size;
            },
            {
                "./_baseKeys": 106,
                "./_getTag": 168,
                "./_stringSize": 221,
                "./isArrayLike": 244,
                "./isString": 255
            }, 
        ],
        276: [
            function(require, module1, exports) {
                var baseFlatten = require("./_baseFlatten"), baseOrderBy = require("./_baseOrderBy"), baseRest = require("./_baseRest"), isIterateeCall = require("./_isIterateeCall");
                /**
                     * Creates an array of elements, sorted in ascending order by the results of
                     * running each element in a collection thru each iteratee. This method
                     * performs a stable sort, that is, it preserves the original sort order of
                     * equal elements. The iteratees are invoked with one argument: (value).
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Collection
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {...(Function|Function[])} [iteratees=[_.identity]]
                     *  The iteratees to sort by.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'fred',   'age': 48 },
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 },
                     *   { 'user': 'barney', 'age': 34 }
                     * ];
                     *
                     * _.sortBy(users, [function(o) { return o.user; }]);
                     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                     *
                     * _.sortBy(users, ['user', 'age']);
                     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
                     */ var sortBy = baseRest(function(collection, iteratees) {
                    if (collection == null) return [];
                    var length = iteratees.length;
                    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) iteratees = [];
                    else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) iteratees = [
                        iteratees[0]
                    ];
                    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                });
                module1.exports = sortBy;
            },
            {
                "./_baseFlatten": 86,
                "./_baseOrderBy": 114,
                "./_baseRest": 121,
                "./_isIterateeCall": 182
            }, 
        ],
        277: [
            function(require, module1, exports) {
                /**
                     * This method returns a new empty array.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.13.0
                     * @category Util
                     * @returns {Array} Returns the new empty array.
                     * @example
                     *
                     * var arrays = _.times(2, _.stubArray);
                     *
                     * console.log(arrays);
                     * // => [[], []]
                     *
                     * console.log(arrays[0] === arrays[1]);
                     * // => false
                     */ function stubArray() {
                    return [];
                }
                module1.exports = stubArray;
            },
            {}, 
        ],
        278: [
            function(require, module1, exports) {
                /**
                     * This method returns `false`.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.13.0
                     * @category Util
                     * @returns {boolean} Returns `false`.
                     * @example
                     *
                     * _.times(2, _.stubFalse);
                     * // => [false, false]
                     */ function stubFalse() {
                    return false;
                }
                module1.exports = stubFalse;
            },
            {}, 
        ],
        279: [
            function(require, module1, exports) {
                var toNumber = require("./toNumber");
                /** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
                /**
                     * Converts `value` to a finite number.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.12.0
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {number} Returns the converted number.
                     * @example
                     *
                     * _.toFinite(3.2);
                     * // => 3.2
                     *
                     * _.toFinite(Number.MIN_VALUE);
                     * // => 5e-324
                     *
                     * _.toFinite(Infinity);
                     * // => 1.7976931348623157e+308
                     *
                     * _.toFinite('3.2');
                     * // => 3.2
                     */ function toFinite(value) {
                    if (!value) return value === 0 ? value : 0;
                    value = toNumber(value);
                    if (value === INFINITY || value === -INFINITY) {
                        var sign = value < 0 ? -1 : 1;
                        return sign * MAX_INTEGER;
                    }
                    return value === value ? value : 0;
                }
                module1.exports = toFinite;
            },
            {
                "./toNumber": 281
            }, 
        ],
        280: [
            function(require, module1, exports) {
                var toFinite = require("./toFinite");
                /**
                     * Converts `value` to an integer.
                     *
                     * **Note:** This method is loosely based on
                     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {number} Returns the converted integer.
                     * @example
                     *
                     * _.toInteger(3.2);
                     * // => 3
                     *
                     * _.toInteger(Number.MIN_VALUE);
                     * // => 0
                     *
                     * _.toInteger(Infinity);
                     * // => 1.7976931348623157e+308
                     *
                     * _.toInteger('3.2');
                     * // => 3
                     */ function toInteger(value) {
                    var result = toFinite(value), remainder = result % 1;
                    return result === result ? remainder ? result - remainder : result : 0;
                }
                module1.exports = toInteger;
            },
            {
                "./toFinite": 279
            }, 
        ],
        281: [
            function(require, module1, exports) {
                var isObject = require("./isObject"), isSymbol = require("./isSymbol");
                /** Used as references for various `Number` constants. */ var NAN = 0 / 0;
                /** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
                /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
                /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
                /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
                /** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
                /**
                     * Converts `value` to a number.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to process.
                     * @returns {number} Returns the number.
                     * @example
                     *
                     * _.toNumber(3.2);
                     * // => 3.2
                     *
                     * _.toNumber(Number.MIN_VALUE);
                     * // => 5e-324
                     *
                     * _.toNumber(Infinity);
                     * // => Infinity
                     *
                     * _.toNumber('3.2');
                     * // => 3.2
                     */ function toNumber(value) {
                    if (typeof value == "number") return value;
                    if (isSymbol(value)) return NAN;
                    if (isObject(value)) {
                        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                        value = isObject(other) ? other + "" : other;
                    }
                    if (typeof value != "string") return value === 0 ? value : +value;
                    value = value.replace(reTrim, "");
                    var isBinary = reIsBinary.test(value);
                    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                }
                module1.exports = toNumber;
            },
            {
                "./isObject": 251,
                "./isSymbol": 256
            }, 
        ],
        282: [
            function(require, module1, exports) {
                var copyObject = require("./_copyObject"), keysIn1 = require("./keysIn");
                /**
                     * Converts `value` to a plain object flattening inherited enumerable string
                     * keyed properties of `value` to own properties of the plain object.
                     *
                     * @static
                     * @memberOf _
                     * @since 3.0.0
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {Object} Returns the converted plain object.
                     * @example
                     *
                     * function Foo() {
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.assign({ 'a': 1 }, new Foo);
                     * // => { 'a': 1, 'b': 2 }
                     *
                     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                     * // => { 'a': 1, 'b': 2, 'c': 3 }
                     */ function toPlainObject(value) {
                    return copyObject(value, keysIn1(value));
                }
                module1.exports = toPlainObject;
            },
            {
                "./_copyObject": 143,
                "./keysIn": 260
            }, 
        ],
        283: [
            function(require, module1, exports) {
                var baseToString = require("./_baseToString");
                /**
                     * Converts `value` to a string. An empty string is returned for `null`
                     * and `undefined` values. The sign of `-0` is preserved.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {string} Returns the converted string.
                     * @example
                     *
                     * _.toString(null);
                     * // => ''
                     *
                     * _.toString(-0);
                     * // => '-0'
                     *
                     * _.toString([1, 2, 3]);
                     * // => '1,2,3'
                     */ function toString(value) {
                    return value == null ? "" : baseToString(value);
                }
                module1.exports = toString;
            },
            {
                "./_baseToString": 126
            }, 
        ],
        284: [
            function(require, module1, exports) {
                var arrayEach = require("./_arrayEach"), baseCreate = require("./_baseCreate"), baseForOwn = require("./_baseForOwn"), baseIteratee = require("./_baseIteratee"), getPrototype = require("./_getPrototype"), isArray = require("./isArray"), isBuffer = require("./isBuffer"), isFunction = require("./isFunction"), isObject = require("./isObject"), isTypedArray = require("./isTypedArray");
                /**
                     * An alternative to `_.reduce`; this method transforms `object` to a new
                     * `accumulator` object which is the result of running each of its own
                     * enumerable string keyed properties thru `iteratee`, with each invocation
                     * potentially mutating the `accumulator` object. If `accumulator` is not
                     * provided, a new object with the same `[[Prototype]]` will be used. The
                     * iteratee is invoked with four arguments: (accumulator, value, key, object).
                     * Iteratee functions may exit iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @since 1.3.0
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The custom accumulator value.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * _.transform([2, 3, 4], function(result, n) {
                     *   result.push(n *= n);
                     *   return n % 2 == 0;
                     * }, []);
                     * // => [4, 9]
                     *
                     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                     *   (result[value] || (result[value] = [])).push(key);
                     * }, {});
                     * // => { '1': ['a', 'c'], '2': ['b'] }
                     */ function transform(object, iteratee, accumulator) {
                    var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                    iteratee = baseIteratee(iteratee, 4);
                    if (accumulator == null) {
                        var Ctor = object && object.constructor;
                        if (isArrLike) accumulator = isArr ? new Ctor() : [];
                        else if (isObject(object)) accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                        else accumulator = {};
                    }
                    (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                        return iteratee(accumulator, value, index, object);
                    });
                    return accumulator;
                }
                module1.exports = transform;
            },
            {
                "./_arrayEach": 64,
                "./_baseCreate": 81,
                "./_baseForOwn": 88,
                "./_baseIteratee": 105,
                "./_getPrototype": 164,
                "./isArray": 243,
                "./isBuffer": 246,
                "./isFunction": 248,
                "./isObject": 251,
                "./isTypedArray": 257
            }, 
        ],
        285: [
            function(require, module1, exports) {
                var baseFlatten = require("./_baseFlatten"), baseRest = require("./_baseRest"), baseUniq = require("./_baseUniq"), isArrayLikeObject = require("./isArrayLikeObject");
                /**
                     * Creates an array of unique values, in order, from all given arrays using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of combined values.
                     * @example
                     *
                     * _.union([2], [1, 2]);
                     * // => [2, 1]
                     */ var union = baseRest(function(arrays) {
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                });
                module1.exports = union;
            },
            {
                "./_baseFlatten": 86,
                "./_baseRest": 121,
                "./_baseUniq": 128,
                "./isArrayLikeObject": 245
            }, 
        ],
        286: [
            function(require, module1, exports) {
                var toString = require("./toString");
                /** Used to generate unique IDs. */ var idCounter = 0;
                /**
                     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Util
                     * @param {string} [prefix=''] The value to prefix the ID with.
                     * @returns {string} Returns the unique ID.
                     * @example
                     *
                     * _.uniqueId('contact_');
                     * // => 'contact_104'
                     *
                     * _.uniqueId();
                     * // => '105'
                     */ function uniqueId(prefix) {
                    var id = ++idCounter;
                    return toString(prefix) + id;
                }
                module1.exports = uniqueId;
            },
            {
                "./toString": 283
            }, 
        ],
        287: [
            function(require, module1, exports) {
                var baseValues = require("./_baseValues"), keys = require("./keys");
                /**
                     * Creates an array of the own enumerable string keyed property values of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property values.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.values(new Foo);
                     * // => [1, 2] (iteration order is not guaranteed)
                     *
                     * _.values('hi');
                     * // => ['h', 'i']
                     */ function values(object) {
                    return object == null ? [] : baseValues(object, keys(object));
                }
                module1.exports = values;
            },
            {
                "./_baseValues": 129,
                "./keys": 259
            }, 
        ],
        288: [
            function(require, module1, exports) {
                var assignValue = require("./_assignValue"), baseZipObject = require("./_baseZipObject");
                /**
                     * This method is like `_.fromPairs` except that it accepts two arrays,
                     * one of property identifiers and one of corresponding values.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.4.0
                     * @category Array
                     * @param {Array} [props=[]] The property identifiers.
                     * @param {Array} [values=[]] The property values.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * _.zipObject(['a', 'b'], [1, 2]);
                     * // => { 'a': 1, 'b': 2 }
                     */ function zipObject(props, values) {
                    return baseZipObject(props || [], values || [], assignValue);
                }
                module1.exports = zipObject;
            },
            {
                "./_assignValue": 75,
                "./_baseZipObject": 130
            }, 
        ]
    }, {}, [
        1
    ])(1);
});

},{}],"1p6vn":[function(require,module,exports) {
(()=>{
    var e = {
        885: (e, t, r)=>{
            e.exports = {
                components: r(615).w,
                dijkstra: r(83).dijkstra,
                dijkstraAll: r(521).o,
                findCycles: r(323).S,
                floydWarshall: r(259).q,
                isAcyclic: r(194).u,
                postorder: r(761).B,
                preorder: r(787).e,
                prim: r(269).V,
                tarjan: r(22).tarjan,
                topsort: r(86).topsort
            };
        },
        568: (e, t, r)=>{
            e.exports = {
                Graph: r(393).Graph,
                json: {
                    read: r(318).ij,
                    write: r(318).cW
                },
                alg: r(885),
                version: r(809).i
            };
        },
        615: (e, t)=>{
            "use strict";
            t.w = void 0, t.w = function(e) {
                var t, r = {}, s = [];
                function i(s) {
                    r.hasOwnProperty(s) || (r[s] = !0, t.push(s), e.successors(s).forEach(i), e.predecessors(s).forEach(i));
                }
                return e.nodes().forEach(function(e) {
                    t = [], i(e), t.length && s.push(t);
                }), s;
            };
        },
        917: (e, t)=>{
            "use strict";
            function r(e, t, s, i, n, o) {
                i.hasOwnProperty(t) || (i[t] = !0, s || o.push(t), n(t).forEach(function(t) {
                    r(e, t, s, i, n, o);
                }), s && o.push(t));
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.dfs = void 0, t.dfs = function(e, t, s) {
                let i;
                i = Array.isArray(t) ? t : [
                    t
                ];
                var n = (e.isDirected() ? e.successors : e.neighbors).bind(e), o = [], h = {};
                return i.forEach(function(t) {
                    if (!e.hasNode(t)) throw new Error("Graph does not have node: " + t);
                    r(e, t, "post" === s, h, n, o);
                }), o;
            };
        },
        521: (e, t, r)=>{
            "use strict";
            t.o = void 0;
            const s = r(83);
            t.o = function(e, t, r) {
                return e.nodes().reduce(function(i, n) {
                    return i[n] = (0, s.dijkstra)(e, n, t, r), i;
                }, {});
            };
        },
        83: (e, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.dijkstra = void 0;
            const s = r(67);
            var i = ()=>1;
            t.dijkstra = function(e, t, r = i, n = function(t) {
                return e.outEdges(t);
            }) {
                return function(e, t, r, i) {
                    var n, o, h = {}, a = new s.PriorityQueue(), d = function(e) {
                        var t = e.v !== n ? e.v : e.w, s = h[t], i = r(e), d = o.distance + i;
                        if (i < 0) throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e + " Weight: " + i);
                        d < s.distance && (s.distance = d, s.predecessor = n, a.decrease(t, d));
                    };
                    for(e.nodes().forEach(function(e) {
                        var r = e === t ? 0 : Number.POSITIVE_INFINITY;
                        h[e] = {
                            distance: r
                        }, a.add(e, r);
                    }); a.size() > 0 && (n = a.removeMin(), (o = h[n]).distance !== Number.POSITIVE_INFINITY);)i(n).forEach(d);
                    return h;
                }(e, String(t), r, n);
            };
        },
        323: (e, t, r)=>{
            "use strict";
            t.S = void 0;
            const s = r(22);
            t.S = function(e) {
                return (0, s.tarjan)(e).filter(function(t) {
                    return t.length > 1 || 1 === t.length && e.hasEdge(t[0], t[0]);
                });
            };
        },
        259: (e, t)=>{
            "use strict";
            t.q = void 0;
            var r = ()=>1;
            t.q = function(e, t = r, s = function(t) {
                return e.outEdges(t);
            }) {
                return function(e, t, r) {
                    var s = {}, i = e.nodes();
                    return i.forEach(function(e) {
                        s[e] = {}, s[e][e] = {
                            distance: 0
                        }, i.forEach(function(t) {
                            e !== t && (s[e][t] = {
                                distance: Number.POSITIVE_INFINITY
                            });
                        }), r(e).forEach(function(r) {
                            var i = r.v === e ? r.w : r.v, n = t(r);
                            s[e][i] = {
                                distance: n,
                                predecessor: e
                            };
                        });
                    }), i.forEach(function(e) {
                        var t = s[e];
                        i.forEach(function(r) {
                            var n = s[r];
                            i.forEach(function(r) {
                                var s = n[e], i = t[r], o = n[r], h = s.distance + i.distance;
                                h < o.distance && (o.distance = h, o.predecessor = i.predecessor);
                            });
                        });
                    }), s;
                }(e, t, s);
            };
        },
        194: (e, t, r)=>{
            "use strict";
            t.u = void 0;
            const s = r(86);
            t.u = function(e) {
                try {
                    (0, s.topsort)(e);
                } catch (e1) {
                    if (e1 instanceof s.topsort.CycleException) return !1;
                    throw e1;
                }
                return !0;
            };
        },
        761: (e, t, r)=>{
            "use strict";
            t.B = void 0;
            const s = r(917);
            t.B = function(e, t) {
                return (0, s.dfs)(e, t, "post");
            };
        },
        787: (e, t, r)=>{
            "use strict";
            t.e = void 0;
            const s = r(917);
            t.e = function(e, t) {
                return (0, s.dfs)(e, t, "pre");
            };
        },
        269: (e, t, r)=>{
            "use strict";
            t.V = void 0;
            const s = r(393), i = r(67);
            t.V = function(e, t) {
                var r, n = new s.Graph(), o = {}, h = new i.PriorityQueue();
                function a(e) {
                    var s = e.v === r ? e.w : e.v, i = h.priority(s);
                    if (void 0 !== i) {
                        var n = t(e);
                        n < i && (o[s] = r, h.decrease(s, n));
                    }
                }
                if (0 === e.nodeCount()) return n;
                e.nodes().forEach(function(e) {
                    h.add(e, Number.POSITIVE_INFINITY), n.setNode(e);
                }), h.decrease(e.nodes()[0], 0);
                for(var d = !1; h.size() > 0;){
                    if (r = h.removeMin(), o.hasOwnProperty(r)) n.setEdge(r, o[r]);
                    else {
                        if (d) throw new Error("Input graph is not connected: " + e);
                        d = !0;
                    }
                    e.nodeEdges(r).forEach(a);
                }
                return n;
            };
        },
        22: (e, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.tarjan = void 0, t.tarjan = function(e) {
                var t = 0, r = [], s = {}, i = [];
                function n(o) {
                    var h = s[o] = {
                        onStack: !0,
                        lowlink: t,
                        index: t++
                    };
                    if (r.push(o), e.successors(o).forEach(function(e) {
                        s.hasOwnProperty(e) ? s[e].onStack && (h.lowlink = Math.min(h.lowlink, s[e].index)) : (n(e), h.lowlink = Math.min(h.lowlink, s[e].lowlink));
                    }), h.lowlink === h.index) {
                        var a, d = [];
                        do a = r.pop(), s[a].onStack = !1, d.push(a);
                        while (o !== a);
                        i.push(d);
                    }
                }
                return e.nodes().forEach(function(e) {
                    s.hasOwnProperty(e) || n(e);
                }), i;
            };
        },
        86: (e, t)=>{
            "use strict";
            function r(e) {
                var t = {}, r = {}, i = [];
                if (e.sinks().forEach(function n(o) {
                    if (r.hasOwnProperty(o)) throw new s();
                    t.hasOwnProperty(o) || (r[o] = !0, t[o] = !0, e.predecessors(o).forEach(n), delete r[o], i.push(o));
                }), Object.keys(t).length !== e.nodeCount()) throw new s();
                return i;
            }
            function s() {}
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.topsort = void 0, r.CycleException = s, t.topsort = r, s.prototype = new Error();
        },
        67: (e, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PriorityQueue = void 0, t.PriorityQueue = class {
                constructor(){
                    this._arr = [], this._keyIndices = {};
                }
                size() {
                    return this._arr.length;
                }
                keys() {
                    return this._arr.map(function(e) {
                        return e.key;
                    });
                }
                has(e) {
                    return this._keyIndices.hasOwnProperty(e);
                }
                priority(e) {
                    var t = this._keyIndices[e];
                    if (void 0 !== t) return this._arr[t].priority;
                }
                min() {
                    if (0 === this.size()) throw new Error("Queue underflow");
                    return this._arr[0].key;
                }
                add(e, t) {
                    var r = this._keyIndices;
                    if (e = String(e), !r.hasOwnProperty(e)) {
                        var s = this._arr, i = s.length;
                        return r[e] = i, s.push({
                            key: e,
                            priority: t
                        }), this._decrease(i), !0;
                    }
                    return !1;
                }
                removeMin() {
                    this._swap(0, this._arr.length - 1);
                    var e = this._arr.pop();
                    return delete this._keyIndices[e.key], this._heapify(0), e.key;
                }
                decrease(e, t) {
                    var r = this._keyIndices[e];
                    if (t > this._arr[r].priority) throw new Error("New priority is greater than current priority. Key: " + e + " Old: " + this._arr[r].priority + " New: " + t);
                    this._arr[r].priority = t, this._decrease(r);
                }
                _heapify(e) {
                    var t = this._arr, r = 2 * e, s = r + 1, i = e;
                    r < t.length && (i = t[r].priority < t[i].priority ? r : i, s < t.length && (i = t[s].priority < t[i].priority ? s : i), i !== e && (this._swap(e, i), this._heapify(i)));
                }
                _decrease(e) {
                    for(var t, r = this._arr, s = r[e].priority; 0 !== e && !(r[t = e >> 1].priority < s);)this._swap(e, t), e = t;
                }
                _swap(e, t) {
                    var r = this._arr, s = this._keyIndices, i = r[e], n = r[t];
                    r[e] = n, r[t] = i, s[n.key] = e, s[i.key] = t;
                }
            };
        },
        393: (e, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Graph = void 0;
            var r = "\0";
            class s {
                constructor(e = {}){
                    this._defaultNodeLabelFn = ()=>{}, this._defaultEdgeLabelFn = ()=>{}, this._nodes = {}, this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {}, this._nodeCount = 0, this._edgeCount = 0, this._isDirected = !e.hasOwnProperty("directed") || e.directed, this._isMultigraph = !!e.hasOwnProperty("multigraph") && e.multigraph, this._isCompound = !!e.hasOwnProperty("compound") && e.compound, this._isCompound && (this._parent = {}, this._children = {}, this._children["\0"] = {});
                }
                isDirected() {
                    return this._isDirected;
                }
                isMultigraph() {
                    return this._isMultigraph;
                }
                isCompound() {
                    return this._isCompound;
                }
                setGraph(e) {
                    return this._label = e, this;
                }
                graph() {
                    return "object" == typeof this._label ? Object.assign({}, this._label) : this._label;
                }
                setDefaultNodeLabel(e) {
                    return this._defaultNodeLabelFn = e, "function" != typeof e && (this._defaultNodeLabelFn = ()=>e), this;
                }
                nodeCount() {
                    return this._nodeCount;
                }
                nodes() {
                    return Object.keys(this._nodes);
                }
                sources() {
                    var e = this;
                    return this.nodes().filter(function(t) {
                        return 0 === Object.keys(e._in[t]).length;
                    });
                }
                sinks() {
                    var e = this;
                    return this.nodes().filter(function(t) {
                        return 0 === Object.keys(e._out[t]).length;
                    });
                }
                setNodes(e, t) {
                    var r = arguments, s = this;
                    return e.forEach(function(e) {
                        r.length > 1 ? s.setNode(e, t) : s.setNode(e);
                    }), this;
                }
                setNode(e, t) {
                    return this._nodes.hasOwnProperty(e) ? (arguments.length > 1 && (this._nodes[e] = t), this) : (this._nodes[e] = arguments.length > 1 ? t : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = r, this._children[e] = {}, this._children["\0"][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);
                }
                node(e) {
                    return this._nodes[e];
                }
                hasNode(e) {
                    return this._nodes.hasOwnProperty(e);
                }
                removeNode(e) {
                    var t = this;
                    if (this._nodes.hasOwnProperty(e)) {
                        var r = function(e) {
                            t.removeEdge(t._edgeObjs[e]);
                        };
                        delete this._nodes[e], this._isCompound && (this._removeFromParentsChildList(e), delete this._parent[e], this.children(e).forEach(function(e) {
                            t.setParent(e);
                        }), delete this._children[e]), Object.keys(this._in[e]).forEach(r), delete this._in[e], delete this._preds[e], Object.keys(this._out[e]).forEach(r), delete this._out[e], delete this._sucs[e], --this._nodeCount;
                    }
                    return this;
                }
                setParent(e, t) {
                    if (!this._isCompound) throw new Error("Cannot set parent in a non-compound graph");
                    if (void 0 === t) t = r;
                    else {
                        for(var s = t += ""; void 0 !== s; s = this.parent(s))if (s === e) throw new Error("Setting " + t + " as parent of " + e + " would create a cycle");
                        this.setNode(t);
                    }
                    return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = t, this._children[t][e] = !0, this;
                }
                _removeFromParentsChildList(e) {
                    delete this._children[this._parent[e]][e];
                }
                parent(e) {
                    if (this._isCompound) {
                        var t = this._parent[e];
                        if (t !== r) return t;
                    }
                }
                children(e = "\0") {
                    if (this._isCompound) {
                        var t = this._children[e];
                        if (t) return Object.keys(t);
                    } else {
                        if (e === r) return this.nodes();
                        if (this.hasNode(e)) return [];
                    }
                }
                predecessors(e) {
                    var t = this._preds[e];
                    if (t) return Object.keys(t);
                }
                successors(e) {
                    var t = this._sucs[e];
                    if (t) return Object.keys(t);
                }
                neighbors(e) {
                    var t = this.predecessors(e);
                    if (t) {
                        const r = new Set(t);
                        for (const t1 of this.successors(e))r.add(t1);
                        return Array.from(r.values());
                    }
                }
                isLeaf(e) {
                    return 0 === (this.isDirected() ? this.successors(e) : this.neighbors(e)).length;
                }
                filterNodes(e) {
                    var t = new s({
                        directed: this._isDirected,
                        multigraph: this._isMultigraph,
                        compound: this._isCompound
                    });
                    t.setGraph(this.graph());
                    var r = this;
                    Object.entries(this._nodes).forEach(function([r, s]) {
                        e(r) && t.setNode(r, s);
                    }), Object.values(this._edgeObjs).forEach(function(e) {
                        t.hasNode(e.v) && t.hasNode(e.w) && t.setEdge(e, r.edge(e));
                    });
                    var i = {};
                    function n(e) {
                        var s = r.parent(e);
                        return void 0 === s || t.hasNode(s) ? (i[e] = s, s) : s in i ? i[s] : n(s);
                    }
                    return this._isCompound && t.nodes().forEach(function(e) {
                        t.setParent(e, n(e));
                    }), t;
                }
                setDefaultEdgeLabel(e) {
                    return this._defaultEdgeLabelFn = e, "function" != typeof e && (this._defaultEdgeLabelFn = ()=>e), this;
                }
                edgeCount() {
                    return this._edgeCount;
                }
                edges() {
                    return Object.values(this._edgeObjs);
                }
                setPath(e, t) {
                    var r = this, s = arguments;
                    return e.reduce(function(e, i) {
                        return s.length > 1 ? r.setEdge(e, i, t) : r.setEdge(e, i), i;
                    }), this;
                }
                setEdge(e, t, r, s) {
                    var n, h, a, d, u = !1, c = arguments[0];
                    "object" == typeof c && null !== c && "v" in c ? (n = c.v, h = c.w, a = c.name, 2 === arguments.length && (d = arguments[1], u = !0)) : (n = c, h = arguments[1], a = arguments[3], arguments.length > 2 && (d = arguments[2], u = !0)), n = "" + n, h = "" + h, void 0 !== a && (a = "" + a);
                    var f = o(this._isDirected, n, h, a);
                    if (this._edgeLabels.hasOwnProperty(f)) return u && (this._edgeLabels[f] = d), this;
                    if (void 0 !== a && !this._isMultigraph) throw new Error("Cannot set a named edge when isMultigraph = false");
                    this.setNode(n), this.setNode(h), this._edgeLabels[f] = u ? d : this._defaultEdgeLabelFn(n, h, a);
                    var p = function(e, t, r, s) {
                        var i = "" + t, n = "" + r;
                        if (!e && i > n) {
                            var o = i;
                            i = n, n = o;
                        }
                        var h = {
                            v: i,
                            w: n
                        };
                        return s && (h.name = s), h;
                    }(this._isDirected, n, h, a);
                    return n = p.v, h = p.w, Object.freeze(p), this._edgeObjs[f] = p, i(this._preds[h], n), i(this._sucs[n], h), this._in[h][f] = p, this._out[n][f] = p, this._edgeCount++, this;
                }
                edge(e, t, r) {
                    var s = 1 === arguments.length ? h(this._isDirected, arguments[0]) : o(this._isDirected, e, t, r);
                    return this._edgeLabels[s];
                }
                hasEdge(e, t, r) {
                    var s = 1 === arguments.length ? h(this._isDirected, arguments[0]) : o(this._isDirected, e, t, r);
                    return this._edgeLabels.hasOwnProperty(s);
                }
                removeEdge(e, t, r) {
                    var s = 1 === arguments.length ? h(this._isDirected, arguments[0]) : o(this._isDirected, e, t, r), i = this._edgeObjs[s];
                    if (i) {
                        const e1 = i.v, t1 = i.w;
                        delete this._edgeLabels[s], delete this._edgeObjs[s], n(this._preds[t1], e1), n(this._sucs[e1], t1), delete this._in[t1][s], delete this._out[e1][s], this._edgeCount--;
                    }
                    return this;
                }
                inEdges(e, t) {
                    var r = this._in[e];
                    if (r) {
                        var s = Object.values(r);
                        return t ? s.filter(function(e) {
                            return e.v === t;
                        }) : s;
                    }
                }
                outEdges(e, t) {
                    var r = this._out[e];
                    if (r) {
                        var s = Object.values(r);
                        return t ? s.filter(function(e) {
                            return e.w === t;
                        }) : s;
                    }
                }
                nodeEdges(e, t) {
                    var r = this.inEdges(e, t);
                    if (r) return r.concat(this.outEdges(e, t));
                }
            }
            function i(e, t) {
                e[t] ? e[t]++ : e[t] = 1;
            }
            function n(e, t) {
                --e[t] || delete e[t];
            }
            function o(e, t, r, s) {
                var i = "" + t, n = "" + r;
                if (!e && i > n) {
                    var o = i;
                    i = n, n = o;
                }
                return i + "\x01" + n + "\x01" + (void 0 === s ? "\0" : s);
            }
            function h(e, t) {
                return o(e, t.v, t.w, t.name);
            }
            t.Graph = s;
        },
        318: (e, t, r)=>{
            "use strict";
            t.ij = t.cW = void 0;
            const s = r(393);
            function i(e) {
                return e.nodes().map(function(t) {
                    var r = e.node(t), s = e.parent(t), i = {
                        v: t
                    };
                    return void 0 !== r && (i.value = r), void 0 !== s && (i.parent = s), i;
                });
            }
            function n(e) {
                return e.edges().map(function(t) {
                    var r = e.edge(t), s = {
                        v: t.v,
                        w: t.w
                    };
                    return void 0 !== t.name && (s.name = t.name), void 0 !== r && (s.value = r), s;
                });
            }
            t.cW = function(e) {
                var t = {
                    options: {
                        directed: e.isDirected(),
                        multigraph: e.isMultigraph(),
                        compound: e.isCompound()
                    },
                    nodes: i(e),
                    edges: n(e)
                };
                return void 0 !== e.graph() && (t.value = e.graph()), t;
            }, t.ij = function(e) {
                var t = new s.Graph(e.options).setGraph(e.value);
                return e.nodes.forEach(function(e) {
                    t.setNode(e.v, e.value), e.parent && t.setParent(e.v, e.parent);
                }), e.edges.forEach(function(e) {
                    t.setEdge({
                        v: e.v,
                        w: e.w,
                        name: e.name
                    }, e.value);
                }), t;
            };
        },
        809: (e, t)=>{
            "use strict";
            t.i = void 0, t.i = "2.1.9-pre";
        }
    }, t = {}, r = function r(s) {
        var i = t[s];
        if (void 0 !== i) return i.exports;
        var n = t[s] = {
            exports: {}
        };
        return e[s](n, n.exports, r), n.exports;
    }(568);
    graphlib = r;
})();

},{}],"1j8D1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "qnaFlowPaper", ()=>//qna
    qnaFlowPaper);
parcelHelpers.export(exports, "qnaFlowGraph", ()=>qnaFlowGraph);
parcelHelpers.export(exports, "qnaFlowContainer", ()=>qnaFlowContainer);
parcelHelpers.export(exports, "stencilPaper", ()=>//stencil
    stencilPaper);
parcelHelpers.export(exports, "stencilGraph", ()=>stencilGraph);
parcelHelpers.export(exports, "stencilContainer", ()=>stencilContainer);
parcelHelpers.export(exports, "togglerRight", ()=>//togglers
    togglerRight);
parcelHelpers.export(exports, "togglerLeft", ()=>togglerLeft);
parcelHelpers.export(exports, "elementTopic", ()=>//toggler-elements
    elementTopic);
parcelHelpers.export(exports, "elemnentCoordinates", ()=>elemnentCoordinates);
parcelHelpers.export(exports, "allElements", ()=>// qnaFunctions
    allElements);
parcelHelpers.export(exports, "removeElements", ()=>removeElements);
parcelHelpers.export(exports, "scaleToFitButton", ()=>// buttons
    scaleToFitButton);
parcelHelpers.export(exports, "autoArrangeButton", ()=>autoArrangeButton);
parcelHelpers.export(exports, "saveGraphButton", ()=>saveGraphButton);
var _global = require("./global");
var _paperServices = require("./services/paper-services");
var _paperServicesDefault = parcelHelpers.interopDefault(_paperServices);
var _elementServices = require("./services/element-services");
var _elementServicesDefault = parcelHelpers.interopDefault(_elementServices);
// Variables
// -- qna
const qnaFlowContainer = document.querySelector(".rf-qna-flow-container");
const qnaFlowGraph = new (0, _global.dia).Graph({}, {
    cellNamespace: (0, _global.shapes)
});
const qnaFlowPaper = (0, _paperServicesDefault.default).createPaper(qnaFlowGraph, "doubleMesh");
qnaFlowPaper.paperType = "qna";
qnaFlowContainer.appendChild(qnaFlowPaper.el);
// V(qnaFlowPaper.viewport).translate(100,100);
// Scroll to middle of the qna-flow-paper
qnaFlowContainer.scrollTo((qnaFlowContainer.scrollWidth - qnaFlowContainer.clientWidth) / 2, (qnaFlowContainer.scrollHeight - qnaFlowContainer.clientHeight) / 2);
// -- stencil
const stencilContainer = document.querySelector(".rf-qna-flow-left-bar-content .element-container .stencil");
const stencilGraph = new (0, _global.dia).Graph({}, {
    cellNamespace: (0, _global.shapes)
});
const stencilPaper = new (0, _global.dia).Paper({
    el: stencilContainer,
    //    height: 60,
    model: stencilGraph,
    interactive: false,
    width: 200,
    height: "95vh"
});
// -- togglers
const togglerRight = document.querySelector(".rf-qna-flow-right-bar-toggler");
const togglerLeft = document.querySelector(".rf-qna-flow-left-bar-toggler");
// -- right toggler elements
const elementTopic = document.querySelector("#element-topic");
const elemnentCoordinates = document.querySelector("#element-coordinates");
// buttons
const scaleToFitButton = document.querySelector("#scaleToFit");
const autoArrangeButton = document.querySelector("#autoArrange");
const saveGraphButton = document.querySelector("#saveGraph");
// qnaFunctions
// -- qna
const removeElements = function(elements) {
    qnaFlowGraph.removeLinks(elements);
    qnaFlowGraph.removeCells(qnaFlowGraph.getCell(elements.model.id));
};
// -- Stencil elements
const question = (0, _elementServicesDefault.default).createElement(null, "stencilQuestion");
question.shape.addTo(stencilGraph);

},{"./global":"fagbk","./services/paper-services":"egmsL","./services/element-services":"3KrQq","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"egmsL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _global = require("../global");
var _linkServices = require("./link-services");
var _linkServicesDefault = parcelHelpers.interopDefault(_linkServices);
exports.default = {
    createPaper: function(graph, drawGridName, backgroundColor) {
        return new (0, _global.dia).Paper({
            model: graph,
            cellViewNamespace: (0, _global.shapes),
            width: /* "100%" */ (0, _global.contentPaperWidth),
            height: /* "100%" */ (0, _global.contentPaperHeight),
            gridSize: (0, _global.gridSize),
            drawGrid: drawGridName ? {
                name: drawGridName,
                args: [
                    {
                        color: "red",
                        thickness: 0.5
                    },
                    {
                        color: "green",
                        scaleFactor: 5,
                        thickness: 0.6
                    }
                ]
            } : false,
            async: true,
            sorting: (0, _global.dia).Paper.sorting.APPROX,
            background: {
                color: backgroundColor ? backgroundColor : "#F3F7F6"
            },
            defaultLink: ()=>(0, _linkServicesDefault.default).createLink(),
            // validateConnection: (sv, _sm, tv, _tm) => sv !== tv,
            linkPinning: false,
            defaultAnchor: {
                name: "perpendicular"
            },
            validateConnection: function(cellViewS, magnetS, cellViewT, magnetT, end, linkView) {
                // Prevent linking from input ports
                if (magnetS && magnetS.getAttribute("port-group") === "in") return false;
                // Prevent linking from output ports to input ports within one element
                if (cellViewS === cellViewT) return false;
                // Prevent linking to output ports
                return magnetT && magnetT.getAttribute("port-group") === "in";
            },
            validateMagnet: function(cellView, magnet) {
                // Note that this is the default behaviour. It is shown for reference purposes.
                // Disable linking interaction for magnets marked as passive
                return magnet.getAttribute("magnet") !== "passive";
            },
            snapLinks: {
                radius: 20
            }
        });
    }
};

},{"../global":"fagbk","./link-services":"2dZPw","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"2dZPw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _global = require("../global");
exports.default = {
    createLink: (source, target)=>{
        return new (0, _global.shapes).standard.Link({
            source: source === null ? null : {
                id: source,
                port: `out-default-${source}`
            },
            target: target === null ? null : {
                id: target,
                port: `in-default-${target}`
            },
            router: {
                name: "manhattan"
            },
            connector: {
                name: "rounded"
            }
        });
    },
    setAttribute: (el, attr)=>{
        el.attr(attr);
    }
};

},{"../global":"fagbk","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"3KrQq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constants = require("../constants");
var _elements = require("../utils/elements");
var _elementToolsServices = require("./element-tools-services");
exports.default = {
    shape: {},
    createElement: function(data, type) {
        this.shape = type ?? (0, _elements.defaultQuestion)(data);
        if (type) switch(type){
            case "question":
                this.shape = (0, _elements.defaultQuestion)(data);
                this.addPorts([
                    {
                        id: `in-default-${this.shape.id}`,
                        group: "in"
                    },
                    {
                        id: `out-default-${this.shape.id}`,
                        group: "out"
                    }, 
                ]);
                break;
            case "stencilQuestion":
                this.shape = (0, _elements.stencilQuestion)();
        }
        window.elementCount += 1;
        return this;
    },
    addPorts: function(ports) {
        this.shape.prop([
            "ports",
            "items"
        ], [
            ...ports
        ], {
            rewrite: true
        });
        return this;
    },
    addElementTools: function(selected) {
        this.shape.addTo((0, _constants.qnaFlowGraph)).findView((0, _constants.qnaFlowPaper)).addTools((0, _elementToolsServices.getToolsWhenNotSelected)(selected));
        return this;
    },
    addStyle: function() {
        return this;
    }
};

},{"../constants":"1j8D1","../utils/elements":"laOqU","./element-tools-services":"kTyMb","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"laOqU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultQuestion", ()=>defaultQuestion);
parcelHelpers.export(exports, "stencilQuestion", ()=>stencilQuestion);
var _global = require("../global");
var _portServices = require("../services/port-services");
const defaultQuestion = (data)=>new (0, _global.shapes).standard.Rectangle({
        position: {
            x: data.x,
            y: data.y
        },
        size: {
            width: (0, _global.elementWidth),
            height: (0, _global.elementHeight)
        },
        attrs: {
            root: {
                magnet: false
            },
            body: {
                strokeWidth: 0.5,
                fill: "#fff",
                rx: 5,
                ry: 5,
                filter: {
                    name: "dropShadow",
                    args: {
                        dx: 2,
                        dy: 2,
                        blur: 3
                    }
                }
            },
            label: {
                // fontWeight: "bold",
                // textAnchor: "left", // align text to left
                // x: 5, // offset text from right edge of model bbox
                fontSize: 11,
                fontFamily: "sans-serif",
                fill: "#000",
                // stroke: "#333333",
                // strokeWidth: 5,
                // paintOrder: "stroke",
                text: data.text.Topic,
                position: {
                    name: "left",
                    args: {
                        y: 0
                    }
                },
                markup: [
                    {
                        tagName: "text",
                        selector: "label",
                        className: "label-text"
                    }, 
                ]
            }
        },
        ports: {
            groups: {
                in: (0, _portServices.getDefaultInPort)(),
                out: (0, _portServices.getDefaultOutPort)()
            },
            items: [
                {
                    group: "in"
                },
                {
                    group: "out"
                }
            ]
        }
    });
const stencilQuestion = ()=>new (0, _global.shapes).standard.Rectangle({
        position: {
            x: 10,
            y: 30
        },
        size: {
            width: 80,
            height: 40
        },
        attrs: {
            body: {
                rx: 10,
                ry: 10,
                fill: "#ADD8E6"
            },
            label: {
                text: "Question"
            }
        }
    });

},{"../global":"fagbk","../services/port-services":"c3rEo","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"c3rEo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDefaultInPort", ()=>getDefaultInPort);
parcelHelpers.export(exports, "getDefaultOutPort", ()=>getDefaultOutPort);
parcelHelpers.export(exports, "createPort", ()=>createPort);
var _global = require("../global");
var _elementPorts = require("../utils/element-ports");
const getDefaultInPort = ()=>(0, _elementPorts.portsIn);
const getDefaultOutPort = ()=>(0, _elementPorts.portsOut);
const createPort = (element)=>{
    const ports = element.options.model.getPorts().length - 1;
    const x = ports * ((0, _elementPorts.portOutDimension).width + (0, _elementPorts.portOutDimension).gap) + 20;
    let elementWidth = element.model.attributes.size.width;
    element.options.model.addPort({
        id: `out-${ports + 1}-${element.options.model.id}`,
        group: "out",
        attrs: {
            portLabel: {
                text: `${ports + 1}`
            }
        },
        args: {
            x
        }
    });
    if (ports > 4) {
        elementWidth += 10 + (0, _elementPorts.portOutDimension).width;
        element.options.model.resize(elementWidth, (0, _global.elementHeight));
    }
};

},{"../global":"fagbk","../utils/element-ports":"6jQ1H","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"6jQ1H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "portsIn", ()=>portsIn);
parcelHelpers.export(exports, "portsOut", ()=>portsOut);
parcelHelpers.export(exports, "portOutDimension", ()=>portOutDimension);
const portOutDimension = {
    width: 40,
    height: 25,
    gap: 10
};
const portsIn = {
    position: {
        name: "top",
        args: {
            x: 20
        }
    },
    attrs: {
        portBody: {
            magnet: "passive",
            r: 5,
            fill: "#ffffff",
            stroke: "#023047"
        }
    },
    label: {
        position: {
            name: "left",
            args: {
                y: 6
            }
        },
        markup: [
            {
                tagName: "text",
                selector: "label",
                className: "label-text"
            }, 
        ]
    },
    markup: [
        {
            tagName: "circle",
            selector: "portBody"
        }, 
    ]
};
const portsOut = {
    position: {
        name: "bottom",
        args: {
            x: 20,
            y: 57
        }
    },
    attrs: {
        portBody: {
            magnet: true,
            width: portOutDimension.width,
            height: portOutDimension.height,
            fill: "#E6A502",
            stroke: "#023047",
            rx: 10,
            ry: 10
        }
    },
    label: {
        position: {
            name: "manual",
            args: {
                y: 5,
                x: -5
            }
        },
        markup: [
            {
                tagName: "text",
                selector: "label",
                className: "label-text"
            }, 
        ]
    },
    markup: [
        {
            tagName: "rect",
            selector: "portBody"
        }, 
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"kTyMb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getToolsWhenSelected", ()=>getToolsWhenSelected);
parcelHelpers.export(exports, "getToolsWhenNotSelected", ()=>getToolsWhenNotSelected);
var _elementTools = require("../utils/element-tools");
var _global = require("../global");
const getToolsWhenSelected = (isElement)=>new (0, _global.dia).ToolsView({
        tools: isElement ? [
            (0, _elementTools.getBoundaryTool)(),
            (0, _elementTools.getRemoveButton)(),
            (0, _elementTools.getPortAddButton)()
        ] : [
            (0, _elementTools.getBoundaryTool)(),
            (0, _elementTools.getRemoveButton)()
        ]
    });
const getToolsWhenNotSelected = (isElement)=>new (0, _global.dia).ToolsView({
        tools: isElement ? [
            (0, _elementTools.getPortAddButton)()
        ] : []
    });

},{"../utils/element-tools":"1Q1bd","../global":"fagbk","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"1Q1bd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBoundaryTool", ()=>getBoundaryTool);
parcelHelpers.export(exports, "getRemoveButton", ()=>getRemoveButton);
parcelHelpers.export(exports, "getPortAddButton", ()=>getPortAddButton);
var _global = require("../global");
var _portServices = require("../services/port-services");
const getBoundaryTool = ()=>new (0, _global.elementTools).Boundary({
        padding: 20,
        rotate: true,
        useModelGeometry: true
    });
const getRemoveButton = ()=>new (0, _global.elementTools).Remove({
        focusOpacity: 0.5,
        rotate: true,
        // top-mid
        x: "-6.6%",
        y: "-19.3%",
        // offset: { x: -19, y: -16 },
        action: function(evt, element, button) {
            element.remove();
            window.elementCount = window.elementCount > 0 ? window.elementCount -= 1 : 0;
        }
    });
const getPortAddButton = ()=>new (0, _global.elementTools).Button({
        markup: [
            {
                tagName: "circle",
                selector: "button",
                attributes: {
                    r: 7,
                    fill: "#001DFF",
                    cursor: "pointer"
                }
            },
            {
                tagName: "path",
                selector: "icon",
                attributes: {
                    d: "M -2 4 2 4 M 0 3 0 0 M -2 -1 1 -1 M -1 -4 1 -4",
                    fill: "none",
                    stroke: "#FFFFFF",
                    "stroke-width": 2,
                    "pointer-events": "none"
                }
            }, 
        ],
        x: "96%",
        y: "85%",
        offset: {
            x: 0,
            y: 0
        },
        rotate: true,
        action: function(evt, element, button) {
            (0, _portServices.createPort)(element);
        }
    });

},{"../global":"fagbk","../services/port-services":"c3rEo","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"9r9WC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GetAIData", ()=>GetAIData);
var _global = require("../global");
var _commonServices = require("./common-services");
function GetAIData() {
    data = new (0, _global.aiData)();
    uniqueNo = (0, _commonServices.getUUID)();
    data = {
        AIDataId: uniqueNo,
        DiagramId: (0, _commonServices.getUUID)(),
        Tag: uniqueNo,
        Topic: "About Save the Children",
        Command: "",
        Hook: [],
        QuestionPattern: [
            "Bye",
            "See you later",
            "Goodbye"
        ],
        AnswerResponse: [
            "See you later, thanks for visiting",
            "Have a nice day",
            "Bye! Come back again soon.", 
        ],
        Fallback: "Sorry",
        Keywords: [
            [
                "save the children",
                "SCI"
            ],
            [
                "Founder"
            ]
        ]
    };
    console.dir(data);
    return data;
}

},{"../global":"fagbk","./common-services":"6lkTH","@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}],"6lkTH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getUUID", ()=>getUUID);
const getUUID = ()=>(String(1e7) + -1000 + -4000 + -8000 + -100000000000).replace(/[018]/g, (c)=>(Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"2IB9L"}]},["480Zd","4pp4s"], "4pp4s", "parcelRequire1e35")

//# sourceMappingURL=index.4de9b498.js.map
